<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[feifei's blog]]></title>
  <subtitle><![CDATA[才华配不上梦想这就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-03-14T05:13:34.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[feifei]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-03-14T05:13:34.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>
<a id="more"></a>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/8ZOurTlgn8RrbWoXS*BZX1J6IOluDKqIy5HvNrz*mRg!/b/dOpJsHBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/fkm63QBXo93*gpIr1Ptdcxzlq0OuPkrqkBhY.WqXWmo!/b/dO7Uq3BnEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/1LhAJQ9mFIqvqEpzyCWwgXw0IS4e*MKVXzbCTxvUyNk!/b/dGTNrnBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://b196.photo.store.qq.com/psb?/V13e7Xsb3duNUs/A4Qe**YLZomvtFndrnmyZjMRJL41EAzOSfQQZaVLpE4!/b/dN*O1HQKPwAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>]]>
    
    </summary>
    
      <category term="［宝宝］" scheme="http://www.52ff.cc/tags/%EF%BC%BB%E5%AE%9D%E5%AE%9D%EF%BC%BD/"/>
    
      <category term="生活" scheme="http://www.52ff.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为了性能尽量要做到的一些地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-14T05:07:29.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-14T05:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.图片设置成撑满整个div，使用</span><br><span class="line">``` bash</span><br><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure></p>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序</p>
<p>!important &gt; [ id &gt; class &gt; tag ]  </p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简陋的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-12T15:55:35.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/categories/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-14T04:57:52.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。<br><a id="more"></a></p>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<h3 id="CentOS_6-2下fastDFS的完整安装和配置步骤">CentOS 6.2下fastDFS的完整安装和配置步骤</h3><p><a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a></p>
<h3 id="FastDFS在Ubuntu下的安装，PHP客户端">FastDFS在Ubuntu下的安装，PHP客户端</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a></p>
<h3 id="FastDFS分布式文件服务器安装，及配置，测试">FastDFS分布式文件服务器安装，及配置，测试</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a></p>
<h3 id="FastDFS_整合Nginx问题整理">FastDFS 整合Nginx问题整理</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a></p>
<h3 id="CentOS下搭建FastDFS">CentOS下搭建FastDFS</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a></p>
<h3 id="Ubuntu安装FastDFS全程记录">Ubuntu安装FastDFS全程记录</h3><p><a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。<br>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-03-14T05:23:49.000Z</updated>
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><p>save：将数据同步保存到磁盘<br>bgsave：将数据异步保存到磁盘<br>lastsave：返回上次成功将数据保存到磁盘的Unix时戳<br>shundown：将数据同步保存到磁盘，然后关闭服务</p>
<h3 id="远程服务控制">远程服务控制</h3><p>info：提供服务器的信息和统计<br>monitor：实时转储收到的请求<br>slaveof：改变复制策略设置<br>config：在运行时配置Redis服务器</p>
<h3 id="对value操作的命令">对value操作的命令</h3><p>exists(key)：确认一个key是否存在<br>del(key)：删除一个key<br>type(key)：返回值的类型<br>keys(pattern)：返回满足给定pattern的所有key<br>randomkey：随机返回key空间的一个<br>keyrename(oldname, newname)：重命名key<br>dbsize：返回当前数据库中key的数目<br>expire：设定一个key的活动时间（s）<br>ttl：获得一个key的活动时间<br>select(index)：按索引查询<br>move(key, dbindex)：移动当前数据库中的key到dbindex数据库<br>flushdb：删除当前选择数据库中的所有key<br>flushall：删除所有数据库中的所有key</p>
<h3 id="对String操作的命令">对String操作的命令</h3><p>set(key, value)：给数据库中名称为key的string赋予值value<br>get(key)：返回数据库中名称为key的string的value<br>getset(key, value)：给名称为key的string赋予上一次的value<br>mget(key1, key2,…, key N)：返回库中多个string的value<br>setnx(key, value)：添加string，名称为key，值为value<br>setex(key, time, value)：向库中添加string，设定过期时间time<br>mset(key N, value N)：批量设置多个string的值<br>msetnx(key N, value N)：如果所有名称为key i的string都不存在<br>incr(key)：名称为key的string增1操作<br>incrby(key, integer)：名称为key的string增加integer<br>decr(key)：名称为key的string减1操作<br>decrby(key, integer)：名称为key的string减少integer<br>append(key, value)：名称为key的string的值附加value<br>substr(key, start, end)：返回名称为key的string的value的子串</p>
<h3 id="对List操作的命令">对List操作的命令</h3><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素<br>lpush(key, value)：在名称为key的list头添加一个值为value的 元素<br>llen(key)：返回名称为key的list的长度<br>lrange(key, start, end)：返回名称为key的list中start至end之间的元素<br>ltrim(key, start, end)：截取名称为key的list<br>lindex(key, index)：返回名称为key的list中index位置的元素<br>lset(key, index, value)：给名称为key的list中index位置的元素赋值<br>lrem(key, count, value)：删除count个key的list中值为value的元素<br>lpop(key)：返回并删除名称为key的list中的首元素<br>rpop(key)：返回并删除名称为key的list中的尾元素<br>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。<br>brpop(key1, key2,… key N, timeout)：rpop的block版本。<br>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p>
<h3 id="对Set操作的命令">对Set操作的命令</h3><p>sadd(key, member)：向名称为key的set中添加元素member<br>srem(key, member) ：删除名称为key的set中的元素member<br>spop(key) ：随机返回并删除名称为key的set中一个元素<br>smove(srckey, dstkey, member) ：移到集合元素<br>scard(key) ：返回名称为key的set的基数<br>sismember(key, member) ：member是否是名称为key的set的元素<br>sinter(key1, key2,…key N) ：求交集<br>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合<br>sunion(key1, (keys)) ：求并集<br>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合<br>sdiff(key1, (keys)) ：求差集<br>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合<br>smembers(key) ：返回名称为key的set的所有元素<br>srandmember(key) ：随机返回名称为key的set的一个元素</p>
<h3 id="对Hash操作的命令">对Hash操作的命令</h3><p>hset(key, field, value)：向名称为key的hash中添加元素field<br>hget(key, field)：返回名称为key的hash中field对应的value<br>hmget(key, (fields))：返回名称为key的hash中field i对应的value<br>hmset(key, (fields))：向名称为key的hash中添加元素field<br>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer<br>hexists(key, field)：名称为key的hash中是否存在键为field的域<br>hdel(key, field)：删除名称为key的hash中键为field的域<br>hlen(key)：返回名称为key的hash中元素个数<br>hkeys(key)：返回名称为key的hash中所有键<br>hvals(key)：返回名称为key的hash中所有键对应的value<br>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo]]></title>
    <link href="http://www.52ff.cc/2015/03/06/hello-world/"/>
    <id>http://www.52ff.cc/2015/03/06/hello-world/</id>
    <published>2015-03-06T09:32:47.000Z</published>
    <updated>2015-03-14T05:28:44.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[重写hashcode()与equals()]]></title>
    <link href="http://www.52ff.cc/2012/03/12/%E9%87%8D%E5%86%99hashcode()%E4%B8%8Eequals()/"/>
    <id>http://www.52ff.cc/2012/03/12/重写hashcode()与equals()/</id>
    <published>2012-03-12T03:51:08.000Z</published>
    <updated>2015-03-14T05:08:52.000Z</updated>
    <content type="html"><![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>
<a id="more"></a>
<p>首先，这两个方法都来自于Object对象，根据API文档查看下原意。(1)public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。（2）public int hashCode() 返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p>
<p>我的理解是hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写hashcode。为了保证这种一致性，必须满足以下两个条件：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class BeanA &#123;</span><br><span class="line">private int i;</span><br><span class="line">public BeanA(int i) &#123;</span><br><span class="line">   this.i = i;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"   "</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">   BeanA a = (BeanA) o;</span><br><span class="line">   <span class="built_in">return</span> (a.i == i) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   HashSet&lt;BeanA&gt; <span class="built_in">set</span> = new HashSet&lt;BeanA&gt;();</span><br><span class="line">   <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    set.add(new BeanA(i));</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">   set.add(new BeanA(<span class="number">1</span>));</span><br><span class="line">   System.out.println(set.toString());</span><br><span class="line">   System.out.println(set.contains(new BeanA(<span class="number">0</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">1</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">4</span>)));</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在类BeanA中重写了equals和hashcode方法，这样在存储到HashSet数据集中，将保证不会出现重复的数据；如果把这两个方法去掉后，那些重复的数据仍会存入HashSet中，这就与HashSet强调的元素唯一性相违背，大家可以把这两个方法注释掉再运行一下。<br>因此，我们就可以理解在一些java类中什么情况下需要重写equals和hashcode。比如：在hibernate的实体类中，往往通过一个主键（或唯一标识符）来判断数据库的某一行，这就需要重写这两个方法。因为，Hibernate保证，仅在特定会话范围内，持久化标识（数据库的行）和Java标识是等价的。因此，一旦我们混合了从不同会话中获取的实例，如果希望Set有明确的语义，就必 须实现equals() 和hashCode()。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mina多线程池]]></title>
    <link href="http://www.52ff.cc/2012/02/12/mina%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.52ff.cc/2012/02/12/mina多线程池/</id>
    <published>2012-02-12T02:51:08.000Z</published>
    <updated>2015-03-14T05:09:05.000Z</updated>
    <content type="html"><![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>
<a id="more"></a>
<p>Mina 的多级线程池<br>在基于 SocketAcceptor 的应用程序中运行过程中 Mina 框架本身会有两种类型的线程在运行<br>一种是在SocketAcceptor 中创建的用于监听并接收来自客户端请求的线程。还有一类线程是处理客户端与服务器端 I/O 的线程即 Processor 的处理线程。后面还有第三类，就是过滤器层的线程。<br>这个多级的概念后面你会体会到Acceptor 是一级线程池而 Processor 的线程池主要通过 ExecutorFileter 进行添加当然可以添加多个层次的线程池。下面逐层进行讲解。</p>
<p>第一类线程池<br>当调用 SocketAcceptor 的 bind 方法时默认会创建一个名称前缀为 SocketAcceptor 的线程该线程负责监听来自客户端的请求如果接收到客户端的请求它仅仅是为处理这个请求做好准备而把具体处理请求以及I/O 的任务代理给 SocketIoProcessor 让它去处理请求。这个准备过程主要是为接受到的请求创建一个   IoSession 并构建出 IoFilter 链然后把准备好的数据以及来自客户端的请求交给 SocketIoProcessor 处理。通常 这类线程会针对每一次的 bind 调用创建一个新的线程。 请注意 “通常 ” 二字使用这两个字说明上述的行为不是绝对的。的确这不是绝对的这取决于SocketAcceptor 的字段 executor 的实现可以通过构造方法来设置字段 executor 的值 executor 字段的类型为 java.util.concurrent.Executor 。 mina 默认是用 org.apache.mina.util.NewThreadExecutor 它会为每一个提交的任务创建一个新的线程。因为在 bind 方法中它会把实现监听客户端请求任务的 Runnable 提交到 executor中去执行。注意千万不要使用一个不创建新线程而是在原线程中执行的 Executor 这会使程序无法监听客户端的请求因为程序中的唯一线程会被 Selector.get() 方法所阻塞详情可以查看 SocketAcceptor 类的源代码。</p>
<p>第二类线程池<br> 当 SocketAcceptor 收到了来自客户端的请求它就会把此请求丢给 SocketIoProcessor 去处理这会创建名称以 SocketAcceptorIoProcessor 为前缀的线程 mina 框架在这类线程中处理 I/O 发布并处理事件。这一类线程的数量可以通过 SocketAcceptor 的构造函数来设置。具体的值可以根据应用的具体需求来决定。 作为 I/O 真正处理的线程存在于服务器端和客户端用来处理 I/O 的读写操作线程的数量是可以配置的默认最大数量是 CPU 个数 +1 。 在服务器端中在创建 SocketAcceptor 的时候指定 ProcessorCount 。<br>SocketAcceptor acceptor = new SocketAcceptor(Runtime.getRuntime().availableProcessors() + 1, Executors.newCachedThreadPool()); NioProcessor 虽然是多线程但是对与一个连接的时候业务处理只会使用一个线程进行处理 Processor线程对于一个客户端连接只使用一个线程 NioProcessor-n 如果 handler 的业务比较耗时会导致NioProcessor 线程堵塞 在 2 个客户端同时连接上来的时候会创建第 2 个前提是第 1 个 NioProcessor 正在忙创建的最大数量由 Acceptor 构造方法的时候指定。如果一个客户端连接同服务器端有很多通信并且I/O 的开销不大但是 Handler 处理的业务时间比较长那么需要采用独立的线程模式在 FilterChain 的最后增加一个 ExecutorFitler 这个就是第三类线程池了。</p>
<p>第三类线程池<br>上述的两类线程是 mina 框架本身所创建的如果你的应用每次处理请求的时间较长而又希望应用能够有较好的响应性那么最好是把处理业务逻辑的任务放到一个新的线程中去执行而不是在 mina 框架创建的线程中去执行。 mina 框架本身提供了一个过滤器 ExecutorFilter 来完成这样的任务它会把在此之后的过滤器以及IoHandler 中处理业务逻辑的代码放到一个新的线程中去执行。当 mina 框架中的第二类线程执行完此过滤器后就会立即返回可以用于处理新的请求。如果不想使用此过滤器还可以设置 mina 的线程模型来达到相同的效果其实线程模型也是使用 ExecutorFilter 实现的。但需要注意的是在 mina 2.0 版本中已经废弃了线程模型。 使用类这三次线程池性能可以得到保证了在本项目中主要配置了第二类线程池和第三类线程池。第二类线程池在新建 NioAcceptor 对象以建立 TCP 监听服务器为例时候在其构造函数中体现而这个数值需要多次测试来设定其测试方法在国外网站有完整表述请自行 Google 第三类线程池设定在 Apache Mina 的过滤器层一般而言只需要设置一层设置在最消耗时间的业务前面如比较复杂的解码或者是数据库访问模块。 关于共享线程池问题 Apache Mina 有个官方说法你可以想让 IoServices 和 ExecutorFilters 共享一个线程池而不是一家一个。这个是不禁止的但是会出现很多问题在这种情况下除非你为 IoServices 建立一个缓冲线程池。 本人尚未考究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
</feed>