<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[flyfish's Blog]]></title>
  <subtitle><![CDATA[才华配不上梦想就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-03-17T17:46:42.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[xiangming]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hello Blog]]></title>
    <link href="http://www.52ff.cc/2015/03/18/hello-blog/"/>
    <id>http://www.52ff.cc/2015/03/18/hello-blog/</id>
    <published>2015-03-17T16:14:01.000Z</published>
    <updated>2015-03-17T17:46:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="为什么写博客">为什么写博客</h3><p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结<br><a id="more"></a></p>
<h3 id="为什么写独立博客？">为什么写独立博客？</h3><p>早就有弄一个独立博客的想法，但是这是一件很花时间和精力的事情，平时忙于琐碎的工作，很难抽出时间玩这个。去年发现有朋友基于bootstrap给自己做了个人站点，发现也有些其他朋友使用markdown写内容再生成静态页面。看到朋友的站点后一下子就想行动起来了，一开始玩了jekyll,后来因为一个主题和node.js选择了hexo。<br>驱使我弄独立博客主要是这几个原因：<br>1.够酷，自己的域名，门面是自己的<br>2.独立，自由，可自定义成自己喜欢的个性的样式<br>3.不会像平台博客那样，平台一变差，博客也跟着变差，更不会有广告飞<br>4.更好的记录</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="为什么写博客">为什么写博客</h3><p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结<br>]]>
    
    </summary>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-03-17T16:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>
<a id="more"></a>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/8ZOurTlgn8RrbWoXS*BZX1J6IOluDKqIy5HvNrz*mRg!/b/dOpJsHBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/fkm63QBXo93*gpIr1Ptdcxzlq0OuPkrqkBhY.WqXWmo!/b/dO7Uq3BnEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/1LhAJQ9mFIqvqEpzyCWwgXw0IS4e*MKVXzbCTxvUyNk!/b/dGTNrnBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://b196.photo.store.qq.com/psb?/V13e7Xsb3duNUs/A4Qe**YLZomvtFndrnmyZjMRJL41EAzOSfQQZaVLpE4!/b/dN*O1HQKPwAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>]]>
    
    </summary>
    
      <category term="［宝宝］" scheme="http://www.52ff.cc/tags/%EF%BC%BB%E5%AE%9D%E5%AE%9D%EF%BC%BD/"/>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为性能注意的地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-17T16:13:27.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-14T05:08:33.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.图片设置成撑满整个div，使用</span><br><span class="line">``` bash</span><br><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure></p>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序</p>
<p>!important &gt; [ id &gt; class &gt; tag ]  </p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简陋的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-12T15:55:35.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/categories/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-15T13:36:42.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>
<a id="more"></a>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<h3 id="CentOS_6-2下fastDFS的完整安装和配置步骤">CentOS 6.2下fastDFS的完整安装和配置步骤</h3><p><a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a></p>
<h3 id="FastDFS在Ubuntu下的安装，PHP客户端">FastDFS在Ubuntu下的安装，PHP客户端</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a></p>
<h3 id="FastDFS分布式文件服务器安装，及配置，测试">FastDFS分布式文件服务器安装，及配置，测试</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a></p>
<h3 id="FastDFS_整合Nginx问题整理">FastDFS 整合Nginx问题整理</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a></p>
<h3 id="CentOS下搭建FastDFS">CentOS下搭建FastDFS</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a></p>
<h3 id="Ubuntu安装FastDFS全程记录">Ubuntu安装FastDFS全程记录</h3><p><a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a></p>
<p>同事小伍哥对于FastDFS性能的测试结果如下:<br>如果用他自带的HTTP服务，并发500个下载60M的文件，服务器彻底失去响应。<br>使用Nginx+FastDFS，并发1000，下载60M的文件，内存占用不超过10M，服务器毫无压力</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-03-14T05:23:49.000Z</updated>
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><p>save：将数据同步保存到磁盘<br>bgsave：将数据异步保存到磁盘<br>lastsave：返回上次成功将数据保存到磁盘的Unix时戳<br>shundown：将数据同步保存到磁盘，然后关闭服务</p>
<h3 id="远程服务控制">远程服务控制</h3><p>info：提供服务器的信息和统计<br>monitor：实时转储收到的请求<br>slaveof：改变复制策略设置<br>config：在运行时配置Redis服务器</p>
<h3 id="对value操作的命令">对value操作的命令</h3><p>exists(key)：确认一个key是否存在<br>del(key)：删除一个key<br>type(key)：返回值的类型<br>keys(pattern)：返回满足给定pattern的所有key<br>randomkey：随机返回key空间的一个<br>keyrename(oldname, newname)：重命名key<br>dbsize：返回当前数据库中key的数目<br>expire：设定一个key的活动时间（s）<br>ttl：获得一个key的活动时间<br>select(index)：按索引查询<br>move(key, dbindex)：移动当前数据库中的key到dbindex数据库<br>flushdb：删除当前选择数据库中的所有key<br>flushall：删除所有数据库中的所有key</p>
<h3 id="对String操作的命令">对String操作的命令</h3><p>set(key, value)：给数据库中名称为key的string赋予值value<br>get(key)：返回数据库中名称为key的string的value<br>getset(key, value)：给名称为key的string赋予上一次的value<br>mget(key1, key2,…, key N)：返回库中多个string的value<br>setnx(key, value)：添加string，名称为key，值为value<br>setex(key, time, value)：向库中添加string，设定过期时间time<br>mset(key N, value N)：批量设置多个string的值<br>msetnx(key N, value N)：如果所有名称为key i的string都不存在<br>incr(key)：名称为key的string增1操作<br>incrby(key, integer)：名称为key的string增加integer<br>decr(key)：名称为key的string减1操作<br>decrby(key, integer)：名称为key的string减少integer<br>append(key, value)：名称为key的string的值附加value<br>substr(key, start, end)：返回名称为key的string的value的子串</p>
<h3 id="对List操作的命令">对List操作的命令</h3><p>rpush(key, value)：在名称为key的list尾添加一个值为value的元素<br>lpush(key, value)：在名称为key的list头添加一个值为value的 元素<br>llen(key)：返回名称为key的list的长度<br>lrange(key, start, end)：返回名称为key的list中start至end之间的元素<br>ltrim(key, start, end)：截取名称为key的list<br>lindex(key, index)：返回名称为key的list中index位置的元素<br>lset(key, index, value)：给名称为key的list中index位置的元素赋值<br>lrem(key, count, value)：删除count个key的list中值为value的元素<br>lpop(key)：返回并删除名称为key的list中的首元素<br>rpop(key)：返回并删除名称为key的list中的尾元素<br>blpop(key1, key2,… key N, timeout)：lpop命令的block版本。<br>brpop(key1, key2,… key N, timeout)：rpop的block版本。<br>rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p>
<h3 id="对Set操作的命令">对Set操作的命令</h3><p>sadd(key, member)：向名称为key的set中添加元素member<br>srem(key, member) ：删除名称为key的set中的元素member<br>spop(key) ：随机返回并删除名称为key的set中一个元素<br>smove(srckey, dstkey, member) ：移到集合元素<br>scard(key) ：返回名称为key的set的基数<br>sismember(key, member) ：member是否是名称为key的set的元素<br>sinter(key1, key2,…key N) ：求交集<br>sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合<br>sunion(key1, (keys)) ：求并集<br>sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合<br>sdiff(key1, (keys)) ：求差集<br>sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合<br>smembers(key) ：返回名称为key的set的所有元素<br>srandmember(key) ：随机返回名称为key的set的一个元素</p>
<h3 id="对Hash操作的命令">对Hash操作的命令</h3><p>hset(key, field, value)：向名称为key的hash中添加元素field<br>hget(key, field)：返回名称为key的hash中field对应的value<br>hmget(key, (fields))：返回名称为key的hash中field i对应的value<br>hmset(key, (fields))：向名称为key的hash中添加元素field<br>hincrby(key, field, integer)：将名称为key的hash中field的value增加integer<br>hexists(key, field)：名称为key的hash中是否存在键为field的域<br>hdel(key, field)：删除名称为key的hash中键为field的域<br>hlen(key)：返回名称为key的hash中元素个数<br>hkeys(key)：返回名称为key的hash中所有键<br>hvals(key)：返回名称为key的hash中所有键对应的value<br>hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty笔记第一篇]]></title>
    <link href="http://www.52ff.cc/2015/03/05/netty%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/03/05/netty笔记第一篇/</id>
    <published>2015-03-05T13:37:48.000Z</published>
    <updated>2015-03-15T14:03:15.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>]]>
    </summary>
    
      <category term="［netty nio］" scheme="http://www.52ff.cc/tags/%EF%BC%BBnetty-nio%EF%BC%BD/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写了个异或加密小程序]]></title>
    <link href="http://www.52ff.cc/2015/02/22/%E5%86%99%E4%BA%86%E4%B8%AA%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.52ff.cc/2015/02/22/写了个异或加密小程序/</id>
    <published>2015-02-22T13:40:50.000Z</published>
    <updated>2015-03-15T14:01:46.000Z</updated>
    <content type="html"><![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>
<a id="more"></a>
<p>代码如下，记录下以后review用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class XORCodec &#123;</span><br><span class="line">	private final static String key = <span class="string">"unisms"</span>;  //密钥</span><br><span class="line">	private static String EncodeType =<span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 加密(字节版)，字节异或后转<span class="number">16</span>进制</span><br><span class="line">	 * @param @throws UnsupportedEncodingException</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">53</span>:<span class="number">55</span></span><br><span class="line">	 */</span><br><span class="line">	public static String encrypt(String <span class="keyword">in</span>Str) throws UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">		byte[] b=<span class="keyword">in</span>Str.getBytes(EncodeType);</span><br><span class="line">		byte[] snNum = new byte[b.length];</span><br><span class="line">		byte[] c=key.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; b.length; i++, j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == c.length)</span><br><span class="line">				j = <span class="number">0</span>;</span><br><span class="line">			snNum[i] = (byte)(b[i] ^ c[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			result= byte2HexStr(snNum);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 解密(字节版)，将<span class="number">16</span>进制字符串每<span class="number">2</span>位转成INT，再转成byte</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">54</span>:<span class="number">34</span></span><br><span class="line">	 */</span><br><span class="line">	public static String decrypt(String instr)&#123;</span><br><span class="line">		byte[] snNum=null;</span><br><span class="line">		byte[] c=null;</span><br><span class="line">		int len;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			len = instr.length()/<span class="number">2</span>;</span><br><span class="line">			snNum = new byte[len];</span><br><span class="line">			c=key.getBytes();</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++, j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == c.length)</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				snNum[i] = (byte) ((byte)(Integer.parseInt(instr.substring(i*<span class="number">2</span>,i*<span class="number">2</span>+<span class="number">2</span>),<span class="number">16</span>)) ^ c[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			result=new String(snNum,EncodeType);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bytes转换成十六进制字符</span><br><span class="line">	 */</span><br><span class="line">	public static String byte2HexStr(byte[] b)</span><br><span class="line">	&#123;</span><br><span class="line">		String stmp=<span class="string">""</span>;</span><br><span class="line">		StringBuilder sb = new StringBuilder(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span> (int n=<span class="number">0</span>;n&lt;b.length;n++)</span><br><span class="line">		&#123;</span><br><span class="line">			stmp = Integer.toHexString(b[n] &amp; <span class="number">0</span>xFF);//<span class="number">0</span>xFF即<span class="number">256</span>相当于<span class="number">11111111</span></span><br><span class="line">			sb.append((stmp.length()==<span class="number">1</span>)? <span class="string">"0"</span>+stmp : stmp);</span><br><span class="line">			sb.append(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> sb.toString().toUpperCase().trim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 加密(字符版)</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String encrypt2(String data)&#123;</span><br><span class="line">		int[] temp = new int[data.length()];</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		//循环需加密的字符串和密钥，分别从需加密字符串和密钥中获取一个字符进行异或</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;data.length();i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			temp[i] = data.charAt(i)^key.charAt(j);//需加密的字符串中一个字符和密钥中一个字符异或得到十进制的整数</span><br><span class="line">			str = Integer.toHexString(temp[i]);//将十进制转化成<span class="number">16</span>进制</span><br><span class="line">			<span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;//不足<span class="number">4</span>位的进行补零</span><br><span class="line">				str = <span class="string">"000"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">2</span>)&#123;</span><br><span class="line">				str = <span class="string">"00"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">3</span>)&#123;</span><br><span class="line">				str = <span class="string">"0"</span>+str;</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span>  result.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 解密(字符版)</span><br><span class="line">	 * @throws</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String decrypt2(String data)&#123;</span><br><span class="line">		char[] c=new char[data.length()/<span class="number">4</span>];//加密后的长度是原先的<span class="number">4</span>倍</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;c.length;i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			int n = Integer.parseInt(data.substring(i*<span class="number">4</span>,i*<span class="number">4</span>+<span class="number">4</span>),<span class="number">16</span>);//将<span class="number">16</span>进制的字符串解析为整数，因为加密时不足<span class="number">4</span>位补到<span class="number">4</span>位，所以每四个进行一次转化</span><br><span class="line">			c[i]=(char)((char)n^key.charAt(j));//重新和密钥中字符异或还原成原先的字符</span><br><span class="line">			result.append(c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL优化的几条建议]]></title>
    <link href="http://www.52ff.cc/2015/02/19/SQL%E4%BC%98%E5%8C%96%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%9D%A1%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/19/SQL优化的若干条技巧/</id>
    <published>2015-02-19T06:50:55.000Z</published>
    <updated>2015-03-17T16:17:39.000Z</updated>
    <content type="html"><![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>
<a id="more"></a>
<h3 id="选择最有效率的表名顺序_(只在基于规则的优化器中有效)_：">选择最有效率的表名顺序 (只在基于规则的优化器中有效) ：</h3><p>ORACLE 的解析器按照从右到左的顺序处理 FROM 子句中的表名， FROM 子句中写在最右的表将被最先处理，所以我们需要把记录最少的表写在最右边。如果有3个以上的表连接查询，那就需要选择交叉表写在最右，交叉表是指那个被其他表所引用的表。</p>
<p>简而言之：大表在前，小表在后</p>
<h3 id="WHERE子句中的连接顺序：">WHERE子句中的连接顺序：</h3><p>ORACLE采用自下而上的顺序解析 WHERE 子句,根据这个原理 , 表之间的连接必须写在其他 WHERE 条件之前 , 那些可以过滤掉最大数量记录的条件必须写在 WHERE 子句的末尾.</p>
<h3 id="SELECT子句中避免使用_‘*’_：">SELECT子句中避免使用  ‘*’ ：</h3><p>ORACLE在解析的过程中 , 会将 ‘*’  依次转换成所有的列名 ,  这个工作是通过查询数据字典完成的 , 这意味着将耗费更多的时间</p>
<h3 id="使用_DECODE_函数来减少处理时间：">使用 DECODE 函数来减少处理时间：</h3><p>使用DECODE 函数可以避免重复扫描相同记录或重复连接相同的表 .</p>
<h3 id="删除重复记录：">删除重复记录：</h3><p>最高效的删除重复记录方法 (  因为使用了 ROWID) 例子：</p>
<p>DELETE  FROM  EMP E  WHERE  E.ROWID &gt; (SELECT MIN(X.ROWID) FROM  EMP X  WHERE  X.EMP_NO = E.EMP_NO);</p>
<h3 id="用_TRUNCATE_替代_DELETE_：">用 TRUNCATE 替代 DELETE ：</h3><p>当删除表中的记录时, 在通常情况下 ,  回滚段 (rollback segments )  用来存放可以被恢复的信息 .  如果你没有 COMMIT 事务 ,ORACLE 会将数据恢复到删除之前的状态 ( 准确地说是恢复到执行删除命令之前的状况 )  而当运用 TRUNCATE 时 ,  回滚段不再存放任何可被恢复的信息 . 当命令运行后 , 数据不能被恢复 . 因此很少的资源被调用 , 执行时间也会很短 . ( 译者按 : TRUNCATE 只在删除全表适用 ,TRUNCATE 是 DDL 不是 DML)</p>
<h3 id="尽量多使用_COMMIT_：">尽量多使用 COMMIT ：</h3><p>只要有可能, 在程序中尽量多使用 COMMIT,  这样程序的性能得到提高 , 需求也会因为 COMMIT 所释放的资源而减少 :</p>
<p>COMMIT所释放的资源 :</p>
<p>a. 回滚段上用于恢复数据的信息<br>b. 被程序语句获得的锁<br>c. redo log buffer 中的空间<br>d. ORACLE为管理上述 3 种资源中的内部花费</p>
<h3 id="用_Where_子句替换_HAVING_子句：">用 Where 子句替换 HAVING 子句：</h3><p>避免使用HAVING 子句 , HAVING  只会在检索出所有记录之后才对结果集进行过滤 .  这个处理需要排序 , 总计等操作 .  如果能通过 WHERE 子句限制记录的数目 , 那就能减少这方面的开销 . ( 非 oracle 中 )on 、 where 、 having 这三个都可以加条件的子句中， on 是最先执行， where 次之， having 最后</p>
<h3 id="用_EXISTS_替代_IN_、用_NOT_EXISTS_替代_NOT_IN_：">用 EXISTS 替代 IN 、用 NOT EXISTS 替代 NOT IN ：</h3><p>在许多基于基础表的查询中, 为了满足一个条件 , 往往需要对另一个表进行联接 . 在这种情况下 ,  使用 EXISTS( 或 NOT EXISTS) 通常将提高查询的效率 . 在子查询中 ,NOT IN 子句将执行一个内部的排序和合并 .  无论在哪种情况下 ,NOT IN 都是最低效的  ( 因为它对子查询中的表执行了一个全表遍历 ).  为了避免使用 NOT IN , 我们可以把它改写成外连接 (Outer Joins) 或 NOT EXISTS.</p>
<p>例子：</p>
<p>(高效 )SELECT * FROM  EMP ( 基础表 )  WHERE  EMPNO &gt; 0  AND  EXISTS (SELECT  ‘ X’  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC =  ‘ MELB’)</p>
<p>(低效 )SELECT  * FROM  EMP ( 基础表 )  WHERE  EMPNO &gt; 0  AND  DEPTNO IN(SELECT DEPTNO  FROM  DEPT  WHERE  LOC =  ‘ MELB’)</p>
<h3 id="使用表的别名_(Alias)_：">使用表的别名 (Alias) ：</h3><p>当在SQL 语句中连接多个表时 ,  请使用表的别名并把别名前缀于每个 Column 上 . 这样一来 , 就可以减少解析的时间并减少那些由 Column 歧义引起的语法错误 .</p>
<h3 id="避免在索引列上使用计算．">避免在索引列上使用计算．</h3><p>WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．</p>
<p>低效：</p>
<p>SELECT …  FROM  DEPT  WHERE SAL * 12 &gt; 25000;</p>
<p>高效:</p>
<p>SELECT …  FROM DEPT WHERE SAL &gt; 25000/12;</p>
<h3 id="用_&gt;=_替代_&gt;">用 &gt;= 替代 &gt;</h3><p>高效:</p>
<p>SELECT * FROM  EMP  WHERE  DEPTNO &gt;=4</p>
<p>低效:</p>
<p>SELECT * FROM EMP WHERE DEPTNO &gt;3</p>
<p>两者的区别在于,  前者 DBMS 将直接跳到第一个 DEPT 等于 4 的记录而后者将首先定位到 DEPTNO=3 的记录并且向前扫描到第一个 DEPT 大于 3 的记录 .</p>
<h3 id="减少对表的查询：">减少对表的查询：</h3><p>在含有子查询的SQL 语句中 , 要特别注意减少对表的查询 . 例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT  TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER FROM  TAB_COLUMNS  WHERE  VERSION = <span class="number">604</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="sql语句用大写的：">sql语句用大写的：</h3><p>因为oracle 总是先解析 sql 语句，把小写的字母转换成大写的再执行</p>
<h3 id="在_java_代码中尽量少用连接符_“_＋_”_连接字符串！">在 java 代码中尽量少用连接符 “ ＋ ” 连接字符串！</h3><h3 id="避免在索引列上使用_NOT_：">避免在索引列上使用 NOT ：</h3><p>我们要避免在索引列上使用NOT, NOT 会产生在和在索引列上使用函数相同的影响 .  当 ORACLE ” 遇到 ” NOT, 他就会停止使用索引转而执行全表扫描 .</p>
<h3 id="通过内部函数提高_SQL_效率：">通过内部函数提高 SQL 效率：</h3><p>复杂的SQL 往往牺牲了执行效率 . 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的</p>
<h3 id="识别_‘_低效执行_‘_的_SQL_语句：">识别 ‘ 低效执行 ‘ 的 SQL 语句：</h3><p>虽然目前各种关于SQL 优化的图形化工具层出不穷 , 但是写出自己的 SQL 工具来解决问题始终是一个最好的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT  EXECUTIONS , DISK_READS, BUFFER_GETS,</span><br><span class="line">ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) Hit_radio,</span><br><span class="line">ROUND(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,</span><br><span class="line">SQL_TEXT</span><br><span class="line">FROM  V<span class="variable">$SQLAREA</span></span><br><span class="line">WHERE  EXECUTIONS&gt;<span class="number">0</span></span><br><span class="line">AND  BUFFER_GETS &gt; <span class="number">0</span></span><br><span class="line">AND  (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span></span><br><span class="line">ORDER BY  <span class="number">4</span> DESC;</span><br></pre></td></tr></table></figure>
<h3 id="用索引提高效率：">用索引提高效率：</h3><p>索引是表的一个概念部分, 用来提高检索数据的效率， ORACLE 使用了一个复杂的自平衡 B-tree 结构 .  通常 , 通过索引查询数据比全表扫描要快 .  当 ORACLE 找出执行查询和 Update 语句的最佳路径时 , ORACLE 优化器将使用索引 .  同样在联结多个表时使用索引也可以提高效率 .  另一个使用索引的好处是 , 它提供了主键 (primary key) 的唯一性验证 . 。那些 LONG 或 LONG RAW 数据类型 ,  你可以索引几乎所有的列 .  通常 ,  在大型表中使用索引特别有效 .  当然 , 你也会发现 ,  在扫描小表时 , 使用索引同样能提高效率 .  虽然使用索引能得到查询效率的提高 , 但是我们也必须注意到它的代价 .  索引需要空间来存储 , 也需要定期维护 ,  每当有记录在表中增减或索引列被修改时 ,  索引本身也会被修改 .  这意味着每条记录的 INSERT , DELETE , UPDATE 将为此多付出 4 , 5  次的磁盘 I/O .  因为索引需要额外的存储空间和处理 , 那些不必要的索引反而会使查询反应时间变慢 . 。定期的重构索引是有必要的 . ：</p>
<p>ALTER  INDEX <indexname> REBUILD <tablespacename></tablespacename></indexname></p>
<h3 id="用_UNION_替换_OR_(_适用于索引列_)">用 UNION 替换 OR ( 适用于索引列 )</h3><p>通常情况下,  用 UNION 替换 WHERE 子句中的 OR 将会起到较好的效果 .  对索引列使用 OR 将造成全表扫描 .  注意 ,  以上规则只针对多个索引列有效 .  如果有 column 没有被索引 ,  查询效率可能会因为你没有选择 OR 而降低 .  在下面的例子中 , LOC_ID  和 REGION 上都建有索引 .</p>
<p>高效:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT LOC_ID , LOC_DESC , REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE LOC_ID = <span class="number">10</span></span><br><span class="line">UNION</span><br><span class="line">SELECT LOC_ID , LOC_DESC , REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE REGION = “ MELBOURNE ”</span><br></pre></td></tr></table></figure></p>
<p>低效:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT LOC_ID , LOC_DESC , REGION</span><br><span class="line">FROM LOCATION</span><br><span class="line">WHERE LOC_ID = <span class="number">10</span> OR REGION = “ MELBOURNE ”</span><br></pre></td></tr></table></figure></p>
<p>如果你坚持要用OR,  那就需要返回记录最少的索引列写在最前面 .</p>
<h3 id="用_IN_来替换_OR">用 IN 来替换 OR</h3><p>低效:<br>SELECT… . FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30</p>
<p>高效<br>SELECT…  FROM LOCATION WHERE LOC_IN  IN (10,20,30);</p>
<h3 id="避免在索引列上使用_IS_NULL_和_IS_NOT_NULL">避免在索引列上使用 IS NULL 和 IS NOT NULL</h3><p>避免在索引中使用任何可以为空的列，ORACLE 将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录 .  对于复合索引，如果每个列都为空，索引中同样不存在此记录 . 　如果至少有一个列不为空，则记录存在于索引中．举例 :  如果唯一性索引建立在表的 A 列和 B 列上 ,  并且表中存在一条记录的 A,B 值为 (123,null) , ORACLE 将不接受下一条具有相同 A,B 值 (123,null) 的记录 ( 插入 ).  然而如果所有的索引列都为空， ORACLE 将认为整个键值为空而空不等于空 .  因此你可以插入 1000  条具有相同键值的记录 , 当然它们都是空 !  因为空值不存在于索引列中 , 所以 WHERE 子句中对索引列进行空值比较将使 ORACLE 停用该索引 .</p>
<p>低效: ( 索引失效 )</p>
<p>SELECT …  FROM  DEPARTMENT  WHERE  DEPT_CODE IS NOT NULL;</p>
<p>高效: ( 索引有效 )</p>
<p>SELECT …  FROM  DEPARTMENT  WHERE  DEPT_CODE &gt;=0;</p>
<h3 id="总是使用索引的第一个列：">总是使用索引的第一个列：</h3><p>如果索引是建立在多个列上,  只有在它的第一个列 (leading column) 被 where 子句引用时 , 优化器才会选择使用该索引 .  这也是一条简单而重要的规则，当仅引用索引的第二个列时 , 优化器使用了全表扫描而忽略了索引</p>
<h3 id="用_UNION-ALL_替换_UNION_(如果业务允许)_：">用 UNION-ALL  替换 UNION (如果业务允许) ：</h3><p>当SQL  语句需要 UNION 两个查询结果集合时 , 这两个结果集合会以 UNION-ALL 的方式被合并 ,  然后在输出最终结果前进行排序 .  如果用 UNION ALL 替代 UNION,  这样排序就不是必要了 .  效率就会因此得到提高 .  需要注意的是， UNION ALL  将重复输出两个结果集合中相同记录 .  因此各位还是要从业务需求分析使用 UNION ALL 的可行性 . UNION  将对结果集合排序 , 这个操作会使用到 SORT_AREA_SIZE 这块内存 .  对于这块内存的优化也是相当重要的 .  下面的 SQL 可以用来查询排序的消耗量</p>
<h3 id="用_WHERE_替代_ORDER_BY_：">用 WHERE 替代 ORDER BY ：</h3><p>ORDER BY 子句只在两种严格的条件下使用索引 .</p>
<p>ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序 .</p>
<p>ORDER BY中所有的列必须定义为非空 .</p>
<p>WHERE子句使用的索引和 ORDER BY 子句中所使用的索引不能并列 .</p>
<p>例如:</p>
<p>表DEPT 包含以下列 :</p>
<p>DEPT_CODE PK NOT NULL<br>DEPT_DESC NOT NULL<br>DEPT_TYPE NULL</p>
<p>低效: ( 索引不被使用 )</p>
<p>SELECT DEPT_CODE FROM  DEPT  ORDER BY  DEPT_TYPE</p>
<p>高效: ( 使用索引 )</p>
<p>SELECT DEPT_CODE  FROM  DEPT  WHERE  DEPT_TYPE &gt; 0</p>
<h3 id="避免改变索引列的类型_:">避免改变索引列的类型 :</h3><p>当比较不同数据类型的数据时, ORACLE 自动对列进行简单的类型转换 .</p>
<p>假设 EMPNO 是一个数值类型的索引列 .</p>
<p>SELECT …   FROM EMP  WHERE  EMPNO = ‘123’</p>
<p>实际上, 经过 ORACLE 类型转换 ,  语句转化为 :</p>
<p>SELECT …   FROM EMP  WHERE  EMPNO = TO_NUMBER(‘123’)</p>
<p>幸运的是, 类型转换没有发生在索引列上 , 索引的用途没有被改变 .</p>
<p>现在, 假设 EMP_TYPE 是一个字符类型的索引列 .</p>
<p>SELECT …   FROM EMP  WHERE EMP_TYPE = 123</p>
<p>这个语句被ORACLE 转换为 :</p>
<p>SELECT …   FROM EMP  WHERETO_NUMBER(EMP_TYPE)=123</p>
<p>因为内部发生的类型转换,  这个索引将不会被用到 !  为了避免 ORACLE 对你的 SQL 进行隐式的类型转换 ,  最好把类型转换用显式表现出来 .  注意当字符和数值比较时 , ORACLE 会优先转换数值类型到字符类型</p>
<h3 id="需要当心的_WHERE_子句_:">需要当心的 WHERE 子句 :</h3><p>某些SELECT 语句中的 WHERE 子句不使用索引 . 这里有一些例子 .</p>
<p>在下面的例子里,</p>
<p>(1)‘ !=’  将不使用索引 .  记住 ,  索引只能告诉你什么存在于表中 ,  而不能告诉你什么不存在于表中 .</p>
<p>(2) ‘ ||’ 是字符连接函数 .  就象其他函数那样 ,  停用了索引 .</p>
<p>(3) ‘ +’ 是数学函数 .  就象其他数学函数那样 ,  停用了索引 .</p>
<h3 id="使用索引">使用索引</h3><p>a. 如果检索数据量超过 30% 的表中记录数 . 使用索引将没有显著的效率提高 .<br>b. 在特定情况下, 使用索引也许会比全表扫描慢 ,  但这是同一个数量级上的区别 . 而通常情况下, 使用索引比全表扫描要块几倍乃至几千倍 ! </p>
<h3 id="避免使用耗费资源的操作_:">避免使用耗费资源的操作 :</h3><p>带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY 的 SQL 语句会启动 SQL 引擎<br>执行耗费资源的排序(SORT) 功能 . DISTINCT 需要一次排序操作 ,  而其他的至少需要执行两次排序 .  通常 ,  带有 UNION, MINUS , INTERSECT 的 SQL 语句都可以用其他方式重写 .  如果你的数据库的 SORT_AREA_SIZE 调配得好 ,  使用 UNION , MINUS, INTERSECT 也是可以考虑的 ,  毕竟它们的可读性很强 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>]]>
    
    </summary>
    
      <category term="［sql］" scheme="http://www.52ff.cc/tags/%EF%BC%BBsql%EF%BC%BD/"/>
    
      <category term="sql数据库" scheme="http://www.52ff.cc/categories/sql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java反射简述一二]]></title>
    <link href="http://www.52ff.cc/2015/02/17/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <id>http://www.52ff.cc/2015/02/17/java反射机制简单整理/</id>
    <published>2015-02-17T14:19:16.000Z</published>
    <updated>2015-03-15T14:02:17.000Z</updated>
    <content type="html"><![CDATA[<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用他的方法？这些答案是肯定的，这种动态获取类的信息，以及动态调用类的方法的功能来源于JAVA的反射。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与 执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。</p>
<a id="more"></a>
<p>JAVA反射机制主要提供了以下功能(前提都是在运行时不是在编译时)：<br>1.判断任意一个对象所属的类<br>2.构造任意一个类的对象<br>3.判断任意一个类所具有的成员变量和方法<br>4.调用任意一个对象的方法(包括private)</p>
<p>Java 反射相关的API简介：<br>位于java.lang.reflect包中<br>—Class类：代表一个类<br>—Filed类：代表类的成员变量<br>—Method类：代表类的方法<br>—Constructor类：代表类的构造方法<br>—Array类：提供了动态创建数组，以及访问数组的元素的静态方法。该类中的所有方法都是静态方法</p>
<h3 id="Class类">Class类</h3><p>在 java 的Object类中的申明了数个应该在所有的java类中被改写的methods：<br>hashCode(), equals(),clone(),toString(),getClass()等，其中的getClass()返回一个Class 类型的对象。<br>Class类十分的特殊，它和一般的类一样继承自Object，其实体用以表达java程序运行时的class和interface，也用来表达 enum，array，primitive，Java Types 以及关键字void，当加载一个类，或者当加载器（class loader）的defineClass（）被JVM调用，便产生一个Class对象，<br>Class是Reflection起源，针对任何你想探勘的class（类），唯有现为他产生一个Class的对象，接下来才能经由后者唤起为数十多个的反射API。</p>
<p>Java允许我们从多种途径为一个类class生成对应的Class对象。<br>—运用 getClass()：Object类中的方法，每个类都拥有此方法<br>String str=”abc”;<br>Class cl=str.getClass();</p>
<p>—运用 Class.getSuperclass（）：Class类中的方法，返回该Class的父类的Class<br>—运用 Class.forName()静态方法：<br>—运用 Class：类名.class<br>—运用primitive wrapper classes的TYPE语法： 基本类型包装类的TYPE，如：Integer.TYPE<br>注意：TYPE的使用，只适合原生（基本）数据类型</p>
<p>——运行时生成instance</p>
<p>想生成对象的实体，在反射动态机制中有两种方法，一个针对无变量的构造方法，一个针对带参数的构造方法，如果想调用带参数的构造方法，就比较的麻烦，不能直接调用Class类中的newInstance()，而是调用Constructor类中newInstance（）方法，首先准备一个Class[]作为Constructor的参数类型。然后调用该Class对象的getConstructor()方法获得一个专属的Constructor的对象，最后再准备一个<br>Object[]作为Constructor对象昂的newInstance(()方法的实参。<br>在这里需要说明的是 只有两个类拥有newInstance()方法，分别是Class类和Constructor类<br>Class类中的newInstance()方法是不带参数的，而Constructro类中的newInstance()方法是带参数的<br>需要提供必要的参数。<br>例:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"DynTest"</span>);</span><br><span class="line">Class[] ptype=new Class[]&#123;double.class,int.class&#125;；Constructor ctor=c.getConstructor(ptypr);</span><br><span class="line">Object[] obj=new Object[]&#123;new Double(<span class="number">3.1415</span>),new Integer(<span class="number">123</span>)&#125;;</span><br><span class="line">Object object=ctor.newInstance(obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="运行时调用Method">运行时调用Method</h3><p>这个动作首先准备一个Class[]{}作为getMethod（String name，Class[]）方法的参数类型，接下来准备一个Obeject[]放置自变量，然后调用Method对象的invoke（Object obj，Object[]）方法。</p>
<h3 id="运行时调用Field内容">运行时调用Field内容</h3><p>变更Field不需要参数和自变量，首先调用Class的getField（）并指定field名称，获得特定的Field对象后便可以直接调用Field的 get（Object obj）和set(Object obj,Object value)方法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;        </span><br><span class="line">        Class&lt;?&gt; clazz = null;  </span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = User.class;  </span><br><span class="line">            Object obj=clazz.newInstance();  </span><br><span class="line">            ((User) obj).setUsername(<span class="string">"4"</span>);  </span><br><span class="line">            ((User) obj).setPassword(<span class="string">"2222"</span>); </span><br><span class="line">            //获取构造函数数组</span><br><span class="line">            Object[] constructors = clazz.getDeclaredConstructors();  </span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"----constructors["</span>+i+<span class="string">"]-----"</span>+constructors[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            //获取类中声明的字段数组，包括公有和私有字段&lt;br&gt;  </span><br><span class="line">            Field[] fields = clazz.getDeclaredFields();  </span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; fields.length; j++) &#123;  </span><br><span class="line">                String head = fields[j].getName().toUpperCase().substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                //获取属性的get方法名称</span><br><span class="line">                String getName = <span class="string">"get"</span> + head+ fields[j].getName().substring(<span class="number">1</span>);  </span><br><span class="line">                //获取属性的<span class="built_in">set</span>方法名称</span><br><span class="line">                String <span class="built_in">set</span>Name = <span class="string">"set"</span> + head+ fields[j].getName().substring(<span class="number">1</span>);  </span><br><span class="line">                //获取类中声明的方法数组，包括公有和私有方法</span><br><span class="line">                Method[] methods=clazz.getDeclaredMethods();  </span><br><span class="line">                <span class="keyword">for</span>(int m=<span class="number">0</span>;m&lt;methods.length;m++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"----method["</span>+m+<span class="string">"]------"</span>+methods[m].getName()); </span><br><span class="line">                 &#125;</span><br><span class="line">                //根据方法名称和参数，获取Method对象，第一个参数是方法名称，后边是一个Class数组，里边是方法参数类型</span><br><span class="line">                Method getMethod= clazz.getMethod(getName, new Class[] &#123;&#125;); </span><br><span class="line">                Method <span class="built_in">set</span>Method= clazz.getMethod(<span class="built_in">set</span>Name,new Class[]&#123; fields[j].getType() &#125;);</span><br><span class="line">                //obj -从中调用底层方法的对象,后边是用于方法调用的参数</span><br><span class="line">                Object result2=<span class="built_in">set</span>Method.invoke(obj, new Object[]&#123;new String(<span class="string">"hello  "</span>+fields[j].getName())&#125;);</span><br><span class="line">                Object result = getMethod.invoke(obj, new Object[] &#123;&#125;);</span><br><span class="line">                System.out.println(<span class="string">"----result------"</span> + result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (SecurityException e) &#123;            </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123; </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java类反射中的主要方法">Java类反射中的主要方法</h3><p>对于以下三类组件中的任何一类来说 — 构造函数、字段和方法 — java.lang.Class 提供四种独立的反射调用，以不同的方式来获得信息。调用都遵循一种标准格式。以下是用于查找构造函数的一组反射调用：<br>Constructor getConstructor(Class[] params) — 获得使用特殊的参数类型的公共构造函数，<br>Constructor[] getConstructors() — 获得类的所有公共构造函数<br>Constructor getDeclaredConstructor(Class[] params) — 获得使用特定参数类型的构造函数(与接入级别无关)<br>Constructor[] getDeclaredConstructors() — 获得类的所有构造函数(与接入级别无关)<br>获得字段信息的Class 反射调用不同于那些用于接入构造函数的调用，在参数类型数组中使用了字段名：<br>Field getField(String name) — 获得命名的公共字段<br>Field[] getFields() — 获得类的所有公共字段<br>Field getDeclaredField(String name) — 获得类声明的命名的字段<br>Field[] getDeclaredFields() — 获得类声明的所有字段<br>用于获得方法信息函数：<br>Method getMethod(String name, Class[] params) — 使用特定的参数类型，获得命名的公共方法<br>Method[] getMethods() — 获得类的所有公共方法<br>Method getDeclaredMethod(String name, Class[] params) — 使用特写的参数类型，获得类声明的命名的方法<br>Method[] getDeclaredMethods() — 获得类声明的所有方法 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用他的方法？这些答案是肯定的，这种动态获取类的信息，以及动态调用类的方法的功能来源于JAVA的反射。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与 执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IntelliJ Idea操作技巧]]></title>
    <link href="http://www.52ff.cc/2015/02/17/IntelliJ-Idea%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/17/IntelliJ-Idea操作技巧/</id>
    <published>2015-02-17T06:55:49.000Z</published>
    <updated>2015-03-18T03:40:50.000Z</updated>
    <content type="html"><![CDATA[<p>用了多年的eclipse,现在终于决定抛弃它了，转向了JetBrains公司的IntelliJ IDEA.原因是eclipse让我碰到了以下几个痛苦的事：<br>1:安装gradle,ivy构建工具麻烦且慢，myeclipse将近1G的大小svn、反编译这种功能还要新安装插件<br>2: myeclipse太耗内存了，两个myelipse一启动，电脑必来慢慢变卡，另外启动和build workspace的速度也有点不爽<br>3:代码助手的功能缺失，idea有live template这个神器，另外前端的js,css,html我已经转向另一个牛逼的工具HBulider</p>
<a id="more"></a>
<p>写这篇文章的主要目的是记录idea工具磨合期掌握的最实用技巧，因为网上的快捷键列举比较杂乱而且应用在mac上不靠谱，自己记下来可以备忘，回顾也方便，帮助自己精通这个工具。</p>
<p>ps:可使用ctrl+`切换keyMap，建议keyMap使用mac os x 10.5 +，使用default的在mac系统和其他快捷键冲突多些</p>
<h3 id="搜索">搜索</h3><p>cmd+shift+f 当前项目下递归查找，相当于eclipse的ctrl+h<br>cmd+g       当前文件中往后搜索一样的字符，相当于eclipse的ctrl+ k<br>cmd+shift+g 当前文件中往前搜索一样的字符<br>cmd+p            查询某方法的参数信息<br>cmd+b            跳到调用方法的定义处<br>cmd+shift+b      跳到方法的实现处<br>cmd+u            跳到方法在父类或接口的定义处<br>cmd+alt+left/right 跳到上/下一次光标查看处<br>cmd+o        查找类<br>cmd+shift+o  查找文件</p>
<h3 id="编辑">编辑</h3><p>cmd+j        调出IDEA的神器live template<br>cmd+n        各种自动生成代码<br>alt+enter    调出IDEA对出错点的提示处理方法，相当于eclipse的ctrl+1<br>cmd+D        复制粘贴当前行到下一行<br>shift+cmd+v  调出IDEA寄存器中保存的最近复制的N份内容，可选择性粘贴<br>ctrl+shift+/      注释/取消注释<br>shift+cmd+enter   补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用了多年的eclipse,现在终于决定抛弃它了，转向了JetBrains公司的IntelliJ IDEA.原因是eclipse让我碰到了以下几个痛苦的事：<br>1:安装gradle,ivy构建工具麻烦且慢，myeclipse将近1G的大小svn、反编译这种功能还要新安装插件<br>2: myeclipse太耗内存了，两个myelipse一启动，电脑必来慢慢变卡，另外启动和build workspace的速度也有点不爽<br>3:代码助手的功能缺失，idea有live template这个神器，另外前端的js,css,html我已经转向另一个牛逼的工具HBulider</p>]]>
    
    </summary>
    
      <category term="我的工具" scheme="http://www.52ff.cc/categories/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重写hashcode()与equals()]]></title>
    <link href="http://www.52ff.cc/2015/02/12/%E9%87%8D%E5%86%99hashcode()%E4%B8%8Eequals()/"/>
    <id>http://www.52ff.cc/2015/02/12/重写hashcode()与equals()/</id>
    <published>2015-02-12T03:51:08.000Z</published>
    <updated>2015-03-15T13:27:18.000Z</updated>
    <content type="html"><![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>
<a id="more"></a>
<p>首先，这两个方法都来自于Object对象，根据API文档查看下原意。(1)public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。（2）public int hashCode() 返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p>
<p>我的理解是hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写hashcode。为了保证这种一致性，必须满足以下两个条件：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class BeanA &#123;</span><br><span class="line">private int i;</span><br><span class="line">public BeanA(int i) &#123;</span><br><span class="line">   this.i = i;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"   "</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">   BeanA a = (BeanA) o;</span><br><span class="line">   <span class="built_in">return</span> (a.i == i) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   HashSet&lt;BeanA&gt; <span class="built_in">set</span> = new HashSet&lt;BeanA&gt;();</span><br><span class="line">   <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    set.add(new BeanA(i));</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">   set.add(new BeanA(<span class="number">1</span>));</span><br><span class="line">   System.out.println(set.toString());</span><br><span class="line">   System.out.println(set.contains(new BeanA(<span class="number">0</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">1</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">4</span>)));</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在类BeanA中重写了equals和hashcode方法，这样在存储到HashSet数据集中，将保证不会出现重复的数据；如果把这两个方法去掉后，那些重复的数据仍会存入HashSet中，这就与HashSet强调的元素唯一性相违背，大家可以把这两个方法注释掉再运行一下。<br>因此，我们就可以理解在一些java类中什么情况下需要重写equals和hashcode。比如：在hibernate的实体类中，往往通过一个主键（或唯一标识符）来判断数据库的某一行，这就需要重写这两个方法。因为，Hibernate保证，仅在特定会话范围内，持久化标识（数据库的行）和Java标识是等价的。因此，一旦我们混合了从不同会话中获取的实例，如果希望Set有明确的语义，就必 须实现equals() 和hashCode()。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mina多线程池]]></title>
    <link href="http://www.52ff.cc/2012/02/15/mina%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.52ff.cc/2012/02/15/mina多线程池/</id>
    <published>2012-02-15T02:51:08.000Z</published>
    <updated>2015-03-15T13:27:36.000Z</updated>
    <content type="html"><![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>
<a id="more"></a>
<p>Mina 的多级线程池<br>在基于 SocketAcceptor 的应用程序中运行过程中 Mina 框架本身会有两种类型的线程在运行<br>一种是在SocketAcceptor 中创建的用于监听并接收来自客户端请求的线程。还有一类线程是处理客户端与服务器端 I/O 的线程即 Processor 的处理线程。后面还有第三类，就是过滤器层的线程。<br>这个多级的概念后面你会体会到Acceptor 是一级线程池而 Processor 的线程池主要通过 ExecutorFileter 进行添加当然可以添加多个层次的线程池。下面逐层进行讲解。</p>
<p>第一类线程池<br>当调用 SocketAcceptor 的 bind 方法时默认会创建一个名称前缀为 SocketAcceptor 的线程该线程负责监听来自客户端的请求如果接收到客户端的请求它仅仅是为处理这个请求做好准备而把具体处理请求以及I/O 的任务代理给 SocketIoProcessor 让它去处理请求。这个准备过程主要是为接受到的请求创建一个   IoSession 并构建出 IoFilter 链然后把准备好的数据以及来自客户端的请求交给 SocketIoProcessor 处理。通常 这类线程会针对每一次的 bind 调用创建一个新的线程。 请注意 “通常 ” 二字使用这两个字说明上述的行为不是绝对的。的确这不是绝对的这取决于SocketAcceptor 的字段 executor 的实现可以通过构造方法来设置字段 executor 的值 executor 字段的类型为 java.util.concurrent.Executor 。 mina 默认是用 org.apache.mina.util.NewThreadExecutor 它会为每一个提交的任务创建一个新的线程。因为在 bind 方法中它会把实现监听客户端请求任务的 Runnable 提交到 executor中去执行。注意千万不要使用一个不创建新线程而是在原线程中执行的 Executor 这会使程序无法监听客户端的请求因为程序中的唯一线程会被 Selector.get() 方法所阻塞详情可以查看 SocketAcceptor 类的源代码。</p>
<p>第二类线程池<br> 当 SocketAcceptor 收到了来自客户端的请求它就会把此请求丢给 SocketIoProcessor 去处理这会创建名称以 SocketAcceptorIoProcessor 为前缀的线程 mina 框架在这类线程中处理 I/O 发布并处理事件。这一类线程的数量可以通过 SocketAcceptor 的构造函数来设置。具体的值可以根据应用的具体需求来决定。 作为 I/O 真正处理的线程存在于服务器端和客户端用来处理 I/O 的读写操作线程的数量是可以配置的默认最大数量是 CPU 个数 +1 。 在服务器端中在创建 SocketAcceptor 的时候指定 ProcessorCount 。<br>SocketAcceptor acceptor = new SocketAcceptor(Runtime.getRuntime().availableProcessors() + 1, Executors.newCachedThreadPool()); NioProcessor 虽然是多线程但是对与一个连接的时候业务处理只会使用一个线程进行处理 Processor线程对于一个客户端连接只使用一个线程 NioProcessor-n 如果 handler 的业务比较耗时会导致NioProcessor 线程堵塞 在 2 个客户端同时连接上来的时候会创建第 2 个前提是第 1 个 NioProcessor 正在忙创建的最大数量由 Acceptor 构造方法的时候指定。如果一个客户端连接同服务器端有很多通信并且I/O 的开销不大但是 Handler 处理的业务时间比较长那么需要采用独立的线程模式在 FilterChain 的最后增加一个 ExecutorFitler 这个就是第三类线程池了。</p>
<p>第三类线程池<br>上述的两类线程是 mina 框架本身所创建的如果你的应用每次处理请求的时间较长而又希望应用能够有较好的响应性那么最好是把处理业务逻辑的任务放到一个新的线程中去执行而不是在 mina 框架创建的线程中去执行。 mina 框架本身提供了一个过滤器 ExecutorFilter 来完成这样的任务它会把在此之后的过滤器以及IoHandler 中处理业务逻辑的代码放到一个新的线程中去执行。当 mina 框架中的第二类线程执行完此过滤器后就会立即返回可以用于处理新的请求。如果不想使用此过滤器还可以设置 mina 的线程模型来达到相同的效果其实线程模型也是使用 ExecutorFilter 实现的。但需要注意的是在 mina 2.0 版本中已经废弃了线程模型。 使用类这三次线程池性能可以得到保证了在本项目中主要配置了第二类线程池和第三类线程池。第二类线程池在新建 NioAcceptor 对象以建立 TCP 监听服务器为例时候在其构造函数中体现而这个数值需要多次测试来设定其测试方法在国外网站有完整表述请自行 Google 第三类线程池设定在 Apache Mina 的过滤器层一般而言只需要设置一层设置在最消耗时间的业务前面如比较复杂的解码或者是数据库访问模块。 关于共享线程池问题 Apache Mina 有个官方说法你可以想让 IoServices 和 ExecutorFilters 共享一个线程池而不是一家一个。这个是不禁止的但是会出现很多问题在这种情况下除非你为 IoServices 建立一个缓冲线程池。 本人尚未考究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
</feed>