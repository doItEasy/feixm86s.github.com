<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[flyfish's Blog]]></title>
  <subtitle><![CDATA[才华配不上梦想就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-03-22T14:01:45.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[xiangming]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Redis的Master-Slave模式]]></title>
    <link href="http://www.52ff.cc/2015/03/22/Redis%E7%9A%84Master-Slave%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.52ff.cc/2015/03/22/Redis的Master-Slave模式/</id>
    <published>2015-03-22T13:51:48.000Z</published>
    <updated>2015-03-22T14:01:45.000Z</updated>
    <content type="html"><![CDATA[<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>
<p>一、Redis的Replication：</p>
<p>下面的列表清楚的解释了Redis Replication的特点和优势。<br>同一个Master可以同步多个Slaves。<br>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。因此我们可以将Redis的Replication架构视为图结构。<br>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。<br>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。<br>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成。即便如此，系统的伸缩性还是得到了很大的提高。<br>Master可以将数据保存操作交给Slaves完成，从而避免了在Master中要有独立的进程来完成此操作。</p>
<p>二、Replication的工作原理：</p>
<p>在Slave启动并连接到Master之后，它将主动发送一个SYNC命令。此后Master将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master将传送整个数据库文件到Slave，以完成一次完全同步。而Slave服务器在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master继续将所有已经收集到的修改命令，和新的修改命令依次传送给Slaves，Slave将在本次执行这些数据修改命令，从而达到最终的数据同步。<br>如果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。</p>
<p>三、如何配置Replication：</p>
<p>见如下步骤：<br>1). 同时启动两个Redis服务器，可以考虑在同一台机器上启动两个Redis服务器，分别监听不同的端口，如6379和6380。<br>2). 在Slave服务器上执行一下命令：<br>/&gt; redis-cli -p 6380   #这里我们假设Slave的端口号是6380<br>redis 127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 #我们假设Master和Slave在同一台主机，Master的端口为6379<br>OK<br>上面的方式只是保证了在执行slaveof命令之后，redis_6380成为了redis_6379的slave，一旦服务(redis_6380)重新启动之后，他们之间的复制关系将终止。<br>如果希望长期保证这两个服务器之间的Replication关系，可以在redis_6380的配置文件中做如下修改：<br>/&gt; cd /etc/redis  #切换Redis服务器配置文件所在的目录。<br>/&gt; ls<br>6379.conf  6380.conf<br>/&gt; vi 6380.conf<br>将</p>
<h1 id="slaveof">slaveof <masterip> <masterport></masterport></masterip></h1><p>改为<br>slaveof 127.0.0.1 6379<br>保存退出。<br>这样就可以保证Redis_6380服务程序在每次启动后都会主动建立与Redis_6379的Replication连接了。</p>
<p>四、应用示例：</p>
<p>这里我们假设Master-Slave已经建立。</p>
<h1 id="启动master服务器。">启动master服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6379</span>
redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;
</code></pre><h1 id="情况Master当前数据库中的所有Keys。">情况Master当前数据库中的所有Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; flushdb
OK
</code></pre><h1 id="在Master中创建新的Keys作为测试数据。">在Master中创建新的Keys作为测试数据。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; set mykey hello
OK
redis <span class="number">127.0.0.1:6379</span>&gt; set mykey2 world
OK
</code></pre><h1 id="查看Master中存在哪些Keys。">查看Master中存在哪些Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="启动slave服务器。">启动slave服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6380</span>
</code></pre><h1 id="查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。">查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="在Master中删除其中一个测试Key，并查看删除后的结果。">在Master中删除其中一个测试Key，并查看删除后的结果。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; del mykey2
(integer) <span class="number">1</span>
redis <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre><h1 id="在Slave中查看是否mykey2也已经在Slave中被删除。">在Slave中查看是否mykey2也已经在Slave中被删除。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>
<p>一、Redis的Replicatio]]>
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hello Blog]]></title>
    <link href="http://www.52ff.cc/2015/03/18/hello-blog/"/>
    <id>http://www.52ff.cc/2015/03/18/hello-blog/</id>
    <published>2015-03-17T16:14:01.000Z</published>
    <updated>2015-03-19T03:40:50.000Z</updated>
    <content type="html"><![CDATA[<p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结.<br><br>                </p>
<hr>
<a id="more"></a>
<h3 id="为什么是独立博客">为什么是独立博客</h3><p>早就有弄一个独立博客的想法，但是这是一件很花时间和精力的事情，平时忙于琐碎的工作，很难抽出时间玩这个。去年发现有朋友基于bootstrap给自己做了个人站点，发现也有些其他朋友使用markdown写内容再生成静态页面。看到朋友的站点后一下子就想行动起来了，一开始玩了jekyll,后来因为一个主题和node.js选择了hexo。<br>驱使我弄独立博客主要是这几个原因：<br>1.够酷，自己的域名，门面是自己的<br>2.独立，自由，可自定义成自己喜欢的个性的样式<br>3.不会像平台博客那样，平台一变差，博客也跟着变差，更不会有广告飞<br>4.更好的记录</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结.<br><br>                </p>
<hr>]]>
    
    </summary>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第十篇(阻塞队列和栈)]]></title>
    <link href="http://www.52ff.cc/2015/03/15/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC10%E7%AF%87-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <id>http://www.52ff.cc/2015/03/15/JAVA多线程第10篇-阻塞队列和栈/</id>
    <published>2015-03-15T12:53:09.000Z</published>
    <updated>2015-03-22T13:03:31.000Z</updated>
    <content type="html"><![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>
<a id="more"></a>
<p>下面使用ArrayBlockQueue来实现之前实现过的生产者消/费者模式<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/** 定义一个盘子类，可以放鸡蛋和取鸡蛋 */  </span><br><span class="line">public class BigPlate &#123;  </span><br><span class="line">  </span><br><span class="line">    /** 装鸡蛋的盘子，大小为<span class="number">5</span> */  </span><br><span class="line">    private BlockingQueue&lt;Object&gt; eggs = new ArrayBlockingQueue&lt;Object&gt;(<span class="number">5</span>);  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋 */  </span><br><span class="line">    public void putEgg(Object egg) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            eggs.put(egg);// 向盘子末尾放一个鸡蛋，如果盘子满了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与put操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"放入鸡蛋"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 取鸡蛋 */  </span><br><span class="line">    public Object <span class="function"><span class="title">getEgg</span></span>() &#123;  </span><br><span class="line">        Object egg = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            egg = eggs.take();// 从盘子开始取一个鸡蛋，如果盘子空了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与take操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"拿到鸡蛋"</span>);  </span><br><span class="line">        <span class="built_in">return</span> egg;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋线程 */  </span><br><span class="line">    static class AddThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">        private Object egg = new Object();  </span><br><span class="line">  </span><br><span class="line">        public AddThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.putEgg(egg);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** 取鸡蛋线程 */  </span><br><span class="line">    static class GetThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">  </span><br><span class="line">        public GetThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.getEgg();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        BigPlate plate = new BigPlate();  </span><br><span class="line">        // 先启动<span class="number">10</span>个放鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new AddThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 再启动<span class="number">10</span>个取鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new GetThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
</code></pre><p>从结果看，启动10个放鸡蛋线程和10个取鸡蛋线程，前5个放入鸡蛋的线程成功执行，到第6个，发现盘子满了，阻塞住，这时切换到取鸡蛋线程执行，成功实现了生产者/消费者模式。</p>
<p>对于阻塞栈，与阻塞队列相似。不同点在于栈是“后入先出”的结构，每次操作的是栈顶，而队列是“先进先出”的结构，每次操作的是队列头。<br>下面是一个简单例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) throws InterruptedException &#123; </span><br><span class="line">                BlockingDeque bDeque = new LinkedBlockingDeque(<span class="number">20</span>); </span><br><span class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123; </span><br><span class="line">                        //将指定元素添加到此阻塞栈中，如果没有可用空间，将一直等待（如果有必要）。 </span><br><span class="line">                        bDeque.putFirst(i); </span><br><span class="line">                        System.out.println(<span class="string">"向阻塞栈中添加了元素:"</span> + i); </span><br><span class="line">                &#125; </span><br><span class="line">                System.out.println(<span class="string">"程序到此运行结束，即将退出----"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第九篇(条件变量Condition)]]></title>
    <link href="http://www.52ff.cc/2015/03/14/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AF%87-Condition/"/>
    <id>http://www.52ff.cc/2015/03/14/JAVA多线程第九篇-Condition/</id>
    <published>2015-03-14T12:30:27.000Z</published>
    <updated>2015-03-22T12:44:36.000Z</updated>
    <content type="html"><![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>
<a id="more"></a>
<p>条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。 </p>
<p>而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。当调用signalAll()方法，又可以唤醒该条件下的等待的线程。有关Condition接口的API可以具体参考JavaAPI文档。</p>
<p>条件变量比较抽象，原因是他不是自然语言中的条件概念，而是程序控制的一种手段。</p>
<p>下面以一个银行存取款的模拟程序为例来揭盖Java多线程条件变量的神秘面纱：</p>
<p>有一个账户，多个用户（线程）在同时操作这个账户，有的存款有的取款，存款随便存，取款有限制，不能透支，任何试图透支的操作都将等待里面有足够存款才执行操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                Thread t1 = new SaveThread(<span class="string">"张三"</span>, myCount, <span class="number">2000</span>); </span><br><span class="line">                Thread t2 = new SaveThread(<span class="string">"李四"</span>, myCount, <span class="number">3600</span>); </span><br><span class="line">                Thread t3 = new DrawThread(<span class="string">"王五"</span>, myCount, <span class="number">2700</span>); </span><br><span class="line">                Thread t4 = new SaveThread(<span class="string">"老张"</span>, myCount, <span class="number">600</span>); </span><br><span class="line">                Thread t5 = new DrawThread(<span class="string">"老牛"</span>, myCount, <span class="number">1300</span>); </span><br><span class="line">                Thread t6 = new DrawThread(<span class="string">"胖子"</span>, myCount, <span class="number">800</span>); </span><br><span class="line">                //执行各个线程 </span><br><span class="line">                pool.execute(t1); </span><br><span class="line">                pool.execute(t2); </span><br><span class="line">                pool.execute(t3); </span><br><span class="line">                pool.execute(t4); </span><br><span class="line">                pool.execute(t5); </span><br><span class="line">                pool.execute(t6); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 存款线程类 </span><br><span class="line">*/ </span><br><span class="line">class SaveThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        SaveThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.saving(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 取款线程类 </span><br><span class="line">*/ </span><br><span class="line">class DrawThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        DrawThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.drawing(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 普通银行账户，不可透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;                         //账号 </span><br><span class="line">        private int cash;                             //账户余额 </span><br><span class="line">        private Lock lock = new ReentrantLock();                //账户锁 </span><br><span class="line">        private Condition _save = lock.newCondition();    //存款条件 </span><br><span class="line">        private Condition _draw = lock.newCondition();    //取款条件 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 存款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void saving(int x, String name) &#123; </span><br><span class="line">                lock.lock();                        //获取锁 </span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        cash += x;                    //存款 </span><br><span class="line">                        System.out.println(name + <span class="string">"存款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                &#125; </span><br><span class="line">                _draw.signalAll();            //唤醒所有等待线程。 </span><br><span class="line">                lock.unlock();                    //释放锁 </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 取款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void drawing(int x, String name) &#123; </span><br><span class="line">                lock.lock();                                 //获取锁 </span><br><span class="line">                try &#123; </span><br><span class="line">                        <span class="keyword">if</span> (cash - x &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                                _draw.await();             //阻塞取款操作 </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                                cash -= x;                     //取款 </span><br><span class="line">                                System.out.println(name + <span class="string">"取款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                        &#125; </span><br><span class="line">                        _save.signalAll();             //唤醒所有存款操作 </span><br><span class="line">                &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                        e.printStackTrace(); </span><br><span class="line">                &#125; finally &#123; </span><br><span class="line">                        lock.unlock();                     //释放锁 </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>李四存款3600，当前余额为13600
张三存款2000，当前余额为15600
老张存款600，当前余额为16200
老牛取款1300，当前余额为14900
胖子取款800，当前余额为14100
王五取款2700，当前余额为11400
</code></pre><p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。<br>        这样看来，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition，下面引入API中的一段代码，加以说明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer &#123;  </span><br><span class="line">   final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">   final Condition notFull  = lock.newCondition();//写线程条件   </span><br><span class="line">   final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line">  </span><br><span class="line">   final Object[] items = new Object[<span class="number">100</span>];//缓存队列  </span><br><span class="line">   int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;  </span><br><span class="line">  </span><br><span class="line">   public void put(Object x) throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == items.length)//如果队列满了   </span><br><span class="line">         notFull.await();//阻塞写线程  </span><br><span class="line">       items[putptr] = x;//赋值   </span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;//如果写索引写到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       ++count;//个数++  </span><br><span class="line">       notEmpty.signal();//唤醒读线程  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   public Object take() throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)//如果队列为空  </span><br><span class="line">         notEmpty.await();//阻塞读线程  </span><br><span class="line">       Object x = items[takeptr];//取值   </span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;//如果读索引读到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       --count;//个数--  </span><br><span class="line">       notFull.signal();//唤醒写线程  </span><br><span class="line">       <span class="built_in">return</span> x;  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，下面分析一下代码的执行过程：</p>
<pre><code><span class="bullet">1. </span>一个写线程执行，调用put方法；
<span class="bullet">2. </span>判断count是否为100，显然没有100；
<span class="bullet">3. </span>继续执行，存入值；
<span class="bullet">4. </span>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；
<span class="bullet">5. </span>仅唤醒读线程阻塞队列中的一个；
<span class="bullet">6. </span>一个读线程执行，调用take方法；
<span class="bullet">7. </span>……
<span class="bullet">8. </span>仅唤醒写线程阻塞队列中的一个。
这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第八篇(锁对象Lock)]]></title>
    <link href="http://www.52ff.cc/2015/03/13/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87-%E9%94%81%E5%AF%B9%E8%B1%A1Lock/"/>
    <id>http://www.52ff.cc/2015/03/13/JAVA多线程第八篇-锁对象Lock/</id>
    <published>2015-03-13T13:45:28.000Z</published>
    <updated>2015-03-21T14:02:32.000Z</updated>
    <content type="html"><![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre><a id="more"></a>
<p>下面看个例子帮助我们理解锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                Lock lock = new ReentrantLock(); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newCachedThreadPool(); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private Lock myLock;                //执行操作所需的锁对象 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, Lock myLock) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //获取锁 </span><br><span class="line">                myLock.lock(); </span><br><span class="line">                //执行现金业务 </span><br><span class="line">                System.out.println(name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                System.out.println(name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                //释放锁，否则别的线程没有机会执行了 </span><br><span class="line">                myLock.unlock(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为<span class="number">6000</span>，当前金额为<span class="number">6000</span> 
张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">12000</span> 
张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">12000</span> 
张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为<span class="number">4000</span> 
张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户，金额为<span class="number">800</span>，当前金额为<span class="number">4000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">800</span>，当前金额为<span class="number">4800</span> 
</code></pre><p>从上面的输出可以看到，利用锁对象太方便了，比直接在某个不知情的对象上用锁清晰多了。<br>但一定要注意的是，在获取了锁对象后，用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行。</p>
<p>上面提到的Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。</p>
<p>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                ReadWriteLock lock = new ReentrantReadWriteLock(<span class="literal">false</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u5 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">0</span>, lock, <span class="literal">true</span>); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                pool.execute(u5); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private ReadWriteLock myLock;                //执行操作所需的锁对象 </span><br><span class="line">        private boolean ischeck;        //是否查询 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, ReadWriteLock myLock, boolean ischeck) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">                this.ischeck = ischeck; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                <span class="keyword">if</span> (ischeck) &#123; </span><br><span class="line">                        //获取读锁 </span><br><span class="line">                        myLock.readLock().lock(); </span><br><span class="line">                        System.out.println(<span class="string">"读："</span> + name + <span class="string">"正在查询"</span> + myCount + <span class="string">"账户，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放读锁 </span><br><span class="line">                        myLock.readLock().unlock(); </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        //获取写锁 </span><br><span class="line">                        myLock.writeLock().lock(); </span><br><span class="line">                        //执行现金业务 </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放写锁 </span><br><span class="line">                        myLock.writeLock().unlock(); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡账户，可随意透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为-<span class="number">2000</span> 
写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户，金额为<span class="number">800</span>，当前金额为-<span class="number">2000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户成功，金额为<span class="number">800</span>，当前金额为-<span class="number">1200</span> 
读：张三他爹正在查询MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，当前金额为-<span class="number">1200</span> 
写：张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，金额为<span class="number">6000</span>，当前金额为-<span class="number">1200</span> 
写：张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">4800</span>
</code></pre><p>在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-03-17T16:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>
<a id="more"></a>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/8ZOurTlgn8RrbWoXS*BZX1J6IOluDKqIy5HvNrz*mRg!/b/dOpJsHBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/fkm63QBXo93*gpIr1Ptdcxzlq0OuPkrqkBhY.WqXWmo!/b/dO7Uq3BnEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/1LhAJQ9mFIqvqEpzyCWwgXw0IS4e*MKVXzbCTxvUyNk!/b/dGTNrnBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://b196.photo.store.qq.com/psb?/V13e7Xsb3duNUs/A4Qe**YLZomvtFndrnmyZjMRJL41EAzOSfQQZaVLpE4!/b/dN*O1HQKPwAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>]]>
    
    </summary>
    
      <category term="［宝宝］" scheme="http://www.52ff.cc/tags/%EF%BC%BB%E5%AE%9D%E5%AE%9D%EF%BC%BD/"/>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第七篇(Callable和Future)]]></title>
    <link href="http://www.52ff.cc/2015/03/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87-Callable%E5%92%8CFuture/"/>
    <id>http://www.52ff.cc/2015/03/12/JAVA多线程第七篇-Callable和Future/</id>
    <published>2015-03-12T13:36:49.000Z</published>
    <updated>2015-03-21T13:59:51.000Z</updated>
    <content type="html"><![CDATA[<p>接着上一篇继续并发包的学习，本篇说明的是Callable和Future，它俩很有意思的，一个产生结果，一个拿到结果。Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值，下面来看一个简单的例子：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CallableAndFuture &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123;  </span><br><span class="line">            public Integer call() throws Exception &#123;  </span><br><span class="line">                <span class="built_in">return</span> new Random().nextInt(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable);  </span><br><span class="line">        new Thread(future).start();  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);// 可能做一些事情  </span><br><span class="line">            System.out.println(future.get());  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到，岂不美哉！这里有一个Future模式的介绍：<a href="http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm。" target="_blank" rel="external">http://openhome.cc/Gossip/DesignPattern/FuturePattern.htm。</a><br>下面来看另一种方式使用Callable和Future，通过ExecutorService的submit方法执行Callable，并返回Future，代码如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CallableAndFuture &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();  </span><br><span class="line">        Future&lt;Integer&gt; future = threadPool.submit(new Callable&lt;Integer&gt;() &#123;  </span><br><span class="line">            public Integer call() throws Exception &#123;  </span><br><span class="line">                <span class="built_in">return</span> new Random().nextInt(<span class="number">100</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        try &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);// 可能做一些事情  </span><br><span class="line">            System.out.println(future.get());  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码是不是简化了很多，ExecutorService继承自Executor，它的目的是为我们管理Thread对象，从而简化并发编程，Executor使我们无需显示的去管理线程的生命周期，是JDK 5之后启动任务的首选方式。<br>执行多个带返回值的任务，并取得多个返回值，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CallableAndFuture &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();  </span><br><span class="line">        CompletionService&lt;Integer&gt; cs = new ExecutorCompletionService&lt;Integer&gt;(threadPool);  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">            final int taskID = i;  </span><br><span class="line">            cs.submit(new Callable&lt;Integer&gt;() &#123;  </span><br><span class="line">                public Integer call() throws Exception &#123;  </span><br><span class="line">                    <span class="built_in">return</span> taskID;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 可能做一些事情  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(cs.take().get());  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; catch (ExecutionException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也可以不使用CompletionService，可以先创建一个装Future类型的集合，用Executor提交的任务返回值添加到集合中，最后遍历集合取出数据，代码略。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接着上一篇继续并发包的学习，本篇说明的是Callable和Future，它俩很有意思的，一个产生结果，一个拿到结果。Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值，下面来看一个简单的例子：<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为性能注意的地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-17T16:13:27.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-19T04:46:23.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br></pre></td></tr></table></figure>
<p>1.图片设置成撑满整个div，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!important &gt; [ id &gt; class &gt; tag ]</span><br></pre></td></tr></table></figure></p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第五篇(并发协作例子)]]></title>
    <link href="http://www.52ff.cc/2015/03/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87-%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://www.52ff.cc/2015/03/12/JAVA多线程第五篇-并发协作-生产者消费者/</id>
    <published>2015-03-11T17:43:04.000Z</published>
    <updated>2015-03-19T17:50:10.000Z</updated>
    <content type="html"><![CDATA[<p>Java线程：并发协作-生产者消费者模型</p>
<p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：<br>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。<br>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。<br>3、当消费者发现仓储没产品可消费时候会通知生产者生产。<br>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
<a id="more"></a>
<p>此模型将要结合java.lang.Object的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">* Java线程：并发协作-生产者消费者模型 </span><br><span class="line">* </span><br><span class="line">*/</span><br><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Godown godown = new Godown(<span class="number">30</span>); </span><br><span class="line">                Consumer c1 = new Consumer(<span class="number">50</span>, godown); </span><br><span class="line">                Consumer c2 = new Consumer(<span class="number">20</span>, godown); </span><br><span class="line">                Consumer c3 = new Consumer(<span class="number">30</span>, godown); </span><br><span class="line">                Producer p1 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p2 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p3 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p4 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p5 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p6 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p7 = new Producer(<span class="number">80</span>, godown); </span><br><span class="line"></span><br><span class="line">                c1.start(); </span><br><span class="line">                c2.start(); </span><br><span class="line">                c3.start(); </span><br><span class="line">                p1.start(); </span><br><span class="line">                p2.start(); </span><br><span class="line">                p3.start(); </span><br><span class="line">                p4.start(); </span><br><span class="line">                p5.start(); </span><br><span class="line">                p6.start(); </span><br><span class="line">                p7.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 仓库 </span><br><span class="line">*/ </span><br><span class="line">class Godown &#123; </span><br><span class="line">        public static final int max_size = <span class="number">100</span>; //最大库存量 </span><br><span class="line">        public int curnum;     //当前库存量 </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">Godown</span></span>() &#123; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        Godown(int curnum) &#123; </span><br><span class="line">                this.curnum = curnum; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 生产指定数量的产品 </span><br><span class="line">         * </span><br><span class="line">         * @param neednum </span><br><span class="line">         */ </span><br><span class="line">        public synchronized void produce(int neednum) &#123; </span><br><span class="line">                //测试是否需要生产 </span><br><span class="line">                <span class="keyword">while</span> (neednum + curnum &gt; max_size) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"要生产的产品数量"</span> + neednum + <span class="string">"超过剩余库存量"</span> + (max_size - curnum) + <span class="string">"，暂时不能执行生产任务!"</span>); </span><br><span class="line">                        try &#123; </span><br><span class="line">                                //当前的生产线程等待 </span><br><span class="line">                                <span class="built_in">wait</span>(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //满足生产条件，则进行生产，这里简单的更改当前库存量 </span><br><span class="line">                curnum += neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经生产了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                //唤醒在此对象监视器上等待的所有线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 消费指定数量的产品 </span><br><span class="line">         * </span><br><span class="line">         * @param neednum </span><br><span class="line">         */ </span><br><span class="line">        public synchronized void consume(int neednum) &#123; </span><br><span class="line">                //测试是否可消费 </span><br><span class="line">                <span class="keyword">while</span> (curnum &lt; neednum) &#123; </span><br><span class="line">                        try &#123; </span><br><span class="line">                                //当前的生产线程等待 </span><br><span class="line">                                <span class="built_in">wait</span>(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //满足消费条件，则进行消费，这里简单的更改当前库存量 </span><br><span class="line">                curnum -= neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经消费了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                //唤醒在此对象监视器上等待的所有线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 生产者 </span><br><span class="line">*/ </span><br><span class="line">class Producer extends Thread &#123; </span><br><span class="line">        private int neednum;                //生产产品的数量 </span><br><span class="line">        private Godown godown;            //仓库 </span><br><span class="line"></span><br><span class="line">        Producer(int neednum, Godown godown) &#123; </span><br><span class="line">                this.neednum = neednum; </span><br><span class="line">                this.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //生产指定数量的产品 </span><br><span class="line">                godown.produce(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 消费者 </span><br><span class="line">*/ </span><br><span class="line">class Consumer extends Thread &#123; </span><br><span class="line">        private int neednum;                //生产产品的数量 </span><br><span class="line">        private Godown godown;            //仓库 </span><br><span class="line"></span><br><span class="line">        Consumer(int neednum, Godown godown) &#123; </span><br><span class="line">                this.neednum = neednum; </span><br><span class="line">                this.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //消费指定数量的产品 </span><br><span class="line">                godown.consume(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>已经生产了10个产品，现仓储量为40 
已经生产了10个产品，现仓储量为50 
已经消费了50个产品，现仓储量为0 
已经生产了80个产品，现仓储量为80 
已经消费了30个产品，现仓储量为50 
已经生产了10个产品，现仓储量为60 
已经消费了20个产品，现仓储量为40 
已经生产了10个产品，现仓储量为50 
已经生产了10个产品，现仓储量为60 
已经生产了10个产品，现仓储量为70 
</code></pre><p>说明：<br>对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的wait方法，wait方法的作用是释放当前线程的所获得的锁，并调用对象的notifyAll() 方法，通知（唤醒）该对象上其他等待线程，使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。<br>notifyAll() 方法，起到的是一个通知作用，不释放锁，也不获取锁。只是告诉该对象上等待的线程“可以竞争执行了，都醒来去执行吧”。</p>
<p>本例仅仅是生产者消费者模型中最简单的一种表示，本例中，如果消费者消费的仓储量达不到满足，而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java线程：并发协作-生产者消费者模型</p>
<p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：<br>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。<br>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。<br>3、当消费者发现仓储没产品可消费时候会通知生产者生产。<br>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第六篇(线程池)]]></title>
    <link href="http://www.52ff.cc/2015/03/11/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.52ff.cc/2015/03/11/JAVA多线程第六篇-线程池/</id>
    <published>2015-03-11T09:17:42.000Z</published>
    <updated>2015-03-21T14:04:18.000Z</updated>
    <content type="html"><![CDATA[<p>自JDK5之后，Java推出了一个并发包，java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。</p>
<p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<a id="more"></a>
<p>下面来看一下Java并发包下如何创建线程池。</p>
<p>1.创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程</p>
<pre><code><span class="constant">ExecutorService threadPool</span> = Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">// 创建可以容纳3个线程的线程池</span>
</code></pre><p>2.创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p>
<pre><code><span class="constant">ExecutorService threadPool</span> = Executors.newCachedThreadPool();<span class="comment">// 线程池的大小会根据执行的任务数动态分配</span>
</code></pre><p>3.创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。</p>
<pre><code><span class="constant">ExecutorService threadPool</span> = Executors.newSingleThreadExecutor();<span class="comment">// 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务</span>
</code></pre><p>4.创建一个可安排在给定延迟后运行命令或者定期地执行的线程池。</p>
<pre><code><span class="constant">ScheduledExecutorService threadPool</span> = Executors.newScheduledThreadPool(<span class="number">3</span>);<span class="comment">// 效果类似于Timer定时器</span>
</code></pre><p>每种线程池都有不同的使用场景，下面看一下这四种线程池使用起来有什么不同。<br>1.newFixedThreadPool</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">            final int taskID = i;  </span><br><span class="line">            threadPool.execute(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Thread.sleep(<span class="number">20</span>);// 为了测试出效果，让每次任务执行都需要一定时间  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        System.out.println(<span class="string">"第"</span> + taskID + <span class="string">"次任务的第"</span> + i + <span class="string">"次执行"</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        threadPool.shutdown();// 任务执行完毕，关闭线程池  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<pre><code>第1次任务的第1次执行  
第2次任务的第1次执行  
第3次任务的第1次执行  
第2次任务的第2次执行  
第3次任务的第2次执行  
第1次任务的第2次执行  
第3次任务的第3次执行  
第1次任务的第3次执行  
第2次任务的第3次执行  
第3次任务的第4次执行  
第2次任务的第4次执行  
第1次任务的第4次执行  
第4次任务的第1次执行  
第4次任务的第2次执行  
第4次任务的第3次执行  
第4次任务的第4次执行  
</code></pre><p>上段代码中，创建了一个固定大小的线程池，容量为3，然后循环执行了4个任务，由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4个任务，在FixedThreadPool中，有一个固定大小的池，如果当前需要执行的任务超过了池大小，那么多于的任务等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。</p>
<p>2.将newFixedThreadPool方法换成newCachedThreadPool方法</p>
<pre><code>第3次任务的第1次执行  
第4次任务的第1次执行  
第1次任务的第1次执行  
第2次任务的第1次执行  
第4次任务的第2次执行  
第3次任务的第2次执行  
第2次任务的第2次执行  
第1次任务的第2次执行  
第2次任务的第3次执行  
第3次任务的第3次执行  
第1次任务的第3次执行  
第4次任务的第3次执行  
第2次任务的第4次执行  
第4次任务的第4次执行  
第3次任务的第4次执行  
第1次任务的第4次执行
</code></pre><p> 可见，4个任务是交替执行的，CachedThreadPool会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就新创建线程，终止并且从缓存中移除已有60秒未被使用的线程。</p>
<p>3.将newFixedThreadPool方法换成newSingleThreadExecutor方法</p>
<pre><code>第1次任务的第1次执行  
第1次任务的第2次执行  
第1次任务的第3次执行  
第1次任务的第4次执行  
第2次任务的第1次执行  
第2次任务的第2次执行  
第2次任务的第3次执行  
第2次任务的第4次执行  
第3次任务的第1次执行  
第3次任务的第2次执行  
第3次任务的第3次执行  
第3次任务的第4次执行  
第4次任务的第1次执行  
第4次任务的第2次执行  
第4次任务的第3次执行  
第4次任务的第4次执行
</code></pre><p>4个任务是顺序执行的，SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同</p>
<p>4.ScheduledThreadPool<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(<span class="number">1</span>);  </span><br><span class="line">        // <span class="number">5</span>秒后执行任务  </span><br><span class="line">        schedulePool.schedule(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                System.out.println(<span class="string">"爆炸"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;, <span class="number">5</span>, TimeUnit.SECONDS);  </span><br><span class="line">        // <span class="number">5</span>秒后执行任务，以后每<span class="number">2</span>秒执行一次  </span><br><span class="line">        schedulePool.scheduleAtFixedRate(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                System.out.println(<span class="string">"爆炸"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;, <span class="number">5</span>, <span class="number">2</span>, TimeUnit.SECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ScheduledThreadPool可以定时的或延时的执行任务。<br>Java的并发包很强大，上面所说只是入门.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自JDK5之后，Java推出了一个并发包，java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。</p>
<p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简陋的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-20T03:03:03.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-20T03:35:36.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>
<a id="more"></a>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<p>[CentOS 6.2下fastDFS的完整安装和配置步骤]<br>(<a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a>)</p>
<p>[FastDFS在Ubuntu下的安装，PHP客户端]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a>)</p>
<p>[FastDFS分布式文件服务器安装，及配置，测试]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a>)</p>
<p>[FastDFS 整合Nginx问题整理]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a>)</p>
<p>[CentOS下搭建FastDFS]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a>)</p>
<p>[Ubuntu安装FastDFS全程记录]<br>(<a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a>)</p>
<p>同事小伍哥对于FastDFS性能的测试结果如下:</p>
<p>场景1：FastDFS+自带HttpServer<br>FastDFS内置了一个Http服务器，可以提供文件下载服务,使用100个线程，下载一个60M的文件，内存消耗6G左右，估计是把文件都放内存里面去了,线程数增加到500，内存占用提高到12G，剩余空闲内存几乎没有，几分钟后，服务器彻底失去响应，只有进行硬件重启.<br>FastDFS开发者表示，老早就不推荐使用内置的Http服务了</p>
<p>场景2：FastDFS+Nginx<br>编译FastDFS的Nginx支持模块，使用Nginx进行文件下载,使用1000个线程并发，下载60M大小的文件，Nginx服务器内存占用20M左右，完全没有压力</p>
<p>场景3：FastDFS+TCPClient<br>FastDFS支持TCP协议，使用其自带的客户端进行下载,使用1000个线程并发，下载60M大小的文件，FastDFS storage内存占用在120M左右，虽然表现没有Nginx那么优秀，但是性能上也足以满足需求了需要注意的是，FastDFS自带的客户端下载文件，内存占用和磁盘IO没有做较好的优化，大并发下载大文件时，会有性能问题</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-03-19T17:05:26.000Z</updated>
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><pre><code><span class="built_in">save</span>：将数据同步保存到磁盘
bgsave：将数据异步保存到磁盘
lastsave：返回上次成功将数据保存到磁盘的Unix时戳
shundown：将数据同步保存到磁盘，然后关闭服务
</code></pre><h3 id="远程服务控制">远程服务控制</h3><pre><code><span class="keyword">info</span>：提供服务器的信息和统计
monitor：实时转储收到的请求
slaveof：改变复制策略设置
config：在运行时配置Redis服务器
</code></pre><h3 id="对value操作的命令">对value操作的命令</h3><pre><code><span class="function"><span class="title">exists</span><span class="params">(key)</span></span>：确认一个key是否存在
<span class="function"><span class="title">del</span><span class="params">(key)</span></span>：删除一个key
<span class="function"><span class="title">type</span><span class="params">(key)</span></span>：返回值的类型
<span class="function"><span class="title">keys</span><span class="params">(pattern)</span></span>：返回满足给定pattern的所有key
randomkey：随机返回key空间的一个
<span class="function"><span class="title">keyrename</span><span class="params">(old name, newname)</span></span>：重命名key
dbsize：返回当前数据库中key的数目
expire：设定一个key的活动时间（s）
ttl：获得一个key的活动时间
<span class="function"><span class="title">select</span><span class="params">(index)</span></span>：按索引查询
<span class="function"><span class="title">move</span><span class="params">(key, dbindex)</span></span>：移动当前数据库中的key到dbindex数据库
flushdb：删除当前选择数据库中的所有key
flushall：删除所有数据库中的所有key
</code></pre><h3 id="对String操作的命令">对String操作的命令</h3><pre><code><span class="operator"><span class="keyword">set</span>(<span class="keyword">key</span>, <span class="keyword">value</span>)：给数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予值<span class="keyword">value</span>
<span class="keyword">get</span>(<span class="keyword">key</span>)：返回数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>
getset(<span class="keyword">key</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予上一次的<span class="keyword">value</span>
mget(key1, key2,…, <span class="keyword">key</span> N)：返回库中多个<span class="keyword">string</span>的<span class="keyword">value</span>
setnx(<span class="keyword">key</span>, <span class="keyword">value</span>)：添加<span class="keyword">string</span>，名称为<span class="keyword">key</span>，值为<span class="keyword">value</span>
setex(<span class="keyword">key</span>, <span class="keyword">time</span>, <span class="keyword">value</span>)：向库中添加<span class="keyword">string</span>，设定过期时间<span class="keyword">time</span>
mset(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：批量设置多个<span class="keyword">string</span>的值
msetnx(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：如果所有名称为<span class="keyword">key</span> i的<span class="keyword">string</span>都不存在
incr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增<span class="number">1</span>操作
incrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增加<span class="built_in">integer</span>
decr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减<span class="number">1</span>操作
decrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减少<span class="built_in">integer</span>
append(<span class="keyword">key</span>, <span class="keyword">value</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>的值附加<span class="keyword">value</span>
<span class="keyword">substr</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>的子串</span>
</code></pre><h3 id="对List操作的命令">对List操作的命令</h3><pre><code>rpush(key, value)：在名称为key的<span class="keyword">list</span>尾添加一个值为value的元素
lpush(key, value)：在名称为key的<span class="keyword">list</span>头添加一个值为value的 元素
llen(key)：返回名称为key的<span class="keyword">list</span>的长度
<span class="keyword">lrange</span>(key, start, end)：返回名称为key的<span class="keyword">list</span>中start至end之间的元素
ltrim(key, start, end)：截取名称为key的<span class="keyword">list</span>
<span class="keyword">lindex</span>(key, index)：返回名称为key的<span class="keyword">list</span>中index位置的元素
<span class="keyword">lset</span>(key, index, value)：给名称为key的<span class="keyword">list</span>中index位置的元素赋值
lrem(key, count, value)：删除count个key的<span class="keyword">list</span>中值为value的元素
lpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的首元素
rpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的尾元素
blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
brpop(key1, key2,… key N, timeout)：rpop的block版本。
rpoplpush(srckey, dstkey)：返回并删除名称为srckey的<span class="keyword">list</span>的尾元素，并将该元素添加到名称为dstkey的<span class="keyword">list</span>的头部
</code></pre><h3 id="对Set操作的命令">对Set操作的命令</h3><pre><code><span class="function"><span class="title">sadd</span><span class="params">(key, member)</span></span>：向名称为key的set中添加元素member
<span class="function"><span class="title">srem</span><span class="params">(key, member)</span></span> ：删除名称为key的set中的元素member
<span class="function"><span class="title">spop</span><span class="params">(key)</span></span> ：随机返回并删除名称为key的set中一个元素
<span class="function"><span class="title">smove</span><span class="params">(srckey, dstkey, member)</span></span> ：移到集合元素
<span class="function"><span class="title">scard</span><span class="params">(key)</span></span> ：返回名称为key的set的基数
<span class="function"><span class="title">sismember</span><span class="params">(key, member)</span></span> ：member是否是名称为key的set的元素
<span class="function"><span class="title">sinter</span><span class="params">(key1, key2,…key N)</span></span> ：求交集
<span class="function"><span class="title">sinterstore</span><span class="params">(dstkey, (keys)</span></span>) ：求交集并将交集保存到dstkey的集合
<span class="function"><span class="title">sunion</span><span class="params">(key1, (keys)</span></span>) ：求并集
<span class="function"><span class="title">sunionstore</span><span class="params">(dstkey, (keys)</span></span>) ：求并集并将并集保存到dstkey的集合
<span class="function"><span class="title">sdiff</span><span class="params">(key1, (keys)</span></span>) ：求差集
<span class="function"><span class="title">sdiffstore</span><span class="params">(dstkey, (keys)</span></span>) ：求差集并将差集保存到dstkey的集合
<span class="function"><span class="title">smembers</span><span class="params">(key)</span></span> ：返回名称为key的set的所有元素
<span class="function"><span class="title">srandmember</span><span class="params">(key)</span></span> ：随机返回名称为key的set的一个元素
</code></pre><h3 id="对Hash操作的命令">对Hash操作的命令</h3><pre><code><span class="function"><span class="title">hset</span><span class="params">(key, field, value)</span></span>：向名称为key的hash中添加元素field
<span class="function"><span class="title">hget</span><span class="params">(key, field)</span></span>：返回名称为key的hash中field对应的value
<span class="function"><span class="title">hmget</span><span class="params">(key, (fields)</span></span>)：返回名称为key的hash中field i对应的value
<span class="function"><span class="title">hmset</span><span class="params">(key, (fields)</span></span>)：向名称为key的hash中添加元素field 
<span class="function"><span class="title">hincrby</span><span class="params">(key, field, integer)</span></span>：将名称为key的hash中field的value增加integer
<span class="function"><span class="title">hexists</span><span class="params">(key, field)</span></span>：名称为key的hash中是否存在键为field的域
<span class="function"><span class="title">hdel</span><span class="params">(key, field)</span></span>：删除名称为key的hash中键为field的域
<span class="function"><span class="title">hlen</span><span class="params">(key)</span></span>：返回名称为key的hash中元素个数
<span class="function"><span class="title">hkeys</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键
<span class="function"><span class="title">hvals</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键对应的value
<span class="function"><span class="title">hgetall</span><span class="params">(key)</span></span>：返回名称为key的hash中所有的键（field）及其对应的value
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优秀技术博文分享]]></title>
    <link href="http://www.52ff.cc/2015/03/10/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/"/>
    <id>http://www.52ff.cc/2015/03/10/优秀技术博文分享/</id>
    <published>2015-03-10T02:58:18.000Z</published>
    <updated>2015-03-22T13:14:59.000Z</updated>
    <content type="html"><![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>
<a id="more"></a>
<h3 id="Nginx+tomcat配置集群负载均衡">Nginx+tomcat配置集群负载均衡</h3><p><a href="http://ari.iteye.com/blog/833153" title="Nginx+tomcat配置集群负载均衡" target="_blank" rel="external">图文解说：Nginx+tomcat配置集群负载均衡</a> </p>
<h3 id="netty学习">netty学习</h3><p><a href="http://ifeve.com/netty-2-6/" target="_blank" rel="external">并发编程网netty教程</a></p>
<h3 id="hexo搭建博客">hexo搭建博客</h3><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo搭建博客全程指导</a></p>
<h3 id="Dubbo指南">Dubbo指南</h3><p><a href="http://alibaba.github.io/dubbo-doc-static/Home-zh.htm" target="_blank" rel="external">Dubo指南</a></p>
<p>随时更新</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>]]>
    
    </summary>
    
      <category term="记录分享" scheme="http://www.52ff.cc/categories/%E8%AE%B0%E5%BD%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty笔记第一篇]]></title>
    <link href="http://www.52ff.cc/2015/03/05/netty%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/03/05/netty笔记第一篇/</id>
    <published>2015-03-05T13:37:48.000Z</published>
    <updated>2015-03-15T14:03:15.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>]]>
    </summary>
    
      <category term="［netty nio］" scheme="http://www.52ff.cc/tags/%EF%BC%BBnetty-nio%EF%BC%BD/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第四篇(线程交互)]]></title>
    <link href="http://www.52ff.cc/2015/03/02/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.52ff.cc/2015/03/02/java多线程第四篇-线程交互/</id>
    <published>2015-03-01T17:24:43.000Z</published>
    <updated>2015-03-19T17:39:27.000Z</updated>
    <content type="html"><![CDATA[<p>线程交互是比较复杂的问题，SCJP要求不很基础：给定一个场景，编写代码来恰当使用等待、通知和通知所有线程。</p>
<p>一、线程交互的基础知识</p>
<p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：<br><a id="more"></a> </p>
<p>void notify()<br>唤醒在此对象监视器上等待的单个线程。<br>void notifyAll()<br>唤醒在此对象监视器上等待的所有线程。<br>void wait()<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<p>然，wait()还有另外两个重载方法：<br>void wait(long timeout)<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。<br>void wait(long timeout, int nanos)<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<p>以上这些方法是帮助线程传递线程关心的时间状态。</p>
<p>关于等待/通知，要记住的关键点是：<br>必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。<br>wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。</p>
<p>下面看个例子就明白了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class ThreadA &#123; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        ThreadB b = new ThreadB(); </span><br><span class="line">        //启动计算线程 </span><br><span class="line">        b.start(); </span><br><span class="line">        //线程A拥有b对象上的锁。线程为了调用<span class="built_in">wait</span>()或notify()方法，该线程必须是那个对象锁的拥有者 </span><br><span class="line">        synchronized (b) &#123; </span><br><span class="line">            try &#123; </span><br><span class="line">                System.out.println(<span class="string">"等待对象b完成计算。。。"</span>); </span><br><span class="line">                //当前线程A等待 </span><br><span class="line">                b.wait(); </span><br><span class="line">            &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"b对象计算的总和是："</span> + b.total); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThreadB extends Thread &#123; </span><br><span class="line">    int total; </span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">        synchronized (this) &#123; </span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                total += i; </span><br><span class="line">            &#125; </span><br><span class="line">            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒 </span><br><span class="line">            notify(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待对象b完成计算。。。<br>b对象计算的总和是：5050 </p>
<p>千万注意：<br>当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程荣然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。</p>
<p>二、多个线程在等待一个对象锁时候使用notifyAll()</p>
<p>在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。</p>
<p>下面给个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Calculator extends Thread &#123; </span><br><span class="line">        int total; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                synchronized (this) &#123; </span><br><span class="line">                        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                                total += i; </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //通知所有在此对象上等待的线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReaderResult extends Thread &#123; </span><br><span class="line">        Calculator c; </span><br><span class="line"></span><br><span class="line">        public ReaderResult(Calculator c) &#123; </span><br><span class="line">                this.c = c; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                synchronized (c) &#123; </span><br><span class="line">                        try &#123; </span><br><span class="line">                                System.out.println(Thread.currentThread() + <span class="string">"等待计算结果。。。"</span>); </span><br><span class="line">                                c.wait(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"计算结果为："</span> + c.total); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Calculator calculator = new Calculator(); </span><br><span class="line"></span><br><span class="line">                //启动三个线程，分别获取计算结果 </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                //启动计算线程 </span><br><span class="line">                calculator.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>运行结果：
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]等待计算结果。。。 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]等待计算结果。。。 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">3</span>,<span class="number">5</span>,main]等待计算结果。。。 
Exception in thread <span class="string">"Thread-0"</span> java.lang.IllegalMonitorStateException: current thread not owner 
  at java.lang.Object.notifyAll(Native <span class="keyword">Method</span>) 
  at threadtest.Calculator.run(Calculator.java:<span class="number">18</span>) 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">3</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
</code></pre><p>运行结果表明，程序中有异常，并且多次运行结果可能有多种输出结果。这就是说明，这个多线程的交互程序还存在问题。究竟是出了什么问题，需要深入的分析和思考，下面将做具体分析。</p>
<p>实际上，上面这个代码中，我们期望的是读取结果的线程在计算线程调用notifyAll()之前等待即可。 但是，如果计算线程先执行，并在读取结果线程等待之前调用了notify()方法，那么又会发生什么呢？这种情况是可能发生的。因为无法保证线程的不同部分将按照什么顺序来执行。幸运的是当读取线程运行时，它只能马上进入等待状态——它没有做任何事情来检查等待的事件是否已经发生。  ——因此，如果计算线程已经调用了notifyAll()方法，那么它就不会再次调用notifyAll()，——并且等待的读取线程将永远保持等待。这当然是开发者所不愿意看到的问题。</p>
<p>因此，当等待的事件发生时，需要能够检查notifyAll()通知事件是否已经发生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>线程交互是比较复杂的问题，SCJP要求不很基础：给定一个场景，编写代码来恰当使用等待、通知和通知所有线程。</p>
<p>一、线程交互的基础知识</p>
<p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写了个异或加密小程序]]></title>
    <link href="http://www.52ff.cc/2015/02/22/%E5%86%99%E4%BA%86%E4%B8%AA%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.52ff.cc/2015/02/22/写了个异或加密小程序/</id>
    <published>2015-02-22T13:40:50.000Z</published>
    <updated>2015-03-15T14:01:46.000Z</updated>
    <content type="html"><![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>
<a id="more"></a>
<p>代码如下，记录下以后review用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class XORCodec &#123;</span><br><span class="line">	private final static String key = <span class="string">"unisms"</span>;  //密钥</span><br><span class="line">	private static String EncodeType =<span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 加密(字节版)，字节异或后转<span class="number">16</span>进制</span><br><span class="line">	 * @param @throws UnsupportedEncodingException</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">53</span>:<span class="number">55</span></span><br><span class="line">	 */</span><br><span class="line">	public static String encrypt(String <span class="keyword">in</span>Str) throws UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">		byte[] b=<span class="keyword">in</span>Str.getBytes(EncodeType);</span><br><span class="line">		byte[] snNum = new byte[b.length];</span><br><span class="line">		byte[] c=key.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; b.length; i++, j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == c.length)</span><br><span class="line">				j = <span class="number">0</span>;</span><br><span class="line">			snNum[i] = (byte)(b[i] ^ c[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			result= byte2HexStr(snNum);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 解密(字节版)，将<span class="number">16</span>进制字符串每<span class="number">2</span>位转成INT，再转成byte</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">54</span>:<span class="number">34</span></span><br><span class="line">	 */</span><br><span class="line">	public static String decrypt(String instr)&#123;</span><br><span class="line">		byte[] snNum=null;</span><br><span class="line">		byte[] c=null;</span><br><span class="line">		int len;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			len = instr.length()/<span class="number">2</span>;</span><br><span class="line">			snNum = new byte[len];</span><br><span class="line">			c=key.getBytes();</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++, j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == c.length)</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				snNum[i] = (byte) ((byte)(Integer.parseInt(instr.substring(i*<span class="number">2</span>,i*<span class="number">2</span>+<span class="number">2</span>),<span class="number">16</span>)) ^ c[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			result=new String(snNum,EncodeType);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bytes转换成十六进制字符</span><br><span class="line">	 */</span><br><span class="line">	public static String byte2HexStr(byte[] b)</span><br><span class="line">	&#123;</span><br><span class="line">		String stmp=<span class="string">""</span>;</span><br><span class="line">		StringBuilder sb = new StringBuilder(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span> (int n=<span class="number">0</span>;n&lt;b.length;n++)</span><br><span class="line">		&#123;</span><br><span class="line">			stmp = Integer.toHexString(b[n] &amp; <span class="number">0</span>xFF);//<span class="number">0</span>xFF即<span class="number">256</span>相当于<span class="number">11111111</span></span><br><span class="line">			sb.append((stmp.length()==<span class="number">1</span>)? <span class="string">"0"</span>+stmp : stmp);</span><br><span class="line">			sb.append(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> sb.toString().toUpperCase().trim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 加密(字符版)</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String encrypt2(String data)&#123;</span><br><span class="line">		int[] temp = new int[data.length()];</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		//循环需加密的字符串和密钥，分别从需加密字符串和密钥中获取一个字符进行异或</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;data.length();i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			temp[i] = data.charAt(i)^key.charAt(j);//需加密的字符串中一个字符和密钥中一个字符异或得到十进制的整数</span><br><span class="line">			str = Integer.toHexString(temp[i]);//将十进制转化成<span class="number">16</span>进制</span><br><span class="line">			<span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;//不足<span class="number">4</span>位的进行补零</span><br><span class="line">				str = <span class="string">"000"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">2</span>)&#123;</span><br><span class="line">				str = <span class="string">"00"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">3</span>)&#123;</span><br><span class="line">				str = <span class="string">"0"</span>+str;</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span>  result.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 解密(字符版)</span><br><span class="line">	 * @throws</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String decrypt2(String data)&#123;</span><br><span class="line">		char[] c=new char[data.length()/<span class="number">4</span>];//加密后的长度是原先的<span class="number">4</span>倍</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;c.length;i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			int n = Integer.parseInt(data.substring(i*<span class="number">4</span>,i*<span class="number">4</span>+<span class="number">4</span>),<span class="number">16</span>);//将<span class="number">16</span>进制的字符串解析为整数，因为加密时不足<span class="number">4</span>位补到<span class="number">4</span>位，所以每四个进行一次转化</span><br><span class="line">			c[i]=(char)((char)n^key.charAt(j));//重新和密钥中字符异或还原成原先的字符</span><br><span class="line">			result.append(c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第三篇(线程同步synchronized和volatile)]]></title>
    <link href="http://www.52ff.cc/2015/02/19/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/02/19/JAVA多线程第三篇/</id>
    <published>2015-02-19T15:38:30.000Z</published>
    <updated>2015-03-19T17:14:04.000Z</updated>
    <content type="html"><![CDATA[<p>当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。” 首先我们创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。</p>
<a id="more"></a>
<h2 id="抛出问题">抛出问题</h2><h3 id="线程的安全和不安全">线程的安全和不安全</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Count &#123;  </span><br><span class="line">    private int num;  </span><br><span class="line">    public void <span class="function"><span class="title">count</span></span>() &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            num += i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line">public class ThreadTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Runnable runnable = new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">            Count count = new Count();  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                count.count();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(runnable).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了10个线程，看一下输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>-<span class="number">55</span>  </span><br><span class="line">Thread-<span class="number">1</span>-<span class="number">110</span>  </span><br><span class="line">Thread-<span class="number">2</span>-<span class="number">165</span>  </span><br><span class="line">Thread-<span class="number">4</span>-<span class="number">220</span>  </span><br><span class="line">Thread-<span class="number">5</span>-<span class="number">275</span>  </span><br><span class="line">Thread-<span class="number">6</span>-<span class="number">330</span>  </span><br><span class="line">Thread-<span class="number">3</span>-<span class="number">385</span>  </span><br><span class="line">Thread-<span class="number">7</span>-<span class="number">440</span>  </span><br><span class="line">Thread-<span class="number">8</span>-<span class="number">495</span>  </span><br><span class="line">Thread-<span class="number">9</span>-<span class="number">550</span></span><br></pre></td></tr></table></figure>
<p>只有Thread-0线程输出的结果是我们期望的，不安全的情况下输出的结果恰好是逐个递增的(其实是巧合，多运行几次，会产生不同的输出结果)，为什么会产生这样的结果呢，因为建立的Count对象是线程共享的，一个线程改变了其成员变量num值，下一个线程正巧读到了修改后的num，所以会递增输出。想得到我们期望的结果，有几种解决方案：</p>
<ol>
<li>将Count中num变成count方法的局部变量；</li>
<li>将线程类成员变量拿到run方法中，这时count引用是线程内的局部变量；</li>
</ol>
<p>上述测试，我们发现，存在成员变量的类用于多线程时是不安全的，不安全体现在这个成员变量可能发生非原子性的操作，而变量定义在方法内也就是局部变量是线程安全的。</p>
<h3 id="JAVA线程的两个特性，可见性和有序性">JAVA线程的两个特性，可见性和有序性</h3><p>要说明线程同步问题首先要说明Java线程的两个特性，可见性和有序性。多个线程之间是不能直接传递数据交互的，它们之间的交互只能通过共享变量来实现。拿上面的例子来说明，在多个线程之间共享了Count类的一个对象，这个对象是被创建在主内存(堆内存)中，每个线程都有自己的工作内存(线程栈)，工作内存存储了主内存Count对象的一个副本，当线程操作Count对象时，首先从主内存复制Count对象到工作内存中，然后执行代码count.count()，改变了num值，最后用工作内存Count刷新主内存Count。当一个对象在多个内存中都存在副本时，如果一个内存修改了共享变量，其它线程也应该能够看到被修改后的值，此为可见性。多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，先取款后汇款或者先汇款后取款，此为有序性。本文讲述了JDK5.0之前传统线程的同步方式，更高级的同步方式之后再叙述。<br>    下面同样用代码来展示一下线程同步问题。<br>    创建两个线程，执行同一个对象的输出方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TraditionalThreadSynchronized &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        final Outputter output = new Outputter();  </span><br><span class="line">        new <span class="function"><span class="title">Thread</span></span>() &#123;  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                output.output(<span class="string">"zhangsan"</span>);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">        new <span class="function"><span class="title">Thread</span></span>() &#123;  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                output.output(<span class="string">"lisi"</span>);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Outputter &#123;  </span><br><span class="line">    public void output(String name) &#123;  </span><br><span class="line">        // TODO 为了保证对name的输出不是一个原子操作，这里逐个输出name的每个字符  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">            // Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：zhlainsigsan</p>
<h2 id="synchronized">synchronized</h2><p>显然输出的字符串被打乱了，我们期望的输出结果是zhangsanlisi，这就是线程同步问题，我们希望output方法被一个线程完整的执行完之后再切换到下一个线程，Java中使用synchronized保证一段代码在多线程执行时是互斥的，有两种用法：</p>
<pre><code><span class="number">1.</span> 使用<span class="keyword">synchronized</span>将需要互斥的代码包含起来，并上一把锁。
</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    synchronized (this) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这把锁必须是需要互斥的多个线程间的共享对象，像下面的代码是没有意义的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    Object lock = new Object();  </span><br><span class="line">    synchronized (lock) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次进入output方法都会创建一个新的lock，这个锁显然每个线程都会创建，没有意义。</p>
<pre><code><span class="number">2.</span> 将<span class="keyword">synchronized</span>加在需要互斥的方法上。
</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public synchronized void output(String name) &#123;  </span><br><span class="line">    // TODO 线程输出方法  </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">        System.out.print(name.charAt(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式就相当于用this锁住整个方法内的代码块，如果用synchronized加在静态方法上，就相当于用××××.class锁住整个方法内的代码块。使用synchronized在某些情况下会造成死锁，死锁问题以后会说明。使用synchronized修饰的方法或者代码块可以看成是一个原子操作。<br>每个锁对(JLS中叫monitor)都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个线程被唤醒(notify)后，才会进入到就绪队列，等待CPU的调度，反之，当一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒，这个涉及到线程间的通信，下一篇博文会说明。看我们的例子，当第一个线程执行输出方法时，获得同步锁，执行输出方法，恰好此时第二个线程也要执行输出方法，但发现同步锁没有被释放，第二个线程就会进入就绪队列，等待锁被释放。一个线程执行互斥代码过程如下：</p>
<ol>
<li>获得同步锁；</li>
<li>清空工作内存；</li>
<li>从主内存拷贝对象副本到工作内存；</li>
<li>执行代码(计算或者输出等)；</li>
<li>刷新主内存数据；</li>
<li>释放同步锁。<br>所以，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。</li>
</ol>
<h2 id="volatile">volatile</h2><p>volatile是第二种Java多线程同步的机制，根据JLS(Java LanguageSpecifications)的说法，一个变量可以被volatile修饰，在这种情况下内存模型(主内存和线程工作内存)确保所有线程可以看到一致的变量值，来看一段代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些线程执行one方法，另一些线程执行two方法，two方法有可能打印出j比i大的值，按照之前分析的线程执行过程分析一下：</p>
<ol>
<li>将变量i从主内存拷贝到工作内存；</li>
<li>改变i的值；</li>
<li>刷新主内存数据；</li>
<li>将变量j从主内存拷贝到工作内存；</li>
<li>改变j的值；</li>
<li>刷新主内存数据；<br>这个时候执行two方法的线程先读取了主存i原来的值又读取了j改变后的值，这就导致了程序的输出不是我们预期的结果，要阻止这种不合理的行为的一种方式是在one方法和two方法前面加上synchronized修饰符：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static synchronized void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static synchronized void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据前面的分析，我们可以知道，这时one方法和two方法再也不会并发的执行了，i和j的值在主内存中会一直保持一致，并且two方法输出的也是一致的。另一种同步的机制是在共享变量之前加上volatile：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static volatile int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>one方法和two方法还会并发的去执行，但是加上volatile可以将共享变量i和j的改变直接响应到主内存中，这样保证了主内存中i和j的值一致性，然而在执行two方法时，在two方法获取到i的值和获取到j的值中间的这段时间，one方法也许被执行了好多次，导致j的值会大于i的值。所以volatile可以保证内存可见性，不能保证并发有序性。<br>没有明白JLS中为什么使用两个变量来阐述volatile的工作原理，这样不是很好理解。volatile是一种弱的同步手段，相对于synchronized来说，某些情况下使用，可能效率更高，因为它不是阻塞的，尤其是读操作时，加与不加貌似没有影响，处理写操作的时候，可能消耗的性能更多些。但是volatile和synchronized性能的比较，我也说不太准，多线程本身就是比较玄的东西，依赖于CPU时间分片的调度，JVM更玄，还没有研究过虚拟机，从顶层往底层看往往是比较难看透的。在JDK5.0之前，如果没有参透volatile的使用场景，还是不要使用了，尽量用synchronized来处理同步问题，线程阻塞这玩意简单粗暴。另外volatile和final不能同时修饰一个字段，可以想想为什么。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。” 首先我们创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL优化的几条建议]]></title>
    <link href="http://www.52ff.cc/2015/02/19/SQL%E4%BC%98%E5%8C%96%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%9D%A1%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/19/SQL优化的若干条技巧/</id>
    <published>2015-02-19T06:50:55.000Z</published>
    <updated>2015-03-19T17:03:21.000Z</updated>
    <content type="html"><![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>
<a id="more"></a>
<h3 id="选择最有效率的表名顺序_(只在基于规则的优化器中有效)_：">选择最有效率的表名顺序 (只在基于规则的优化器中有效) ：</h3><pre><code>ORACLE 的解析器按照从右到左的顺序处理 <span class="keyword">FROM</span> 子句中的表名， <span class="keyword">FROM</span> 子句中写在最右的表将被最先处理，所以我们需要把记录最少的表写在最右边。如果有<span class="number">3</span>个以上的表连接查询，那就需要选择交叉表写在最右，交叉表是指那个被其他表所引用的表。
简而言之：大表在前，小表在后
</code></pre><h3 id="WHERE子句中的连接顺序：">WHERE子句中的连接顺序：</h3><pre><code>ORACLE采用自下而上的顺序解析 <span class="keyword">WHERE</span> 子句,根据这个原理 , 表之间的连接必须写在其他 <span class="keyword">WHERE</span> 条件之前 , 那些可以过滤掉最大数量记录的条件必须写在 <span class="keyword">WHERE</span> 子句的末尾<span class="built_in">.</span>
</code></pre><h3 id="SELECT子句中避免使用’*’_：">SELECT子句中避免使用’*’ ：</h3><pre><code>ORACLE在解析的过程中,会将 <span class="string">'*'</span>  依次转换成所有的列名 ,  这个工作是通过查询数据字典完成的 , 这意味着将耗费更多的时间
</code></pre><h3 id="使用_DECODE_函数来减少处理时间：">使用 DECODE 函数来减少处理时间：</h3><pre><code>使用<span class="variable">DECODE</span> 函数可以避免重复扫描相同记录或重复连接相同的表 .
</code></pre><h3 id="删除重复记录：">删除重复记录：</h3><pre><code>最高效的删除重复记录方法 (因为使用了 ROWID) 例子：
<span class="operator"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span>  EMP E  <span class="keyword">WHERE</span>  E.ROWID &gt; (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(X.ROWID) <span class="keyword">FROM</span>  EMP X  <span class="keyword">WHERE</span>  X.EMP_NO = E.EMP_NO);</span>
</code></pre><h3 id="用_TRUNCATE_替代_DELETE_：">用 TRUNCATE 替代 DELETE ：</h3><pre><code>当删除表中的记录时, 在通常情况下 ,  回滚段 (<span class="operator"><span class="keyword">rollback</span> segments)  用来存放可以被恢复的信息 .  如果你没有 <span class="keyword">COMMIT</span> 事务 ,ORACLE 会将数据恢复到删除之前的状态 (准确地说是恢复到执行删除命令之前的状况)  而当运用 <span class="keyword">TRUNCATE</span> 时 ,  回滚段不再存放任何可被恢复的信息 . 当命令运行后 , 数据不能被恢复 . 因此很少的资源被调用,执行时间也会很短.</span>
</code></pre><h3 id="尽量多使用_COMMIT_：">尽量多使用 COMMIT ：</h3><pre><code>只要有可能, 在程序中尽量多使用 <span class="operator"><span class="keyword">COMMIT</span>,  这样程序的性能得到提高 , 需求也会因为 <span class="keyword">COMMIT</span> 所释放的资源而减少 :
<span class="keyword">COMMIT</span>所释放的资源 :
a. 回滚段上用于恢复数据的信息
b. 被程序语句获得的锁
c. redo <span class="keyword">log</span> buffer 中的空间
d. ORACLE为管理上述 <span class="number">3</span> 种资源中的内部花费</span>
</code></pre><h3 id="用_Where_子句替换_HAVING_子句：">用 Where 子句替换 HAVING 子句：</h3><pre><code>避免使用HAVING 子句 , HAVING  只会在检索出所有记录之后才对结果集进行过滤 .  这个处理需要排序 , 总计等操作 . 如果能通过 WHERE 子句限制记录的数目 , 那就能减少这方面的开销.<span class="keyword">on</span> 、 <span class="keyword">where</span> 、 having 这三个都可以加条件的子句中， <span class="function_start"><span class="keyword">on</span></span> 是最先执行， <span class="keyword">where</span> 次之， having 最后
</code></pre><h3 id="用_EXISTS_替代_IN_、用_NOT_EXISTS_替代_NOT_IN_：">用 EXISTS 替代 IN 、用 NOT EXISTS 替代 NOT IN ：</h3><pre><code>在许多基于基础表的查询中, 为了满足一个条件 , 往往需要对另一个表进行联接 . 在这种情况下 ,  使用 EXISTS(或 <span class="keyword">NOT</span> EXISTS) 通常将提高查询的效率 . 在子查询中 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 子句将执行一个内部的排序和合并 .  无论在哪种情况下 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 都是最低效的  (因为它对子查询中的表执行了一个全表遍历 ).  为了避免使用 <span class="keyword">NOT</span> <span class="keyword">IN</span> , 我们可以把它改写成外连接 (Outer Joins) 或 <span class="keyword">NOT</span> EXISTS.

(高效)<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  EXISTS (<span class="keyword">SELECT</span>  ‘ X<span class="comment">'  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC =  ‘ MELB')</span>

(低效)<span class="keyword">SELECT</span>  * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  DEPTNO <span class="keyword">IN</span>(<span class="keyword">SELECT</span> DEPTNO  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span>  LOC =  ‘ MELB<span class="comment">')</span>
</code></pre><h3 id="使用表的别名_(Alias)_：">使用表的别名 (Alias) ：</h3><pre><code>当在SQL 语句中连接多个表时 ,  请使用表的别名并把别名前缀于每个 <span class="keyword">Column</span> 上 . 这样一来 , 就可以减少解析的时间并减少那些由 <span class="keyword">Column</span> 歧义引起的语法错误 .
</code></pre><h3 id="避免在索引列上使用计算．">避免在索引列上使用计算．</h3><pre><code>WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．
低效：
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span> SAL * <span class="number">12</span> &gt; <span class="number">25000</span>;</span>
高效:
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span> DEPT <span class="keyword">WHERE</span> SAL &gt; <span class="number">25000</span>/<span class="number">12</span>;</span>
</code></pre><h3 id="用_&gt;=_替代_&gt;">用 &gt;= 替代 &gt;</h3><pre><code>高效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP  <span class="keyword">WHERE</span>  DEPTNO &gt;=<span class="number">4</span>
低效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;<span class="number">3</span>

两者的区别在于,  前者 DBMS 将直接跳到第一个 DEPT 等于 <span class="number">4</span> 的记录而后者将首先定位到 DEPTNO=<span class="number">3</span> 的记录并且向前扫描到第一个 DEPT 大于 <span class="number">3</span> 的记录 .
</code></pre><h3 id="减少对表的查询：">减少对表的查询：</h3><pre><code>在含有子查询的SQL 语句中 , 要特别注意减少对表的查询 . 例子：
    <span class="operator"><span class="keyword">SELECT</span>  TAB_NAME <span class="keyword">FROM</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> (TAB_NAME,DB_VER) = ( <span class="keyword">SELECT</span> TAB_NAME,DB_VER <span class="keyword">FROM</span>  TAB_COLUMNS  <span class="keyword">WHERE</span>  <span class="keyword">VERSION</span> = <span class="number">604</span>)</span>
</code></pre><h3 id="sql语句用大写的：">sql语句用大写的：</h3><pre><code>因为oracle 总是先解析 sql 语句，把小写的字母转换成大写的再执行
</code></pre><h3 id="在_java_代码中尽量少用连接符_“_＋_”_连接字符串！">在 java 代码中尽量少用连接符 “ ＋ ” 连接字符串！</h3><h3 id="避免在索引列上使用_NOT_：">避免在索引列上使用 NOT ：</h3><pre><code>我们要避免在索引列上使用<span class="literal">NOT</span>, <span class="literal">NOT</span> 会产生在和在索引列上使用函数相同的影响 .  当 ORACLE ” 遇到 ” <span class="literal">NOT</span>, 他就会停止使用索引转而执行全表扫描 .
</code></pre><h3 id="通过内部函数提高_SQL_效率：">通过内部函数提高 SQL 效率：</h3><pre><code>复杂的SQL 往往牺牲了执行效率 . 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的
</code></pre><h3 id="识别_‘_低效执行_‘_的_SQL_语句：">识别 ‘ 低效执行 ‘ 的 SQL 语句：</h3><pre><code>虽然目前各种关于SQL 优化的图形化工具层出不穷 , 但是写出自己的 SQL 工具来解决问题始终是一个最好的方法：
<span class="operator"><span class="keyword">SELECT</span>  EXECUTIONS , DISK_READS, BUFFER_GETS,
<span class="keyword">ROUND</span>((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) Hit_radio,
<span class="keyword">ROUND</span>(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,
SQL_TEXT
<span class="keyword">FROM</span>  V$SQLAREA
<span class="keyword">WHERE</span>  EXECUTIONS&gt;<span class="number">0</span>
<span class="keyword">AND</span>  BUFFER_GETS &gt; <span class="number">0</span>
<span class="keyword">AND</span>  (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span>
<span class="keyword">ORDER</span> <span class="keyword">BY</span>  <span class="number">4</span> <span class="keyword">DESC</span>;</span>
</code></pre><h3 id="用索引提高效率：">用索引提高效率：</h3><pre><code>索引是表的一个概念部分, 用来提高检索数据的效率， ORACLE 使用了一个复杂的自平衡 B-tree 结构 .  通常 , 通过索引查询数据比全表扫描要快 .  当 ORACLE 找出执行查询和 <span class="operator"><span class="keyword">Update</span> 语句的最佳路径时 , ORACLE 优化器将使用索引 .  同样在联结多个表时使用索引也可以提高效率 .  另一个使用索引的好处是 , 它提供了主键 (<span class="keyword">primary</span> <span class="keyword">key</span>) 的唯一性验证 . 。那些 LONG 或 LONG RAW 数据类型 ,  你可以索引几乎所有的列 .  通常 ,  在大型表中使用索引特别有效 .  当然 , 你也会发现 ,  在扫描小表时 , 使用索引同样能提高效率 .  虽然使用索引能得到查询效率的提高 , 但是我们也必须注意到它的代价 .  索引需要空间来存储 , 也需要定期维护 ,  每当有记录在表中增减或索引列被修改时 ,  索引本身也会被修改 .  这意味着每条记录的 <span class="keyword">INSERT</span> , <span class="keyword">DELETE</span> , <span class="keyword">UPDATE</span> 将为此多付出 <span class="number">4</span> , <span class="number">5</span>  次的磁盘 I/O .  因为索引需要额外的存储空间和处理 , 那些不必要的索引反而会使查询反应时间变慢 . 。定期的重构索引是有必要的 . <span class="keyword">ALTER</span>  <span class="keyword">INDEX</span> &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt;</span>
</code></pre><h3 id="用_UNION_替换_OR_(_适用于索引列_)">用 UNION 替换 OR ( 适用于索引列 )</h3><pre><code>通常情况下,  用 <span class="keyword">UNION</span> 替换 <span class="keyword">WHERE</span> 子句中的 <span class="keyword">OR</span> 将会起到较好的效果 .  对索引列使用 <span class="keyword">OR</span> 将造成全表扫描 .  注意 ,  以上规则只针对多个索引列有效 .  如果有 column 没有被索引 ,  查询效率可能会因为你没有选择 <span class="keyword">OR</span> 而降低 .  在下面的例子中 , LOC_ID  和 REGION 上都建有索引 .

高效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span>
<span class="keyword">UNION</span>
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> REGION = “ MELBOURNE ”
低效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> REGION = “ MELBOURNE ”
如果你坚持要用<span class="keyword">OR</span>,  那就需要返回记录最少的索引列写在最前面 .
</code></pre><h3 id="用_IN_来替换_OR">用 IN 来替换 OR</h3><pre><code>低效:
<span class="operator"><span class="keyword">SELECT</span>… . <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> LOC_ID = <span class="number">20</span> <span class="keyword">OR</span> LOC_ID = <span class="number">30</span>

高效
<span class="keyword">SELECT</span>…  <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_IN  <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span>
</code></pre><h3 id="避免在索引列上使用_IS_NULL_和_IS_NOT_NULL">避免在索引列上使用 IS NULL 和 IS NOT NULL</h3><pre><code>避免在索引中使用任何可以为空的列，ORACLE 将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录 .  对于复合索引，如果每个列都为空，索引中同样不存在此记录 . 　如果至少有一个列不为空，则记录存在于索引中．举例 :  如果唯一性索引建立在表的 A 列和 B 列上 ,  并且表中存在一条记录的 A,B 值为 (123,null) , ORACLE 将不接受下一条具有相同 A,B 值 (123,null) 的记录 ( 插入 ).  然而如果所有的索引列都为空， ORACLE 将认为整个键值为空而空不等于空 .  因此你可以插入 1000  条具有相同键值的记录 , 当然它们都是空 !  因为空值不存在于索引列中 , 所以 WHERE 子句中对索引列进行空值比较将使 ORACLE 停用该索引 .

索引失效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span>
索引有效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE &gt;=<span class="number">0</span>;</span>
</code></pre><h3 id="总是使用索引的第一个列：">总是使用索引的第一个列：</h3><pre><code>如果索引是建立在多个列上,  只有在它的第一个列 (leading column) 被 <span class="keyword">where</span> 子句引用时 , 优化器才会选择使用该索引 .  这也是一条简单而重要的规则，当仅引用索引的第二个列时 , 优化器使用了全表扫描而忽略了索引
</code></pre><h3 id="用_UNION-ALL_替换_UNION_(如果业务允许)_：">用 UNION-ALL  替换 UNION (如果业务允许) ：</h3><pre><code>当SQL  语句需要 <span class="keyword">UNION</span> 两个查询结果集合时 , 这两个结果集合会以 <span class="keyword">UNION</span>-ALL 的方式被合并 ,  然后在输出最终结果前进行排序 .  如果用 <span class="keyword">UNION</span> ALL 替代 <span class="keyword">UNION</span>,  这样排序就不是必要了 .  效率就会因此得到提高 .  需要注意的是， <span class="keyword">UNION</span> ALL  将重复输出两个结果集合中相同记录 .  因此各位还是要从业务需求分析使用 <span class="keyword">UNION</span> ALL 的可行性 . <span class="keyword">UNION</span>  将对结果集合排序 , 这个操作会使用到 SORT_AREA_SIZE 这块内存 .  对于这块内存的优化也是相当重要的 .  下面的 SQL 可以用来查询排序的消耗量
</code></pre><h3 id="用_WHERE_替代_ORDER_BY_：">用 WHERE 替代 ORDER BY ：</h3><pre><code><span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句只在两种严格的条件下使用索引
<span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序 <span class="built_in">.
</span><span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须定义为非空 <span class="built_in">.
</span><span class="keyword">WHERE</span>子句使用的索引和 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中所使用的索引不能并列 <span class="built_in">.

</span>例如:
表DEPT 包含以下列 :
DEPT_CODE PK <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_DESC <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_TYPE <span class="built_in">NULL</span>

低效: ( 索引不被使用 
<span class="keyword">SELECT</span> DEPT_CODE FROM  DEPT  <span class="keyword">ORDER</span> <span class="keyword">BY</span>  DEPT_TYPE
高效: ( 使用索引 )
<span class="keyword">SELECT</span> DEPT_CODE  FROM  DEPT  <span class="keyword">WHERE</span>  DEPT_TYPE <span class="subst">&gt;</span> <span class="number">0</span>
</code></pre><h3 id="避免改变索引列的类型_:">避免改变索引列的类型 :</h3><pre><code>当比较不同数据类型的数据时, ORACLE 自动对列进行简单的类型转换 .
假设 EMPNO 是一个数值类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = ‘<span class="number">123</span><span class="comment">'</span>
实际上, 经过 ORACLE 类型转换 ,  语句转化为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = TO_NUMBER(‘<span class="number">123</span><span class="comment">')</span>
幸运的是, 类型转换没有发生在索引列上 , 索引的用途没有被改变 .
现在, 假设 EMP_TYPE 是一个字符类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span> EMP_TYPE = <span class="number">123</span>
这个语句被ORACLE 转换为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  WHERETO_NUMBER(EMP_TYPE)=<span class="number">12</span>    
因为内部发生的类型转换,  这个索引将不会被用到 !  为了避免 ORACLE 对你的 SQL 进行隐式的类型转换 ,  最好把类型转换用显式表现出来 .  注意当字符和数值比较时 , ORACLE 会优先转换数值类型到字符类型
</code></pre><h3 id="需要当心的_WHERE_子句_:">需要当心的 WHERE 子句 :</h3><pre><code>某些<span class="keyword">SELECT</span> 语句中的 <span class="keyword">WHERE</span> 子句不使用索引 . 这里有一些例子 .
在下面的例子里,
(<span class="number">1</span>)‘ !=<span class="comment">'  将不使用索引 .  记住 ,  索引只能告诉你什么存在于表中 ,  而不能告诉你什么不存在于表中 .</span>
(<span class="number">2</span>) ‘ ||<span class="comment">' 是字符连接函数 .  就象其他函数那样 ,  停用了索引 .</span>
(<span class="number">3</span>) ‘ +<span class="comment">' 是数学函数 .  就象其他数学函数那样 ,  停用了索引 .</span>
</code></pre><h3 id="使用索引">使用索引</h3><pre><code><span class="tag">a</span>. 如果检索数据量超过 <span class="number">30%</span> 的表中记录数 . 使用索引将没有显著的效率提高 . 
<span class="tag">b</span>. 在特定情况下, 使用索引也许会比全表扫描慢 ,  但这是同一个数量级上的区别 . 而通常情况下, 使用索引比全表扫描要块几倍乃至几千倍 ! 
</code></pre><h3 id="避免使用耗费资源的操作_:">避免使用耗费资源的操作 :</h3><pre><code>带有DISTINCT,UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span>,ORDER BY 的SQL 语句会启动 SQL引擎 
执行耗费资源的排序(<span class="keyword">SORT</span>)功能 . DISTINCT 需要一次排序操作,而其他的至少需要执行两次排序.通常,带有 UNION, <span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 的 SQL 语句都可以用其他方式重写.如果你的数据库的 SORT_AREA_SIZE调配得好,使用 UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 也是可以考虑的,毕竟它们的可读性很强 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>]]>
    
    </summary>
    
      <category term="［sql］" scheme="http://www.52ff.cc/tags/%EF%BC%BBsql%EF%BC%BD/"/>
    
      <category term="sql数据库" scheme="http://www.52ff.cc/categories/sql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>