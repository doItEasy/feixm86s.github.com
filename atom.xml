<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[FlyFish's Blog]]></title>
  <subtitle><![CDATA[才华配不上梦想就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-04-02T13:06:19.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[xiangming]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JVM-体系结构 内存模型]]></title>
    <link href="http://www.52ff.cc/2015/04/02/JVM-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.52ff.cc/2015/04/02/JVM-体系结构-内存模型/</id>
    <published>2015-04-02T13:01:39.000Z</published>
    <updated>2015-04-02T13:06:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一：Java技术体系模块图">一：Java技术体系模块图</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm1.jpg" alt=""><br><a id="more"></a></p>
<h2 id="二：JVM内存区域模型">二：JVM内存区域模型</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm2.jpg" alt=""></p>
<p>1.方法区<br>也称”永久代” 、“非堆”，  它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。<br>2.虚拟机栈<br>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。<br> 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。<br>3.本地方法栈<br> 与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。<br>4.堆<br>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。<br>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。<br>新生代：<br> 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。<br>老年代：<br>用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。<br>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm3.jpg" alt=""></p>
<p>5.程序计数器<br>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h2 id="三：直接内存">三：直接内存</h2><p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一：Java技术体系模块图">一：Java技术体系模块图</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm1.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://www.52ff.cc/tags/jvm/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty学习笔记-线程模型]]></title>
    <link href="http://www.52ff.cc/2015/03/30/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.52ff.cc/2015/03/30/Netty学习笔记-线程模型/</id>
    <published>2015-03-30T15:05:34.000Z</published>
    <updated>2015-03-30T15:39:36.000Z</updated>
    <content type="html"><![CDATA[<p>常见并发服务器方案比较:<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/20131104212306625.png" alt=""></p>
<p>具体可参照:<a href="http://blog.csdn.net/yusiguyuan/article/details/17591613" target="_blank" rel="external">常见多线程并发服务器编程模型</a></p>
<a id="more"></a>
<p>下面看下Netty的线程模型。Netty采用了Reactor模式，Reactor模式有多个变种，Netty基于Multiple Reactors模式（如下图）做了一定的修改，Mutilple Reactors模式有多个reactor：mainReactor和subReactor，其中mainReactor负责客户端的连接请求，并将请求转交给subReactor，后由subReactor负责相应通道的IO请求，非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理。</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>常见并发服务器方案比较:<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/20131104212306625.png" alt=""></p>
<p>具体可参照:<a href="http://blog.csdn.net/yusiguyuan/article/details/17591613">常见多线程并发服务器编程模型</a></p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty学习笔记–ByteBuf]]></title>
    <link href="http://www.52ff.cc/2015/03/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%93ByteBuf/"/>
    <id>http://www.52ff.cc/2015/03/24/Netty学习笔记–ByteBuf/</id>
    <published>2015-03-24T12:54:25.000Z</published>
    <updated>2015-03-29T14:01:03.000Z</updated>
    <content type="html"><![CDATA[<p>Netty的ByteBuf是Java NIO Buffer的优化，比JDK自带的缓冲区实现更优秀。</p>
<p>Netty缓冲API提供了几个优势:</p>
<ul>
<li>可以自定义缓冲类型 </li>
<li>通过一个内置的复合缓冲类型实现零拷贝 </li>
<li>扩展性好,比如StringBuffer </li>
<li>不需要调用flip()来切换读/写模式 </li>
<li>读取和写入索引分开</li>
<li>方法链 </li>
<li>引用计数 </li>
<li>Pooling(池)</li>
</ul>
<a id="more"></a>
<h2 id="读写索引">读写索引</h2><p>ByteBuf是一个很好的经过优化的字节数据容器,我们可以将字节数据有效的添加到ByteBuf中或从ByteBuf中获取数据。ByteBuf有2部分:一个用于读,一个用于写。ByteBuf提供两个指针变量支付读和写操作,读操作是使用readerIndex(),写操作时使用writerIndex()<br>写入数据到ByteBuf后,写入索引是增加的字节数量。开始读字节后,读取索引增加。你可以读取字节,直到写入索引和读取索引处理相同的位置,若再继续读取,则会抛出IndexOutOfBoundsException。调用ByteBuf的任何方法开始读/写都会单独维护读索引和写索引。ByteBuf的默认最大容量限制是Integer.MAX_VALUE,写入时若超出这个值将会导致一个异常。</p>
<p>对比上一篇讲到的关于java.nio.Buffer的知识。<br>个人的理解是：</p>
<pre><code>ByteBuf的读索引替代了java<span class="class">.nio</span><span class="class">.Buffer</span>的<span class="attribute">position</span>的作用
写索引替代了java<span class="class">.nio</span><span class="class">.Buffer</span>的limit的作用
</code></pre><p>这和JDK的ByteBuffer不同,ByteBuffer只有一个方法来设置索引,所以需要使用flip()方法来切换读和写模式。<br>ByteBuf一定符合:0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity。<br>注:flip()相当于buffer.limit(buffer.position( )).position(0); </p>
<h2 id="3种不同类型的ByteBuf">3种不同类型的ByteBuf</h2><ul>
<li>Heap Buffer(堆缓冲区)<br>  最常用的类型是ByteBuf将数据存储在JVM的堆空间,这是通过将数据存储在数组的实现。堆缓冲区可以快速分配,当不使用时也可<br>以快速释放。它还提供了直接访问数组的方法,通过ByteBuf.array()来获取byte[]数据。<br>访问非堆缓冲区ByteBuf的数组会导致UnsupportedOperationException,可以使用ByteBuf.hasArray()来检查是否支持访问数组。</li>
<li>Direct Buffer(直接缓冲区)<br>直接缓冲区,在堆之外直接分配内存。直接缓冲区不会占用堆空间容量,使用时应该考虑到应用程序要使用的最大内存容量以及如何限制它。直接缓冲区在使用Socket传递数据时性能很好,因为若使用间接缓冲区,JVM会先将数据复制到直接缓冲区再进行传递;但是直接缓冲区的缺点是在分配内存空间和释放内存时比堆缓冲区更复杂,而Netty使用内存池来解决这样的问题,这也是Netty使用内存池的原因之一。直接缓冲区不支持数组访问数据,但是我们可以间接的访问数据数组,如下面代码:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);￼<span class="keyword">if</span>(!directBuf.hasArray())&#123;    int len = directBuf.readableBytes();￼    byte[] arr = new byte[len];￼    directBuf.getBytes(<span class="number">0</span>, arr);&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问直接缓冲区的数据数组需要更多的编码和更复杂的操作,建议若需要在数组访问数据使用堆缓冲区会更好。</p>
<ul>
<li>Composite Buffer(复合缓冲区)<br>  复合缓冲区,我们可以创建多个不同的ByteBuf,然后提供一个这些ByteBuf组合的视图。复合缓冲区就像一个列表,我们可以动态 的添加和删除其中的ByteBuf,JDK的ByteBuffer没有这样的功能。Netty提供了CompositeByteBuf类来处理复合缓冲 区,CompositeByteBuf只是一个视图,CompositeByteBuf.hasArray()总是返回false,因为它可能包含一些直接或间接的不同类型的 ByteBuf。</li>
</ul>
<p>Unpooled也是用来创建缓冲区的工具类,Unpooled提供了很多方法,详细方法及使用可以看API文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//创建复合缓冲区CompositeByteBuf compBuf = Unpooled.compositeBuffer();￼//创建堆缓冲区￼ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);￼//创建直接缓冲区ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p>ByteBuf提供了一些较为丰富的实现类，逻辑上主要分为两种：HeapByteBuf和DirectByteBuf，实现机制则分为两种：PooledByteBuf和UnpooledByteBuf，除了这些之外，Netty还实现了一些衍生ByteBuf（DerivedByteBuf），如：ReadOnlyByteBuf、DuplicatedByteBuf以及SlicedByteBuf。</p>
<p>ByteBuf实现类的类图如下：</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty3.jpg" alt=""></p>
<h2 id="ByteBuf特殊机制">ByteBuf特殊机制</h2><ul>
<li><p>Reference Count<br>ByteBuf的生命周期管理引入了Reference Count的机制，感觉让我回到了CPP时代。可以通过简单的继承SimpleChannelInboundHandler实现自动释放reference count。SimpleChannelInboundHandler的事件方法如下，在消费完毕msg后，可以AutoRelease之：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    boolean release = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptInboundMessage(msg)) &#123;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            I imsg = (I) msg;</span><br><span class="line">            messageReceived(ctx, imsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            release = <span class="literal">false</span>;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (autoRelease &amp;&amp; release) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Zero Copy<br>Zero-copy与传统意义的zero-copy不太一样。传统的zero-copy是IO传输过程中，数据无需中内核态到用户态、用户态到内核态的数据拷贝，减少拷贝次数。而Netty的zero-copy则是完全在用户态，或者说传输层的zero-copy机制，可以参考下图。由于协议传输过程中，通常会有拆包、合并包的过程，一般的做法就是System.arrayCopy了，但是Netty通过ByteBuf.slice以及Unpooled.wrappedBuffer等方法拆分、合并Buffer无需拷贝数据。<br>如何实现zero-copy的呢。slice实现就是创建一个SlicedByteBuf对象，将this对象，以及相应的数据指针传入即可，wrappedBuffer实现机制类似。</p>
</li>
</ul>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty4.png" alt=""></p>
<h2 id="实用工具类">实用工具类</h2><ul>
<li><p>ByteBufHolder<br>ByteBufHolder是一个辅助类,是一个接口,其实现类是DefaultByteBufHolder,还有一些实现了ByteBufHolder接口的其他接口类。 ByteBufHolder的作用就是帮助更方便的访问ByteBuf中的数据,当缓冲区没用了后,可以使用这个辅助类释放资源。ByteBufHolder很简 单,提供的可供访问的方法也很少。如果你想实现一个“消息对象”有效负载存储在ByteBuf,使用ByteBufHolder是一个好主意。</p>
</li>
<li><p>ByteBufAllocator<br>Netty支持各种ByteBuf的池实现,来使Netty提供一种称为ByteBufAllocator成为可能。ByteBufAllocator负责分配ByteBuf实 例,ByteBufAllocator提供了各种分配不同ByteBuf的方法,如需要一个堆缓冲区可以使用ByteBufAllocator.heapBuffer(),需要一个直接 缓冲区可以使用ByteBufAllocator.directBuffer(),需要一个复合缓冲区可以使用ByteBufAllocator.compositeBuffer()。其他方法的使用可 以看ByteBufAllocator源码及注释。<br>获取ByteBufAllocator对象很容易,可以从Channel的alloc()获取,也可以从ChannelHandlerContext的alloc()获取。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">￼@Override￼public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;    ￼//get ByteBufAllocator instance by ChannelHandlerContext.alloc()</span><br><span class="line">    ByteBufAllocator alloc1 = ctx.alloc();</span><br><span class="line">    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ByteBufUtil<br>ByteBufUtil提供了一些静态的方法,在操作ByteBuf时非常有用。ByteBufUtil提供了Unpooled之外的一些方法,也许最有价值的是 hexDump(ByteBuf buffer)方法,这个方法返回指定ByteBuf中可读字节的十六进制字符串,可以用于调试程序时打印ByteBuf的内容,十 六进制字符串相比字节而言对用户更友好。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Netty的ByteBuf是Java NIO Buffer的优化，比JDK自带的缓冲区实现更优秀。</p>
<p>Netty缓冲API提供了几个优势:</p>
<ul>
<li>可以自定义缓冲类型 </li>
<li>通过一个内置的复合缓冲类型实现零拷贝 </li>
<li>扩展性好,比如StringBuffer </li>
<li>不需要调用flip()来切换读/写模式 </li>
<li>读取和写入索引分开</li>
<li>方法链 </li>
<li>引用计数 </li>
<li>Pooling(池)</li>
</ul>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.nio.Buffer研究笔记]]></title>
    <link href="http://www.52ff.cc/2015/03/23/java.nio.Buffer%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.52ff.cc/2015/03/23/java.nio.Buffer研究笔记/</id>
    <published>2015-03-23T06:22:26.000Z</published>
    <updated>2015-03-23T07:58:43.000Z</updated>
    <content type="html"><![CDATA[<p>每当你需要传输数据时,一个缓冲区是必要的。Java NIO API中缓冲区的类主要是Buffer。Buffer是一个包装了基本数据元素数组的对象，它以及它的子类定义了一系列API用于处理数据缓存。其中最重要的子类是ByteBuffer。</p>
<p>Netty的ByteBuf对jdk自带的缓冲区进行了重新设计和优化，Mina的IoBuffer对ByteBuffer进行了封装优化,它们比JDK自带的缓冲区实现更优秀。</p>
<p>本文用于记录java.nio.Buffer的概念结构，也是为了备忘。<br>最后的目的还是为了更好的学习理解Netty的ByteBuf。</p>
<a id="more"></a>
<h3 id="Buffer有四个基本属性：">Buffer有四个基本属性：</h3><p>1、capacity  容量，buffer能够容纳的最大元素数目，在Buffer创建时设定并不能更改<br>2、limit buffer中有效位置数目<br>3、position 下一个读或者写的位置<br>4、mark  用于记忆的标志位，配合reset()使用，初始值未设定，调用mark后设为当前position的值</p>
<p>四者关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<pre><code>写完后将<span class="built_in">limit</span>从capacity设为position
读的时候从position读到<span class="built_in">limit</span>
</code></pre><h3 id="BufferAPI">BufferAPI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package java.nio;</span><br><span class="line">public abstract class Buffer &#123;</span><br><span class="line">public final int capacity( )</span><br><span class="line">public final int position( )</span><br><span class="line">public final Buffer position (int newPosition)</span><br><span class="line">public final int <span class="built_in">limit</span>( )</span><br><span class="line">public final Buffer <span class="built_in">limit</span> (int newLimit)</span><br><span class="line">public final Buffer mark( )</span><br><span class="line">public final Buffer reset( )</span><br><span class="line">public final Buffer clear( )</span><br><span class="line">public final Buffer flip( )</span><br><span class="line">public final Buffer rewind( )</span><br><span class="line">public final int remaining( )</span><br><span class="line">public final boolean hasRemaining( )</span><br><span class="line">public abstract boolean isReadOnly( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持链式调用，如：buffer.mark().position(5).reset();</p>
<h3 id="操作说明">操作说明</h3><ul>
<li>get()从当前position位置读取</li>
<li>put(byte)put(byte)在当前position位置写入<br>get(index)和put(index,byte)不改变当前position属性</li>
<li>flip()将limit属性从capacity设置为当前position,将position设为0<br>相当于buffer.limit(buffer.position( )).position(0);<br>重要：<br>1.从写状态切换到读状态时需要使用flip()<br>2.两次调用buffer的flip方法，将使得position和limit属性都为0</li>
<li>clear()方法，将buffer重设为空状态，也就是设置limit=capacity,position=0，以便重复利用</li>
<li>mark(),初始是未定义的，这适合如果调用reset将抛出InvalidMarkException。调用makr()后，将当前position设为mark以便reset时返回。<br>注意，rewind(), clear(), and flip()方法都将丢弃已经创建的mark。</li>
<li>rewind()位置清零 position = 0;mark = -1; </li>
</ul>
<h3 id="创建Buffer">创建Buffer</h3><p>Buffer以及其子类都无法直接new，而必须把通过他们提供的工厂方法来创建。通常有两种方式：<br>1、allocate，例如<br>CharBuffer charBuffer = CharBuffer.allocate (100);<br>将在堆上分配一个可以存储100个字符的数组作为backing store。</p>
<p>2、wrap，包装一个已有的数组：<br>char [] myArray = new char [100];<br>CharBuffer charbuffer = CharBuffer.wrap (myArray);<br>注意,这样的方式创建的Buffer，将不会在堆上创建新的数组，而是直接利用myArray做backing store，这意味着任何对myArray或者buffer的修改都将影响到buffer或者myArray。可以通过public final boolean hasArray( )方法来判断是否拥有一个数组，通过array()方法取得这个数组。</p>
<h3 id="复制Buffer">复制Buffer</h3><p>   其实这个复制也是“浅拷贝”，通过duplicate()方法将返回一个新创建的buffer，这个新buffer与原来的Buffer共享数据，一样的capacity，但是有自己的position、limit和mark属性。通过asReadOnlyBuffer()方法复制的buffer与duplicate()类似，但是是只读的，不能调用put。比较特别的是slice()方法，故名思议，类似切割一个Buffer出来，与duplicate类似，但是它将从原来Buffer的当前position开始，并且capacity等于原来Buffer的剩余元素数目，也就是(limit-position)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>每当你需要传输数据时,一个缓冲区是必要的。Java NIO API中缓冲区的类主要是Buffer。Buffer是一个包装了基本数据元素数组的对象，它以及它的子类定义了一系列API用于处理数据缓存。其中最重要的子类是ByteBuffer。</p>
<p>Netty的ByteBuf对jdk自带的缓冲区进行了重新设计和优化，Mina的IoBuffer对ByteBuffer进行了封装优化,它们比JDK自带的缓冲区实现更优秀。</p>
<p>本文用于记录java.nio.Buffer的概念结构，也是为了备忘。<br>最后的目的还是为了更好的学习理解Netty的ByteBuf。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis的Master-Slave模式]]></title>
    <link href="http://www.52ff.cc/2015/03/22/Redis%E7%9A%84Master-Slave%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.52ff.cc/2015/03/22/Redis的Master-Slave模式/</id>
    <published>2015-03-22T13:51:48.000Z</published>
    <updated>2015-03-22T14:03:26.000Z</updated>
    <content type="html"><![CDATA[<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>
<a id="more"></a>
<p>一、Redis的Replication：</p>
<p>下面的列表清楚的解释了Redis Replication的特点和优势。<br>同一个Master可以同步多个Slaves。<br>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。因此我们可以将Redis的Replication架构视为图结构。<br>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。<br>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。<br>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成。即便如此，系统的伸缩性还是得到了很大的提高。<br>Master可以将数据保存操作交给Slaves完成，从而避免了在Master中要有独立的进程来完成此操作。</p>
<p>二、Replication的工作原理：</p>
<p>在Slave启动并连接到Master之后，它将主动发送一个SYNC命令。此后Master将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master将传送整个数据库文件到Slave，以完成一次完全同步。而Slave服务器在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master继续将所有已经收集到的修改命令，和新的修改命令依次传送给Slaves，Slave将在本次执行这些数据修改命令，从而达到最终的数据同步。<br>如果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。</p>
<p>三、如何配置Replication：</p>
<p>见如下步骤：<br>1). 同时启动两个Redis服务器，可以考虑在同一台机器上启动两个Redis服务器，分别监听不同的端口，如6379和6380。<br>2). 在Slave服务器上执行一下命令：<br>/&gt; redis-cli -p 6380   #这里我们假设Slave的端口号是6380<br>redis 127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 #我们假设Master和Slave在同一台主机，Master的端口为6379<br>OK<br>上面的方式只是保证了在执行slaveof命令之后，redis_6380成为了redis_6379的slave，一旦服务(redis_6380)重新启动之后，他们之间的复制关系将终止。<br>如果希望长期保证这两个服务器之间的Replication关系，可以在redis_6380的配置文件中做如下修改：<br>/&gt; cd /etc/redis  #切换Redis服务器配置文件所在的目录。<br>/&gt; ls<br>6379.conf  6380.conf<br>/&gt; vi 6380.conf<br>将</p>
<h1 id="slaveof">slaveof <masterip> <masterport></masterport></masterip></h1><p>改为<br>slaveof 127.0.0.1 6379<br>保存退出。<br>这样就可以保证Redis_6380服务程序在每次启动后都会主动建立与Redis_6379的Replication连接了。</p>
<p>四、应用示例：</p>
<p>这里我们假设Master-Slave已经建立。</p>
<h1 id="启动master服务器。">启动master服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6379</span>
redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;
</code></pre><h1 id="情况Master当前数据库中的所有Keys。">情况Master当前数据库中的所有Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; flushdb
OK
</code></pre><h1 id="在Master中创建新的Keys作为测试数据。">在Master中创建新的Keys作为测试数据。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; set mykey hello
OK
redis <span class="number">127.0.0.1:6379</span>&gt; set mykey2 world
OK
</code></pre><h1 id="查看Master中存在哪些Keys。">查看Master中存在哪些Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="启动slave服务器。">启动slave服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6380</span>
</code></pre><h1 id="查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。">查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="在Master中删除其中一个测试Key，并查看删除后的结果。">在Master中删除其中一个测试Key，并查看删除后的结果。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; del mykey2
(integer) <span class="number">1</span>
redis <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre><h1 id="在Slave中查看是否mykey2也已经在Slave中被删除。">在Slave中查看是否mykey2也已经在Slave中被删除。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-03-24T05:06:32.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄,目的是测试下七牛云图床的速度</p>
<a id="more"></a>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ffpsb.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff2.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff3.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff1.jpeg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄,目的是测试下七牛云图床的速度</p>]]>
    
    </summary>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为性能注意的地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-17T16:13:27.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-19T04:46:23.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br></pre></td></tr></table></figure>
<p>1.图片设置成撑满整个div，使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!important &gt; [ id &gt; class &gt; tag ]</span><br></pre></td></tr></table></figure></p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简易的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-26T09:37:19.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-20T03:35:36.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>
<a id="more"></a>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<p>[CentOS 6.2下fastDFS的完整安装和配置步骤]<br>(<a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a>)</p>
<p>[FastDFS在Ubuntu下的安装，PHP客户端]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a>)</p>
<p>[FastDFS分布式文件服务器安装，及配置，测试]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a>)</p>
<p>[FastDFS 整合Nginx问题整理]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a>)</p>
<p>[CentOS下搭建FastDFS]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a>)</p>
<p>[Ubuntu安装FastDFS全程记录]<br>(<a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a>)</p>
<p>同事小伍哥对于FastDFS性能的测试结果如下:</p>
<p>场景1：FastDFS+自带HttpServer<br>FastDFS内置了一个Http服务器，可以提供文件下载服务,使用100个线程，下载一个60M的文件，内存消耗6G左右，估计是把文件都放内存里面去了,线程数增加到500，内存占用提高到12G，剩余空闲内存几乎没有，几分钟后，服务器彻底失去响应，只有进行硬件重启.<br>FastDFS开发者表示，老早就不推荐使用内置的Http服务了</p>
<p>场景2：FastDFS+Nginx<br>编译FastDFS的Nginx支持模块，使用Nginx进行文件下载,使用1000个线程并发，下载60M大小的文件，Nginx服务器内存占用20M左右，完全没有压力</p>
<p>场景3：FastDFS+TCPClient<br>FastDFS支持TCP协议，使用其自带的客户端进行下载,使用1000个线程并发，下载60M大小的文件，FastDFS storage内存占用在120M左右，虽然表现没有Nginx那么优秀，但是性能上也足以满足需求了需要注意的是，FastDFS自带的客户端下载文件，内存占用和磁盘IO没有做较好的优化，大并发下载大文件时，会有性能问题</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-03-19T17:05:26.000Z</updated>
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><pre><code><span class="built_in">save</span>：将数据同步保存到磁盘
bgsave：将数据异步保存到磁盘
lastsave：返回上次成功将数据保存到磁盘的Unix时戳
shundown：将数据同步保存到磁盘，然后关闭服务
</code></pre><h3 id="远程服务控制">远程服务控制</h3><pre><code><span class="keyword">info</span>：提供服务器的信息和统计
monitor：实时转储收到的请求
slaveof：改变复制策略设置
config：在运行时配置Redis服务器
</code></pre><h3 id="对value操作的命令">对value操作的命令</h3><pre><code><span class="function"><span class="title">exists</span><span class="params">(key)</span></span>：确认一个key是否存在
<span class="function"><span class="title">del</span><span class="params">(key)</span></span>：删除一个key
<span class="function"><span class="title">type</span><span class="params">(key)</span></span>：返回值的类型
<span class="function"><span class="title">keys</span><span class="params">(pattern)</span></span>：返回满足给定pattern的所有key
randomkey：随机返回key空间的一个
<span class="function"><span class="title">keyrename</span><span class="params">(old name, newname)</span></span>：重命名key
dbsize：返回当前数据库中key的数目
expire：设定一个key的活动时间（s）
ttl：获得一个key的活动时间
<span class="function"><span class="title">select</span><span class="params">(index)</span></span>：按索引查询
<span class="function"><span class="title">move</span><span class="params">(key, dbindex)</span></span>：移动当前数据库中的key到dbindex数据库
flushdb：删除当前选择数据库中的所有key
flushall：删除所有数据库中的所有key
</code></pre><h3 id="对String操作的命令">对String操作的命令</h3><pre><code><span class="operator"><span class="keyword">set</span>(<span class="keyword">key</span>, <span class="keyword">value</span>)：给数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予值<span class="keyword">value</span>
<span class="keyword">get</span>(<span class="keyword">key</span>)：返回数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>
getset(<span class="keyword">key</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予上一次的<span class="keyword">value</span>
mget(key1, key2,…, <span class="keyword">key</span> N)：返回库中多个<span class="keyword">string</span>的<span class="keyword">value</span>
setnx(<span class="keyword">key</span>, <span class="keyword">value</span>)：添加<span class="keyword">string</span>，名称为<span class="keyword">key</span>，值为<span class="keyword">value</span>
setex(<span class="keyword">key</span>, <span class="keyword">time</span>, <span class="keyword">value</span>)：向库中添加<span class="keyword">string</span>，设定过期时间<span class="keyword">time</span>
mset(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：批量设置多个<span class="keyword">string</span>的值
msetnx(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：如果所有名称为<span class="keyword">key</span> i的<span class="keyword">string</span>都不存在
incr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增<span class="number">1</span>操作
incrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增加<span class="built_in">integer</span>
decr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减<span class="number">1</span>操作
decrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减少<span class="built_in">integer</span>
append(<span class="keyword">key</span>, <span class="keyword">value</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>的值附加<span class="keyword">value</span>
<span class="keyword">substr</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>的子串</span>
</code></pre><h3 id="对List操作的命令">对List操作的命令</h3><pre><code>rpush(key, value)：在名称为key的<span class="keyword">list</span>尾添加一个值为value的元素
lpush(key, value)：在名称为key的<span class="keyword">list</span>头添加一个值为value的 元素
llen(key)：返回名称为key的<span class="keyword">list</span>的长度
<span class="keyword">lrange</span>(key, start, end)：返回名称为key的<span class="keyword">list</span>中start至end之间的元素
ltrim(key, start, end)：截取名称为key的<span class="keyword">list</span>
<span class="keyword">lindex</span>(key, index)：返回名称为key的<span class="keyword">list</span>中index位置的元素
<span class="keyword">lset</span>(key, index, value)：给名称为key的<span class="keyword">list</span>中index位置的元素赋值
lrem(key, count, value)：删除count个key的<span class="keyword">list</span>中值为value的元素
lpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的首元素
rpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的尾元素
blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
brpop(key1, key2,… key N, timeout)：rpop的block版本。
rpoplpush(srckey, dstkey)：返回并删除名称为srckey的<span class="keyword">list</span>的尾元素，并将该元素添加到名称为dstkey的<span class="keyword">list</span>的头部
</code></pre><h3 id="对Set操作的命令">对Set操作的命令</h3><pre><code><span class="function"><span class="title">sadd</span><span class="params">(key, member)</span></span>：向名称为key的set中添加元素member
<span class="function"><span class="title">srem</span><span class="params">(key, member)</span></span> ：删除名称为key的set中的元素member
<span class="function"><span class="title">spop</span><span class="params">(key)</span></span> ：随机返回并删除名称为key的set中一个元素
<span class="function"><span class="title">smove</span><span class="params">(srckey, dstkey, member)</span></span> ：移到集合元素
<span class="function"><span class="title">scard</span><span class="params">(key)</span></span> ：返回名称为key的set的基数
<span class="function"><span class="title">sismember</span><span class="params">(key, member)</span></span> ：member是否是名称为key的set的元素
<span class="function"><span class="title">sinter</span><span class="params">(key1, key2,…key N)</span></span> ：求交集
<span class="function"><span class="title">sinterstore</span><span class="params">(dstkey, (keys)</span></span>) ：求交集并将交集保存到dstkey的集合
<span class="function"><span class="title">sunion</span><span class="params">(key1, (keys)</span></span>) ：求并集
<span class="function"><span class="title">sunionstore</span><span class="params">(dstkey, (keys)</span></span>) ：求并集并将并集保存到dstkey的集合
<span class="function"><span class="title">sdiff</span><span class="params">(key1, (keys)</span></span>) ：求差集
<span class="function"><span class="title">sdiffstore</span><span class="params">(dstkey, (keys)</span></span>) ：求差集并将差集保存到dstkey的集合
<span class="function"><span class="title">smembers</span><span class="params">(key)</span></span> ：返回名称为key的set的所有元素
<span class="function"><span class="title">srandmember</span><span class="params">(key)</span></span> ：随机返回名称为key的set的一个元素
</code></pre><h3 id="对Hash操作的命令">对Hash操作的命令</h3><pre><code><span class="function"><span class="title">hset</span><span class="params">(key, field, value)</span></span>：向名称为key的hash中添加元素field
<span class="function"><span class="title">hget</span><span class="params">(key, field)</span></span>：返回名称为key的hash中field对应的value
<span class="function"><span class="title">hmget</span><span class="params">(key, (fields)</span></span>)：返回名称为key的hash中field i对应的value
<span class="function"><span class="title">hmset</span><span class="params">(key, (fields)</span></span>)：向名称为key的hash中添加元素field 
<span class="function"><span class="title">hincrby</span><span class="params">(key, field, integer)</span></span>：将名称为key的hash中field的value增加integer
<span class="function"><span class="title">hexists</span><span class="params">(key, field)</span></span>：名称为key的hash中是否存在键为field的域
<span class="function"><span class="title">hdel</span><span class="params">(key, field)</span></span>：删除名称为key的hash中键为field的域
<span class="function"><span class="title">hlen</span><span class="params">(key)</span></span>：返回名称为key的hash中元素个数
<span class="function"><span class="title">hkeys</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键
<span class="function"><span class="title">hvals</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键对应的value
<span class="function"><span class="title">hgetall</span><span class="params">(key)</span></span>：返回名称为key的hash中所有的键（field）及其对应的value
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优秀技术博文分享]]></title>
    <link href="http://www.52ff.cc/2015/03/10/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/"/>
    <id>http://www.52ff.cc/2015/03/10/优秀技术博文分享/</id>
    <published>2015-03-10T02:58:18.000Z</published>
    <updated>2015-03-23T01:37:03.000Z</updated>
    <content type="html"><![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>
<a id="more"></a>
<h3 id="Nginx+tomcat配置集群负载均衡">Nginx+tomcat配置集群负载均衡</h3><p><a href="http://ari.iteye.com/blog/833153" title="Nginx+tomcat配置集群负载均衡" target="_blank" rel="external">图文解说：Nginx+tomcat配置集群负载均衡</a> </p>
<h3 id="netty学习">netty学习</h3><p><a href="http://ifeve.com/netty-2-6/" target="_blank" rel="external">并发编程网netty教程</a></p>
<h3 id="hexo搭建博客">hexo搭建博客</h3><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo搭建博客全程指导</a></p>
<h3 id="Dubbo指南">Dubbo指南</h3><p><a href="http://alibaba.github.io/dubbo-doc-static/Home-zh.htm" target="_blank" rel="external">Dubo指南</a></p>
<h3 id="优秀个人csdn博客">优秀个人csdn博客</h3><p><a href="http://blog.csdn.net/yusiguyuan/" target="_blank" rel="external">鱼思故渊的专栏</a></p>
<p>随时更新</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>]]>
    
    </summary>
    
      <category term="记录分享" scheme="http://www.52ff.cc/categories/%E8%AE%B0%E5%BD%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty几个核心类的概念和用法]]></title>
    <link href="http://www.52ff.cc/2015/03/05/netty%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/03/05/netty笔记第一篇/</id>
    <published>2015-03-05T13:37:48.000Z</published>
    <updated>2015-03-24T07:50:42.000Z</updated>
    <content type="html"><![CDATA[<p>本篇文章整理下Netty的10个核心类，列举这些类的概念以及他们的用法，以便更加熟悉的netty的结构，帮助自己和他人学习netty,日后新的理解也会不时补充进来。</p>
<a id="more"></a>
<h2 id="Bootstrap_or_ServerBootstrap">Bootstrap or ServerBootstrap</h2><p>  一个Netty程序开始于Bootstrap类,Bootstrap类是Netty提供的一个可以通过简单配置来设置或”引导”程序的一个很重要的类。当你需要连接客户端或服务器绑定指定端口时需要使用bootstrap.</p>
<ul>
<li>Bootstrap用来连接远程主机,有1个EventLoopGroup</li>
<li>ServerBootstrap用来绑定本地端口,有2个EventLoopGroup<br>一个EventLoopGroup负责接受新连接，一个EventLoopGroup负责已接收到连接</li>
</ul>
<h2 id="EventLoop">EventLoop</h2><p>EventLoop 是一个Channel执行实际工作的线程。当一个Channel注册后,Netty将这个Channel绑定到一个EventLoop,在Channel的生命周期内总是被绑定到一个EventLoop。<br>处理IO的工作由EventLoop管理</p>
<h2 id="EventLoopGroup">EventLoopGroup</h2><p>EventLoopGroup包含一个或多个EventLoop，可以理解为EventLoop是一个事件循环线程,而EventLoopGroup是一个事件循环集合</p>
<h2 id="ChannelPipeline">ChannelPipeline</h2><p>所有的Netty程序都是基于ChannelPipeline,ChannelPipeline上面用于添加ChannelHandler。<br>ChannelHandler会在程序的“引导”阶段被添加 ChannelPipeline中,并且被添加的顺序将决定处理数据的顺序。ChannelPipeline的作用我们可以理解为用来管理ChannelHandler的一个容器。<br>也可以理解为一个链状的列表。</p>
<p>例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(new MyServerHandler());</span><br></pre></td></tr></table></figure></p>
<h2 id="Channel">Channel</h2><p>Channel概念与java.nio.channel概念一致，用以连接IO设备（socket、文件等）的纽带，是数据传输的通道，传输API的核心是Channel接口,每个Channel都会分配一个ChannelPipeline和ChannelConfig。<br>对于每个新的通道,会创建一个新的ChannelPipeline并附加至通道。一旦连接,Channel和ChannelPipeline之间的耦合是永久性 的。Channel不能附加其他的ChannelPipeline或从ChannelPipeline分离。</p>
<h2 id="Future_or_ChannelFuture">Future or ChannelFuture</h2><h2 id="ChannelInitializer">ChannelInitializer</h2><p>ChannelInitializer类用来配置Handlers，通过ChannelPipeline来添加ChannelHandler的，ChannelInitializer自身也是一个ChannelHandler,在添加完其他的handlers之后会自动从ChannelPipeline中删除自己</p>
<h2 id="ChannelHandler">ChannelHandler</h2><p>Netty的ChannelHandler是你的应用程序中处理最多的，我们 可以理解为ChannelHandler是一段执行业务逻辑处理数据的代码,它们来来往往的通过ChannelPipeline。实际上,ChannelHandler是定义一个handler 的父接口，ChannelInboundHandler和ChannelOutboundHandler都实现ChannelHandler接口</p>
<ul>
<li>ChannelInboundHandler<br>入站的消息从ChannelPipeline的头部开始经过所有的ChannelInboundHandler处理</li>
<li>ChannelOutboundHandler<br>出站的消息从ChannelPipeline的尾部开始经过ChannelOutboundHandler处理</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章整理下Netty的10个核心类，列举这些类的概念以及他们的用法，以便更加熟悉的netty的结构，帮助自己和他人学习netty,日后新的理解也会不时补充进来。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第十篇(阻塞队列和栈)]]></title>
    <link href="http://www.52ff.cc/2015/03/05/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%8D%81%E7%AF%87-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <id>http://www.52ff.cc/2015/03/05/JAVA多线程第十篇-阻塞队列和栈/</id>
    <published>2015-03-05T12:53:09.000Z</published>
    <updated>2015-03-23T06:29:54.000Z</updated>
    <content type="html"><![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>
<a id="more"></a>
<p>下面使用ArrayBlockQueue来实现之前实现过的生产者消/费者模式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/** 定义一个盘子类，可以放鸡蛋和取鸡蛋 */  </span><br><span class="line">public class BigPlate &#123;  </span><br><span class="line">  </span><br><span class="line">    /** 装鸡蛋的盘子，大小为<span class="number">5</span> */  </span><br><span class="line">    private BlockingQueue&lt;Object&gt; eggs = new ArrayBlockingQueue&lt;Object&gt;(<span class="number">5</span>);  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋 */  </span><br><span class="line">    public void putEgg(Object egg) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            eggs.put(egg);// 向盘子末尾放一个鸡蛋，如果盘子满了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与put操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"放入鸡蛋"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 取鸡蛋 */  </span><br><span class="line">    public Object <span class="function"><span class="title">getEgg</span></span>() &#123;  </span><br><span class="line">        Object egg = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            egg = eggs.take();// 从盘子开始取一个鸡蛋，如果盘子空了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与take操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"拿到鸡蛋"</span>);  </span><br><span class="line">        <span class="built_in">return</span> egg;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋线程 */  </span><br><span class="line">    static class AddThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">        private Object egg = new Object();  </span><br><span class="line">  </span><br><span class="line">        public AddThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.putEgg(egg);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** 取鸡蛋线程 */  </span><br><span class="line">    static class GetThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">  </span><br><span class="line">        public GetThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.getEgg();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        BigPlate plate = new BigPlate();  </span><br><span class="line">        // 先启动<span class="number">10</span>个放鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new AddThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 再启动<span class="number">10</span>个取鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new GetThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
</code></pre><p>从结果看，启动10个放鸡蛋线程和10个取鸡蛋线程，前5个放入鸡蛋的线程成功执行，到第6个，发现盘子满了，阻塞住，这时切换到取鸡蛋线程执行，成功实现了生产者/消费者模式。</p>
<p>对于阻塞栈，与阻塞队列相似。不同点在于栈是“后入先出”的结构，每次操作的是栈顶，而队列是“先进先出”的结构，每次操作的是队列头。<br>下面是一个简单例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) throws InterruptedException &#123; </span><br><span class="line">                BlockingDeque bDeque = new LinkedBlockingDeque(<span class="number">20</span>); </span><br><span class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123; </span><br><span class="line">                        //将指定元素添加到此阻塞栈中，如果没有可用空间，将一直等待（如果有必要）。 </span><br><span class="line">                        bDeque.putFirst(i); </span><br><span class="line">                        System.out.println(<span class="string">"向阻塞栈中添加了元素:"</span> + i); </span><br><span class="line">                &#125; </span><br><span class="line">                System.out.println(<span class="string">"程序到此运行结束，即将退出----"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第九篇(条件变量Condition)]]></title>
    <link href="http://www.52ff.cc/2015/03/04/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AF%87-Condition/"/>
    <id>http://www.52ff.cc/2015/03/04/JAVA多线程第九篇-Condition/</id>
    <published>2015-03-04T12:30:27.000Z</published>
    <updated>2015-03-23T06:29:26.000Z</updated>
    <content type="html"><![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>
<a id="more"></a>
<p>条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。 </p>
<p>而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。当调用signalAll()方法，又可以唤醒该条件下的等待的线程。有关Condition接口的API可以具体参考JavaAPI文档。</p>
<p>条件变量比较抽象，原因是他不是自然语言中的条件概念，而是程序控制的一种手段。</p>
<p>下面以一个银行存取款的模拟程序为例来揭盖Java多线程条件变量的神秘面纱：</p>
<p>有一个账户，多个用户（线程）在同时操作这个账户，有的存款有的取款，存款随便存，取款有限制，不能透支，任何试图透支的操作都将等待里面有足够存款才执行操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                Thread t1 = new SaveThread(<span class="string">"张三"</span>, myCount, <span class="number">2000</span>); </span><br><span class="line">                Thread t2 = new SaveThread(<span class="string">"李四"</span>, myCount, <span class="number">3600</span>); </span><br><span class="line">                Thread t3 = new DrawThread(<span class="string">"王五"</span>, myCount, <span class="number">2700</span>); </span><br><span class="line">                Thread t4 = new SaveThread(<span class="string">"老张"</span>, myCount, <span class="number">600</span>); </span><br><span class="line">                Thread t5 = new DrawThread(<span class="string">"老牛"</span>, myCount, <span class="number">1300</span>); </span><br><span class="line">                Thread t6 = new DrawThread(<span class="string">"胖子"</span>, myCount, <span class="number">800</span>); </span><br><span class="line">                //执行各个线程 </span><br><span class="line">                pool.execute(t1); </span><br><span class="line">                pool.execute(t2); </span><br><span class="line">                pool.execute(t3); </span><br><span class="line">                pool.execute(t4); </span><br><span class="line">                pool.execute(t5); </span><br><span class="line">                pool.execute(t6); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 存款线程类 </span><br><span class="line">*/ </span><br><span class="line">class SaveThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        SaveThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.saving(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 取款线程类 </span><br><span class="line">*/ </span><br><span class="line">class DrawThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        DrawThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.drawing(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 普通银行账户，不可透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;                         //账号 </span><br><span class="line">        private int cash;                             //账户余额 </span><br><span class="line">        private Lock lock = new ReentrantLock();                //账户锁 </span><br><span class="line">        private Condition _save = lock.newCondition();    //存款条件 </span><br><span class="line">        private Condition _draw = lock.newCondition();    //取款条件 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 存款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void saving(int x, String name) &#123; </span><br><span class="line">                lock.lock();                        //获取锁 </span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        cash += x;                    //存款 </span><br><span class="line">                        System.out.println(name + <span class="string">"存款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                &#125; </span><br><span class="line">                _draw.signalAll();            //唤醒所有等待线程。 </span><br><span class="line">                lock.unlock();                    //释放锁 </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 取款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void drawing(int x, String name) &#123; </span><br><span class="line">                lock.lock();                                 //获取锁 </span><br><span class="line">                try &#123; </span><br><span class="line">                        <span class="keyword">if</span> (cash - x &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                                _draw.await();             //阻塞取款操作 </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                                cash -= x;                     //取款 </span><br><span class="line">                                System.out.println(name + <span class="string">"取款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                        &#125; </span><br><span class="line">                        _save.signalAll();             //唤醒所有存款操作 </span><br><span class="line">                &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                        e.printStackTrace(); </span><br><span class="line">                &#125; finally &#123; </span><br><span class="line">                        lock.unlock();                     //释放锁 </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>李四存款3600，当前余额为13600
张三存款2000，当前余额为15600
老张存款600，当前余额为16200
老牛取款1300，当前余额为14900
胖子取款800，当前余额为14100
王五取款2700，当前余额为11400
</code></pre><p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。<br>        这样看来，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition，下面引入API中的一段代码，加以说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;  </span><br><span class="line">   final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">   final Condition notFull  = lock.newCondition();//写线程条件   </span><br><span class="line">   final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line">  </span><br><span class="line">   final Object[] items = new Object[<span class="number">100</span>];//缓存队列  </span><br><span class="line">   int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;  </span><br><span class="line">  </span><br><span class="line">   public void put(Object x) throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == items.length)//如果队列满了   </span><br><span class="line">         notFull.await();//阻塞写线程  </span><br><span class="line">       items[putptr] = x;//赋值   </span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;//如果写索引写到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       ++count;//个数++  </span><br><span class="line">       notEmpty.signal();//唤醒读线程  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   public Object take() throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)//如果队列为空  </span><br><span class="line">         notEmpty.await();//阻塞读线程  </span><br><span class="line">       Object x = items[takeptr];//取值   </span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;//如果读索引读到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       --count;//个数--  </span><br><span class="line">       notFull.signal();//唤醒写线程  </span><br><span class="line">       <span class="built_in">return</span> x;  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，下面分析一下代码的执行过程：</p>
<pre><code><span class="bullet">1. </span>一个写线程执行，调用put方法；
<span class="bullet">2. </span>判断count是否为100，显然没有100；
<span class="bullet">3. </span>继续执行，存入值；
<span class="bullet">4. </span>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；
<span class="bullet">5. </span>仅唤醒读线程阻塞队列中的一个；
<span class="bullet">6. </span>一个读线程执行，调用take方法；
<span class="bullet">7. </span>……
<span class="bullet">8. </span>仅唤醒写线程阻塞队列中的一个。
这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第八篇(锁对象Lock)]]></title>
    <link href="http://www.52ff.cc/2015/03/03/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87-%E9%94%81%E5%AF%B9%E8%B1%A1Lock/"/>
    <id>http://www.52ff.cc/2015/03/03/JAVA多线程第八篇-锁对象Lock/</id>
    <published>2015-03-03T13:45:28.000Z</published>
    <updated>2015-03-23T06:29:03.000Z</updated>
    <content type="html"><![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre><a id="more"></a>
<p>下面看个例子帮助我们理解锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                Lock lock = new ReentrantLock(); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newCachedThreadPool(); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private Lock myLock;                //执行操作所需的锁对象 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, Lock myLock) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //获取锁 </span><br><span class="line">                myLock.lock(); </span><br><span class="line">                //执行现金业务 </span><br><span class="line">                System.out.println(name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                System.out.println(name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                //释放锁，否则别的线程没有机会执行了 </span><br><span class="line">                myLock.unlock(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为<span class="number">6000</span>，当前金额为<span class="number">6000</span> 
张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">12000</span> 
张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">12000</span> 
张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为<span class="number">4000</span> 
张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户，金额为<span class="number">800</span>，当前金额为<span class="number">4000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">800</span>，当前金额为<span class="number">4800</span> 
</code></pre><p>从上面的输出可以看到，利用锁对象太方便了，比直接在某个不知情的对象上用锁清晰多了。<br>但一定要注意的是，在获取了锁对象后，用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行。</p>
<p>上面提到的Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。</p>
<p>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                ReadWriteLock lock = new ReentrantReadWriteLock(<span class="literal">false</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u5 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">0</span>, lock, <span class="literal">true</span>); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                pool.execute(u5); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private ReadWriteLock myLock;                //执行操作所需的锁对象 </span><br><span class="line">        private boolean ischeck;        //是否查询 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, ReadWriteLock myLock, boolean ischeck) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">                this.ischeck = ischeck; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                <span class="keyword">if</span> (ischeck) &#123; </span><br><span class="line">                        //获取读锁 </span><br><span class="line">                        myLock.readLock().lock(); </span><br><span class="line">                        System.out.println(<span class="string">"读："</span> + name + <span class="string">"正在查询"</span> + myCount + <span class="string">"账户，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放读锁 </span><br><span class="line">                        myLock.readLock().unlock(); </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        //获取写锁 </span><br><span class="line">                        myLock.writeLock().lock(); </span><br><span class="line">                        //执行现金业务 </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放写锁 </span><br><span class="line">                        myLock.writeLock().unlock(); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡账户，可随意透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为-<span class="number">2000</span> 
写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户，金额为<span class="number">800</span>，当前金额为-<span class="number">2000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户成功，金额为<span class="number">800</span>，当前金额为-<span class="number">1200</span> 
读：张三他爹正在查询MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，当前金额为-<span class="number">1200</span> 
写：张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，金额为<span class="number">6000</span>，当前金额为-<span class="number">1200</span> 
写：张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">4800</span>
</code></pre><p>在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring动态数据源和事务配置详解]]></title>
    <link href="http://www.52ff.cc/2015/02/28/spring%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.52ff.cc/2015/02/28/spring动态数据源和事务配置详解/</id>
    <published>2015-02-28T12:53:21.000Z</published>
    <updated>2015-03-26T08:24:29.000Z</updated>
    <content type="html"><![CDATA[<p>最近在工作中碰到了保存数据时需要跨IDC写多个数据库的需求，记得多年前的做法是在java代码里面lookup需要的数据源,但是这样的做法明显耦合度太高了。现在我们大多java项目已经离不开spring了,spring也提供各种强大的功能，所以就特地看了下spring对于动态数据源的配置，顺便将spring对于事务配置的两种常见的方式也整理一下。</p>
<p>动态数据源具体实现的思路就是采用Proxy模式，弄一个虚拟的数据源，并且用它来封装数据源选择逻辑，由虚拟的数据源根据Client提供的上下文来实现数据源的选择。</p>
<a id="more"></a>
<h2 id="动态数据源dynamicDataSource配置">动态数据源dynamicDataSource配置</h2><p>具体的实现请在org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource</p>
<p>下面具体演示下：<br>重写determineCurrentLookupKey方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDataSource extends AbstractRoutingDataSource &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object <span class="function"><span class="title">determineCurrentLookupKey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> DataSourceContextHolder.getDataSourceType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前线程里取出对应的数据源名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceContextHolder&#123;</span><br><span class="line"></span><br><span class="line">    public static final String ONE=<span class="string">"one"</span>;</span><br><span class="line">    public static final String TWO = <span class="string">"two"</span>;</span><br><span class="line">    private static final ThreadLocal contextHolder =</span><br><span class="line">            new ThreadLocal();</span><br><span class="line"></span><br><span class="line">    public static void <span class="built_in">set</span>DataSourceType(String dataSourceType) &#123;</span><br><span class="line">        contextHolder.set(dataSourceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String <span class="function"><span class="title">getDataSourceType</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (String) contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void <span class="function"><span class="title">clearDataSourceType</span></span>() &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置下xml文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 数据源定义,使用Apache DBCP 连接池 --&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"dataSource0"</span> class=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> destroy-method=<span class="string">"close"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"maxIdle"</span> value=<span class="string">"60"</span> /&gt;</span><br><span class="line">		&lt;property name=<span class="string">"maxActive"</span> value=<span class="string">"60"</span> /&gt;</span><br><span class="line">		&lt;property name=<span class="string">"timeBetweenEvictionRunsMillis"</span> value=<span class="string">"3600000"</span> /&gt;</span><br><span class="line">		&lt;property name=<span class="string">"minEvictableIdleTimeMillis"</span> value=<span class="string">"3600000"</span> /&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=<span class="string">"dataSource1"</span> parent=<span class="string">"dataSource0"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"url"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"username"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password&#125;</span>"</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"dataSource2"</span> parent=<span class="string">"dataSource0"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.driver2&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"url"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.url2&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"username"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.username2&#125;</span>"</span>/&gt;</span><br><span class="line">		&lt;property name=<span class="string">"password"</span> value=<span class="string">"<span class="variable">$&#123;jdbc.password2&#125;</span>"</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id=<span class="string">"dynamicDataSource"</span> class=<span class="string">"com.skymobi.webframework.utils.DynamicDataSource"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"targetDataSources"</span>&gt;</span><br><span class="line">			&lt;map key-type=<span class="string">"java.lang.String"</span>&gt;</span><br><span class="line">				&lt;entry key=<span class="string">"two"</span> value-ref=<span class="string">"dataSource2"</span>/&gt;</span><br><span class="line">			&lt;/map&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">		&lt;property name=<span class="string">"defaultTargetDataSource"</span> ref=<span class="string">"dataSource1"</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;bean id=<span class="string">"sessionFactory"</span> class=<span class="string">"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dynamicDataSource"</span> /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 事务管理器配置 --&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">"sessionFactory"</span> ref=<span class="string">"sessionFactory"</span> /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 使用annotation定义事务 --&gt;</span><br><span class="line">	&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span> proxy-target-class=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>最后在代码中使用DataSourceContextHolder.setDataSourceType(DataSourceContextHolder.ONE)就可以切换数据源了</p>
<p>注意：切换数据源必须在一个事务结束后切换，在一个事务内是无法切换数据源的<br>所以建议切换数据源的代码要写在service层而非dao层</p>
<h2 id="事务管理器配置的两种方式">事务管理器配置的两种方式</h2><p>上面动态数据源也涉及到了事务，顺便回顾下spring事务管理的两种最常见配置</p>
<ul>
<li>现在最常用的annotation方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"myBatisTransaction"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用annotation定义事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"myBatisTransaction"</span> proxy-target-class=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要在方法前加上@Transactional</p>
<ul>
<li>aop配置切面<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"myBatisTransaction"</span>&gt;</span><br><span class="line">		&lt;tx:attributes&gt;</span><br><span class="line">			&lt;tx:method name=<span class="string">"*"</span> propagation=<span class="string">"REQUIRED"</span> rollback-for=<span class="string">"java.lang.RuntimeException"</span> /&gt;</span><br><span class="line">			&lt;tx:method name=<span class="string">"get*"</span> <span class="built_in">read</span>-only=<span class="string">"true"</span> /&gt;</span><br><span class="line">			&lt;tx:method name=<span class="string">"query*"</span> <span class="built_in">read</span>-only=<span class="string">"true"</span> /&gt;</span><br><span class="line">			&lt;tx:method name=<span class="string">"find*"</span> <span class="built_in">read</span>-only=<span class="string">"true"</span> /&gt;</span><br><span class="line">			&lt;tx:method name=<span class="string">"isNot*"</span> <span class="built_in">read</span>-only=<span class="string">"true"</span> /&gt;</span><br><span class="line">		&lt;/tx:attributes&gt;</span><br><span class="line">	&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:pointcut id=<span class="string">"services"</span></span><br><span class="line">					  expression=<span class="string">"execution(* flydev.*.service.*.*(..))"</span> /&gt;</span><br><span class="line">		&lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut-ref=<span class="string">"services"</span> /&gt;</span><br><span class="line">	&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在工作中碰到了保存数据时需要跨IDC写多个数据库的需求，记得多年前的做法是在java代码里面lookup需要的数据源,但是这样的做法明显耦合度太高了。现在我们大多java项目已经离不开spring了,spring也提供各种强大的功能，所以就特地看了下spring对于动态数据源的配置，顺便将spring对于事务配置的两种常见的方式也整理一下。</p>
<p>动态数据源具体实现的思路就是采用Proxy模式，弄一个虚拟的数据源，并且用它来封装数据源选择逻辑，由虚拟的数据源根据Client提供的上下文来实现数据源的选择。</p>]]>
    
    </summary>
    
      <category term="spring" scheme="http://www.52ff.cc/tags/spring/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发需掌握的linux命令小记]]></title>
    <link href="http://www.52ff.cc/2015/02/23/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%9C%80%E6%8E%8C%E6%8F%A1%E7%9A%84linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/02/23/开发人员需掌握的linux命令/</id>
    <published>2015-02-23T02:13:12.000Z</published>
    <updated>2015-03-23T08:16:21.000Z</updated>
    <content type="html"><![CDATA[<p>抽空将之前记录的工作几年来使用的linux命令重新温习整理下<br><a id="more"></a></p>
<h2 id="文件相关">文件相关</h2><ul>
<li>文件拷贝</li>
</ul>
<p>参数：<br>cp -l file1 file2 创建硬链接<br>cp -s file1 file2 创建软链接<br>cp -r d1 d2 递归持续复制，用于目录的复制行为；<br>mv test.log test1.txt 文件改名<br>mv test1.txt test3 将test1.txt文件移到目录test3中<br>mv <em> ../移动当前文件夹下的所有文件到上一级目录<br>mv test3/</em>.txt test5 把当前目录的一个子目录里的文件移动到另一个子目录里<br>mv dir1 dir2 目录的移动<br>rz 上传文件<br>sz 下载文件</p>
<ul>
<li>远程文件拷贝</li>
</ul>
<p>rcp通过rsh方式远端复制文件或目录。<br>scp通过ssh方式远端复制文件或目录</p>
<p>语法：rcp [-pr][源文件或目录][目标文件或目录] 或 scp [-pr][源文件或目录…][目标文件] </p>
<p>例如：<br>scp /home/user/hosts.list  user@ip:/home/user/<br>scp user@ip:/home/user/hosts.list  /home/user/</p>
<ul>
<li>内容查看</li>
</ul>
<p>cat -n file1 查看整个文件，同时显示行号<br>grep 进行匹配输出<br>tail -100f file1 显示文件file1最后100行<br>sort 对文本文件进行行排序</p>
<ul>
<li>文件解压缩<br>zip -r test.zip test 递归压缩目录<br>unzip test.zip 解压<br>tar -tf test.tar 列出test.tar 内容，不解压<br>tar -xvf test.tar 解压<br>tar -zxvf test.tgz 解压gzip压缩过的tar文件</li>
</ul>
<h2 id="网络相关">网络相关</h2><ul>
<li><p>Netstat</p>
<p>用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)</p>
<p>  常见参数<br>  -a (all)显示所有选项，默认不显示LISTEN相关<br>  -t (tcp)仅显示tcp相关选项<br>  -u (udp)仅显示udp相关选项<br>  -n 拒绝显示别名，能显示数字的全部转化成数字。<br>  -l 仅列出有在 Listen (监听) 的服務状态<br>  -p 显示建立相关链接的程序名<br>  -r 显示路由信息，路由表<br>  -e 显示扩展信息，例如uid等<br>  -s 按各个协议进行统计<br>  -c 每隔一个固定时间，执行该netstat命令。<br>  提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到</p>
</li>
</ul>
<pre><code>列出所有端口 netstat -a
列出所有 tcp 端口 netstat -at
列出所有 udp 端口 netstat -au
只显示监听端口 netstat -<span class="keyword">l</span>
只列出所有监听 UNIX 端口 netstat -lx
显示TCP或UDP 端口的统计信息 netstat -<span class="keyword">st</span> 或 -<span class="keyword">su</span>
显示核心路由信息 netstat -<span class="literal">r</span>
找出运行在指定端口的进程 netstat -<span class="keyword">an</span>|grep 8080 或 netstat -anpt|grep 8080
</code></pre><ul>
<li>tcpdump</li>
</ul>
<p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>截获所有210.27.48.1 的主机收到的和发出的所有的数据包<br>tcpdump host 210.27.48.1</p>
<p>截获主机210.27.48.1 和主机210.27.48.2 的通信<br>tcpdump host 210.27.48.1 and 210.27.48.2 </p>
<p>详见：<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>抽空将之前记录的工作几年来使用的linux命令重新温习整理下<br>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.52ff.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写了个异或加密小程序]]></title>
    <link href="http://www.52ff.cc/2015/02/22/%E5%86%99%E4%BA%86%E4%B8%AA%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.52ff.cc/2015/02/22/写了个异或加密小程序/</id>
    <published>2015-02-22T13:40:50.000Z</published>
    <updated>2015-03-15T14:01:46.000Z</updated>
    <content type="html"><![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>
<a id="more"></a>
<p>代码如下，记录下以后review用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class XORCodec &#123;</span><br><span class="line">	private final static String key = <span class="string">"unisms"</span>;  //密钥</span><br><span class="line">	private static String EncodeType =<span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 加密(字节版)，字节异或后转<span class="number">16</span>进制</span><br><span class="line">	 * @param @throws UnsupportedEncodingException</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">53</span>:<span class="number">55</span></span><br><span class="line">	 */</span><br><span class="line">	public static String encrypt(String <span class="keyword">in</span>Str) throws UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">		byte[] b=<span class="keyword">in</span>Str.getBytes(EncodeType);</span><br><span class="line">		byte[] snNum = new byte[b.length];</span><br><span class="line">		byte[] c=key.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; b.length; i++, j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == c.length)</span><br><span class="line">				j = <span class="number">0</span>;</span><br><span class="line">			snNum[i] = (byte)(b[i] ^ c[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			result= byte2HexStr(snNum);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 解密(字节版)，将<span class="number">16</span>进制字符串每<span class="number">2</span>位转成INT，再转成byte</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">54</span>:<span class="number">34</span></span><br><span class="line">	 */</span><br><span class="line">	public static String decrypt(String instr)&#123;</span><br><span class="line">		byte[] snNum=null;</span><br><span class="line">		byte[] c=null;</span><br><span class="line">		int len;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			len = instr.length()/<span class="number">2</span>;</span><br><span class="line">			snNum = new byte[len];</span><br><span class="line">			c=key.getBytes();</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++, j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == c.length)</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				snNum[i] = (byte) ((byte)(Integer.parseInt(instr.substring(i*<span class="number">2</span>,i*<span class="number">2</span>+<span class="number">2</span>),<span class="number">16</span>)) ^ c[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			result=new String(snNum,EncodeType);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bytes转换成十六进制字符</span><br><span class="line">	 */</span><br><span class="line">	public static String byte2HexStr(byte[] b)</span><br><span class="line">	&#123;</span><br><span class="line">		String stmp=<span class="string">""</span>;</span><br><span class="line">		StringBuilder sb = new StringBuilder(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span> (int n=<span class="number">0</span>;n&lt;b.length;n++)</span><br><span class="line">		&#123;</span><br><span class="line">			stmp = Integer.toHexString(b[n] &amp; <span class="number">0</span>xFF);//<span class="number">0</span>xFF即<span class="number">256</span>相当于<span class="number">11111111</span></span><br><span class="line">			sb.append((stmp.length()==<span class="number">1</span>)? <span class="string">"0"</span>+stmp : stmp);</span><br><span class="line">			sb.append(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> sb.toString().toUpperCase().trim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 加密(字符版)</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String encrypt2(String data)&#123;</span><br><span class="line">		int[] temp = new int[data.length()];</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		//循环需加密的字符串和密钥，分别从需加密字符串和密钥中获取一个字符进行异或</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;data.length();i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			temp[i] = data.charAt(i)^key.charAt(j);//需加密的字符串中一个字符和密钥中一个字符异或得到十进制的整数</span><br><span class="line">			str = Integer.toHexString(temp[i]);//将十进制转化成<span class="number">16</span>进制</span><br><span class="line">			<span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;//不足<span class="number">4</span>位的进行补零</span><br><span class="line">				str = <span class="string">"000"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">2</span>)&#123;</span><br><span class="line">				str = <span class="string">"00"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">3</span>)&#123;</span><br><span class="line">				str = <span class="string">"0"</span>+str;</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span>  result.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 解密(字符版)</span><br><span class="line">	 * @throws</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String decrypt2(String data)&#123;</span><br><span class="line">		char[] c=new char[data.length()/<span class="number">4</span>];//加密后的长度是原先的<span class="number">4</span>倍</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;c.length;i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			int n = Integer.parseInt(data.substring(i*<span class="number">4</span>,i*<span class="number">4</span>+<span class="number">4</span>),<span class="number">16</span>);//将<span class="number">16</span>进制的字符串解析为整数，因为加密时不足<span class="number">4</span>位补到<span class="number">4</span>位，所以每四个进行一次转化</span><br><span class="line">			c[i]=(char)((char)n^key.charAt(j));//重新和密钥中字符异或还原成原先的字符</span><br><span class="line">			result.append(c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL优化的几条建议]]></title>
    <link href="http://www.52ff.cc/2015/02/19/SQL%E4%BC%98%E5%8C%96%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%9D%A1%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/19/SQL优化的若干条技巧/</id>
    <published>2015-02-19T06:50:55.000Z</published>
    <updated>2015-03-23T06:25:56.000Z</updated>
    <content type="html"><![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>
<a id="more"></a>
<h3 id="选择最有效率的表名顺序_(只在基于规则的优化器中有效)_：">选择最有效率的表名顺序 (只在基于规则的优化器中有效) ：</h3><pre><code>ORACLE 的解析器按照从右到左的顺序处理 <span class="keyword">FROM</span> 子句中的表名， <span class="keyword">FROM</span> 子句中写在最右的表将被最先处理，所以我们需要把记录最少的表写在最右边。如果有<span class="number">3</span>个以上的表连接查询，那就需要选择交叉表写在最右，交叉表是指那个被其他表所引用的表。
简而言之：大表在前，小表在后
</code></pre><h3 id="WHERE子句中的连接顺序：">WHERE子句中的连接顺序：</h3><pre><code>ORACLE采用自下而上的顺序解析 <span class="keyword">WHERE</span> 子句,根据这个原理 , 表之间的连接必须写在其他 <span class="keyword">WHERE</span> 条件之前 , 那些可以过滤掉最大数量记录的条件必须写在 <span class="keyword">WHERE</span> 子句的末尾<span class="built_in">.</span>
</code></pre><h3 id="SELECT子句中避免使用’*’_：">SELECT子句中避免使用’*’ ：</h3><pre><code>ORACLE在解析的过程中,会将 <span class="string">'*'</span>  依次转换成所有的列名 ,  这个工作是通过查询数据字典完成的 , 这意味着将耗费更多的时间
</code></pre><h3 id="使用_DECODE_函数来减少处理时间：">使用 DECODE 函数来减少处理时间：</h3><pre><code>使用<span class="variable">DECODE</span> 函数可以避免重复扫描相同记录或重复连接相同的表 .
</code></pre><h3 id="删除重复记录：">删除重复记录：</h3><pre><code>最高效的删除重复记录方法 (因为使用了 ROWID) 例子：
<span class="operator"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span>  EMP E  <span class="keyword">WHERE</span>  E.ROWID &gt; (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(X.ROWID) <span class="keyword">FROM</span>  EMP X  <span class="keyword">WHERE</span>  X.EMP_NO = E.EMP_NO);</span>
</code></pre><h3 id="用_TRUNCATE_替代_DELETE_：">用 TRUNCATE 替代 DELETE ：</h3><pre><code>当删除表中的记录时, 在通常情况下 ,  回滚段 (<span class="operator"><span class="keyword">rollback</span> segments)  用来存放可以被恢复的信息 .  如果你没有 <span class="keyword">COMMIT</span> 事务 ,ORACLE 会将数据恢复到删除之前的状态 (准确地说是恢复到执行删除命令之前的状况)  而当运用 <span class="keyword">TRUNCATE</span> 时 ,  回滚段不再存放任何可被恢复的信息 . 当命令运行后 , 数据不能被恢复 . 因此很少的资源被调用,执行时间也会很短.</span>
</code></pre><h3 id="尽量多使用_COMMIT_：">尽量多使用 COMMIT ：</h3><pre><code>只要有可能, 在程序中尽量多使用 <span class="operator"><span class="keyword">COMMIT</span>,  这样程序的性能得到提高 , 需求也会因为 <span class="keyword">COMMIT</span> 所释放的资源而减少 :
<span class="keyword">COMMIT</span>所释放的资源 :
a. 回滚段上用于恢复数据的信息
b. 被程序语句获得的锁
c. redo <span class="keyword">log</span> buffer 中的空间
d. ORACLE为管理上述 <span class="number">3</span> 种资源中的内部花费</span>
</code></pre><h3 id="用_Where_子句替换_HAVING_子句：">用 Where 子句替换 HAVING 子句：</h3><pre><code>避免使用HAVING 子句 , HAVING  只会在检索出所有记录之后才对结果集进行过滤 .  这个处理需要排序 , 总计等操作 . 如果能通过 WHERE 子句限制记录的数目 , 那就能减少这方面的开销.<span class="keyword">on</span> 、 <span class="keyword">where</span> 、 having 这三个都可以加条件的子句中， <span class="function_start"><span class="keyword">on</span></span> 是最先执行， <span class="keyword">where</span> 次之， having 最后
</code></pre><h3 id="用_EXISTS_替代_IN_、用_NOT_EXISTS_替代_NOT_IN_：">用 EXISTS 替代 IN 、用 NOT EXISTS 替代 NOT IN ：</h3><pre><code>在许多基于基础表的查询中, 为了满足一个条件 , 往往需要对另一个表进行联接 . 在这种情况下 ,  使用 EXISTS(或 <span class="keyword">NOT</span> EXISTS) 通常将提高查询的效率 . 在子查询中 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 子句将执行一个内部的排序和合并 .  无论在哪种情况下 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 都是最低效的  (因为它对子查询中的表执行了一个全表遍历 ).  为了避免使用 <span class="keyword">NOT</span> <span class="keyword">IN</span> , 我们可以把它改写成外连接 (Outer Joins) 或 <span class="keyword">NOT</span> EXISTS.

(高效)<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  EXISTS (<span class="keyword">SELECT</span>  ‘ X<span class="comment">'  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC =  ‘ MELB')</span>

(低效)<span class="keyword">SELECT</span>  * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  DEPTNO <span class="keyword">IN</span>(<span class="keyword">SELECT</span> DEPTNO  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span>  LOC =  ‘ MELB<span class="comment">')</span>
</code></pre><h3 id="使用表的别名_(Alias)_：">使用表的别名 (Alias) ：</h3><pre><code>当在SQL 语句中连接多个表时 ,  请使用表的别名并把别名前缀于每个 <span class="keyword">Column</span> 上 . 这样一来 , 就可以减少解析的时间并减少那些由 <span class="keyword">Column</span> 歧义引起的语法错误 .
</code></pre><h3 id="避免在索引列上使用计算．">避免在索引列上使用计算．</h3><pre><code>WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．
低效：
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span> SAL * <span class="number">12</span> &gt; <span class="number">25000</span>;</span>
高效:
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span> DEPT <span class="keyword">WHERE</span> SAL &gt; <span class="number">25000</span>/<span class="number">12</span>;</span>
</code></pre><h3 id="用_&gt;=_替代_&gt;">用 &gt;= 替代 &gt;</h3><pre><code>高效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP  <span class="keyword">WHERE</span>  DEPTNO &gt;=<span class="number">4</span>
低效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;<span class="number">3</span>

两者的区别在于,  前者 DBMS 将直接跳到第一个 DEPT 等于 <span class="number">4</span> 的记录而后者将首先定位到 DEPTNO=<span class="number">3</span> 的记录并且向前扫描到第一个 DEPT 大于 <span class="number">3</span> 的记录 .
</code></pre><h3 id="减少对表的查询：">减少对表的查询：</h3><pre><code>在含有子查询的SQL 语句中 , 要特别注意减少对表的查询 . 例子：
    <span class="operator"><span class="keyword">SELECT</span>  TAB_NAME <span class="keyword">FROM</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> (TAB_NAME,DB_VER) = ( <span class="keyword">SELECT</span> TAB_NAME,DB_VER <span class="keyword">FROM</span>  TAB_COLUMNS  <span class="keyword">WHERE</span>  <span class="keyword">VERSION</span> = <span class="number">604</span>)</span>
</code></pre><h3 id="sql语句用大写的：">sql语句用大写的：</h3><pre><code>因为oracle 总是先解析 sql 语句，把小写的字母转换成大写的再执行
</code></pre><h3 id="在_java_代码中尽量少用连接符_“_＋_”_连接字符串！">在 java 代码中尽量少用连接符 “ ＋ ” 连接字符串！</h3><h3 id="避免在索引列上使用_NOT_：">避免在索引列上使用 NOT ：</h3><pre><code>我们要避免在索引列上使用<span class="literal">NOT</span>, <span class="literal">NOT</span> 会产生在和在索引列上使用函数相同的影响 .  当 ORACLE ” 遇到 ” <span class="literal">NOT</span>, 他就会停止使用索引转而执行全表扫描 .
</code></pre><h3 id="通过内部函数提高_SQL_效率：">通过内部函数提高 SQL 效率：</h3><pre><code>复杂的SQL 往往牺牲了执行效率 . 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的
</code></pre><h3 id="识别_‘_低效执行_‘_的_SQL_语句：">识别 ‘ 低效执行 ‘ 的 SQL 语句：</h3><pre><code>虽然目前各种关于SQL 优化的图形化工具层出不穷 , 但是写出自己的 SQL 工具来解决问题始终是一个最好的方法：
<span class="operator"><span class="keyword">SELECT</span>  EXECUTIONS , DISK_READS, BUFFER_GETS,
<span class="keyword">ROUND</span>((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) Hit_radio,
<span class="keyword">ROUND</span>(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,
SQL_TEXT
<span class="keyword">FROM</span>  V$SQLAREA
<span class="keyword">WHERE</span>  EXECUTIONS&gt;<span class="number">0</span>
<span class="keyword">AND</span>  BUFFER_GETS &gt; <span class="number">0</span>
<span class="keyword">AND</span>  (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span>
<span class="keyword">ORDER</span> <span class="keyword">BY</span>  <span class="number">4</span> <span class="keyword">DESC</span>;</span>
</code></pre><h3 id="用索引提高效率：">用索引提高效率：</h3><pre><code>索引是表的一个概念部分, 用来提高检索数据的效率， ORACLE 使用了一个复杂的自平衡 B-tree 结构 .  通常 , 通过索引查询数据比全表扫描要快 .  当 ORACLE 找出执行查询和 <span class="operator"><span class="keyword">Update</span> 语句的最佳路径时 , ORACLE 优化器将使用索引 .  同样在联结多个表时使用索引也可以提高效率 .  另一个使用索引的好处是 , 它提供了主键 (<span class="keyword">primary</span> <span class="keyword">key</span>) 的唯一性验证 . 。那些 LONG 或 LONG RAW 数据类型 ,  你可以索引几乎所有的列 .  通常 ,  在大型表中使用索引特别有效 .  当然 , 你也会发现 ,  在扫描小表时 , 使用索引同样能提高效率 .  虽然使用索引能得到查询效率的提高 , 但是我们也必须注意到它的代价 .  索引需要空间来存储 , 也需要定期维护 ,  每当有记录在表中增减或索引列被修改时 ,  索引本身也会被修改 .  这意味着每条记录的 <span class="keyword">INSERT</span> , <span class="keyword">DELETE</span> , <span class="keyword">UPDATE</span> 将为此多付出 <span class="number">4</span> , <span class="number">5</span>  次的磁盘 I/O .  因为索引需要额外的存储空间和处理 , 那些不必要的索引反而会使查询反应时间变慢 . 。定期的重构索引是有必要的 . <span class="keyword">ALTER</span>  <span class="keyword">INDEX</span> &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt;</span>
</code></pre><h3 id="用_UNION_替换_OR_(_适用于索引列_)">用 UNION 替换 OR ( 适用于索引列 )</h3><pre><code>通常情况下,  用 <span class="keyword">UNION</span> 替换 <span class="keyword">WHERE</span> 子句中的 <span class="keyword">OR</span> 将会起到较好的效果 .  对索引列使用 <span class="keyword">OR</span> 将造成全表扫描 .  注意 ,  以上规则只针对多个索引列有效 .  如果有 column 没有被索引 ,  查询效率可能会因为你没有选择 <span class="keyword">OR</span> 而降低 .  在下面的例子中 , LOC_ID  和 REGION 上都建有索引 .

高效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span>
<span class="keyword">UNION</span>
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> REGION = “ MELBOURNE ”
低效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> REGION = “ MELBOURNE ”
如果你坚持要用<span class="keyword">OR</span>,  那就需要返回记录最少的索引列写在最前面 .
</code></pre><h3 id="用_IN_来替换_OR">用 IN 来替换 OR</h3><pre><code>低效:
<span class="operator"><span class="keyword">SELECT</span>… . <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> LOC_ID = <span class="number">20</span> <span class="keyword">OR</span> LOC_ID = <span class="number">30</span>

高效
<span class="keyword">SELECT</span>…  <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_IN  <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span>
</code></pre><h3 id="避免在索引列上使用_IS_NULL_和_IS_NOT_NULL">避免在索引列上使用 IS NULL 和 IS NOT NULL</h3><pre><code>避免在索引中使用任何可以为空的列，ORACLE 将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录 .  对于复合索引，如果每个列都为空，索引中同样不存在此记录 . 　如果至少有一个列不为空，则记录存在于索引中．举例 :  如果唯一性索引建立在表的 A 列和 B 列上 ,  并且表中存在一条记录的 A,B 值为 (123,null) , ORACLE 将不接受下一条具有相同 A,B 值 (123,null) 的记录 ( 插入 ).  然而如果所有的索引列都为空， ORACLE 将认为整个键值为空而空不等于空 .  因此你可以插入 1000  条具有相同键值的记录 , 当然它们都是空 !  因为空值不存在于索引列中 , 所以 WHERE 子句中对索引列进行空值比较将使 ORACLE 停用该索引 .

索引失效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span>
索引有效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE &gt;=<span class="number">0</span>;</span>
</code></pre><h3 id="总是使用索引的第一个列：">总是使用索引的第一个列：</h3><pre><code>如果索引是建立在多个列上,  只有在它的第一个列 (leading column) 被 <span class="keyword">where</span> 子句引用时 , 优化器才会选择使用该索引 .  这也是一条简单而重要的规则，当仅引用索引的第二个列时 , 优化器使用了全表扫描而忽略了索引
</code></pre><h3 id="用_UNION-ALL_替换_UNION_(如果业务允许)_：">用 UNION-ALL  替换 UNION (如果业务允许) ：</h3><pre><code>当SQL  语句需要 <span class="keyword">UNION</span> 两个查询结果集合时 , 这两个结果集合会以 <span class="keyword">UNION</span>-ALL 的方式被合并 ,  然后在输出最终结果前进行排序 .  如果用 <span class="keyword">UNION</span> ALL 替代 <span class="keyword">UNION</span>,  这样排序就不是必要了 .  效率就会因此得到提高 .  需要注意的是， <span class="keyword">UNION</span> ALL  将重复输出两个结果集合中相同记录 .  因此各位还是要从业务需求分析使用 <span class="keyword">UNION</span> ALL 的可行性 . <span class="keyword">UNION</span>  将对结果集合排序 , 这个操作会使用到 SORT_AREA_SIZE 这块内存 .  对于这块内存的优化也是相当重要的 .  下面的 SQL 可以用来查询排序的消耗量
</code></pre><h3 id="用_WHERE_替代_ORDER_BY_：">用 WHERE 替代 ORDER BY ：</h3><pre><code><span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句只在两种严格的条件下使用索引
<span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序 <span class="built_in">.
</span><span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须定义为非空 <span class="built_in">.
</span><span class="keyword">WHERE</span>子句使用的索引和 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中所使用的索引不能并列 <span class="built_in">.

</span>例如:
表DEPT 包含以下列 :
DEPT_CODE PK <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_DESC <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_TYPE <span class="built_in">NULL</span>

低效: ( 索引不被使用 
<span class="keyword">SELECT</span> DEPT_CODE FROM  DEPT  <span class="keyword">ORDER</span> <span class="keyword">BY</span>  DEPT_TYPE
高效: ( 使用索引 )
<span class="keyword">SELECT</span> DEPT_CODE  FROM  DEPT  <span class="keyword">WHERE</span>  DEPT_TYPE <span class="subst">&gt;</span> <span class="number">0</span>
</code></pre><h3 id="避免改变索引列的类型_:">避免改变索引列的类型 :</h3><pre><code>当比较不同数据类型的数据时, ORACLE 自动对列进行简单的类型转换 .
假设 EMPNO 是一个数值类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = ‘<span class="number">123</span><span class="comment">'</span>
实际上, 经过 ORACLE 类型转换 ,  语句转化为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = TO_NUMBER(‘<span class="number">123</span><span class="comment">')</span>
幸运的是, 类型转换没有发生在索引列上 , 索引的用途没有被改变 .
现在, 假设 EMP_TYPE 是一个字符类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span> EMP_TYPE = <span class="number">123</span>
这个语句被ORACLE 转换为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  WHERETO_NUMBER(EMP_TYPE)=<span class="number">12</span>    
因为内部发生的类型转换,  这个索引将不会被用到 !  为了避免 ORACLE 对你的 SQL 进行隐式的类型转换 ,  最好把类型转换用显式表现出来 .  注意当字符和数值比较时 , ORACLE 会优先转换数值类型到字符类型
</code></pre><h3 id="需要当心的_WHERE_子句_:">需要当心的 WHERE 子句 :</h3><pre><code>某些<span class="keyword">SELECT</span> 语句中的 <span class="keyword">WHERE</span> 子句不使用索引 . 这里有一些例子 .
在下面的例子里,
(<span class="number">1</span>)‘ !=<span class="comment">'  将不使用索引 .  记住 ,  索引只能告诉你什么存在于表中 ,  而不能告诉你什么不存在于表中 .</span>
(<span class="number">2</span>) ‘ ||<span class="comment">' 是字符连接函数 .  就象其他函数那样 ,  停用了索引 .</span>
(<span class="number">3</span>) ‘ +<span class="comment">' 是数学函数 .  就象其他数学函数那样 ,  停用了索引 .</span>
</code></pre><h3 id="使用索引">使用索引</h3><pre><code><span class="tag">a</span>. 如果检索数据量超过 <span class="number">30%</span> 的表中记录数 . 使用索引将没有显著的效率提高 . 
<span class="tag">b</span>. 在特定情况下, 使用索引也许会比全表扫描慢 ,  但这是同一个数量级上的区别 . 而通常情况下, 使用索引比全表扫描要块几倍乃至几千倍 ! 
</code></pre><h3 id="避免使用耗费资源的操作_:">避免使用耗费资源的操作 :</h3><pre><code>带有DISTINCT,UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span>,ORDER BY 的SQL 语句会启动 SQL引擎 
执行耗费资源的排序(<span class="keyword">SORT</span>)功能 . DISTINCT 需要一次排序操作,而其他的至少需要执行两次排序.通常,带有 UNION, <span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 的 SQL 语句都可以用其他方式重写.如果你的数据库的 SORT_AREA_SIZE调配得好,使用 UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 也是可以考虑的,毕竟它们的可读性很强 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>]]>
    
    </summary>
    
      <category term="sql" scheme="http://www.52ff.cc/tags/sql/"/>
    
      <category term="sql数据库" scheme="http://www.52ff.cc/categories/sql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>