<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[FlyFish's Blog]]></title>
  <subtitle><![CDATA[才华配不上梦想就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-04-04T14:31:23.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[xiangming]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[高并发大吞吐量服务端的思考]]></title>
    <link href="http://www.52ff.cc/2015/04/04/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%A4%A7%E5%90%9E%E5%90%90%E9%87%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.52ff.cc/2015/04/04/高并发大吞吐量服务端的思考/</id>
    <published>2015-04-04T14:11:41.000Z</published>
    <updated>2015-04-04T14:31:23.000Z</updated>
    <content type="html"><![CDATA[<p>目前大家开发的应用程序基本上是IO密集型，而非计算密集型。</p>
<p>这里就IO密集型的应用程序探讨下服务端的建设。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前大家开发的应用程序基本上是IO密集型，而非计算密集型。</p>
<p>这里就IO密集型的应用程序探讨下服务端的建设。</p>
]]>
    </summary>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阻塞和非阻塞IO]]></title>
    <link href="http://www.52ff.cc/2015/04/04/%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>http://www.52ff.cc/2015/04/04/阻塞和非阻塞IO/</id>
    <published>2015-04-04T12:56:19.000Z</published>
    <updated>2015-04-04T14:20:18.000Z</updated>
    <content type="html"><![CDATA[<p>首先讲下个人理解的阻塞是：CPU执行时等待其他条件的完成</p>
<h2 id="java传统阻塞IO">java传统阻塞IO</h2><p>当进行文件操作File IO时是一个字节一个字节或一行一行的读；<br>当进行网络通信Socket IO时一般是对通道中的字节流进行逐个字节读取；<br>这个时候就会发生阻塞，具体体现就是当获取到CPU执行时，CPU要等待读取完通道中的数据流。 可以为每一个Socket创建一个Thread，虽然这样能大大减少线程获取CPU执行时，CPU等待IO的时间，可是会有小部分客户端过来的通道网络很慢，CPU还是要花大把时间等待在IO上面，真正计算执行的时间很短，而且这样的系统开销和资源浪费都太大，不是合理选择。</p>
<a id="more"></a>
<h2 id="非阻塞NIO">非阻塞NIO</h2><p>而NIO对Socket IO可以实现非阻塞，可以用单线程管理多个通道，并且NIO有了缓冲区的概念，不管是File IO还是Socket IO都是在和Buffer相互读取。<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nio1.jpeg" alt=""></p>
<p>NIO有三个核心模块：Selector(选择器)、Channel(通道)、Buffer(缓冲区)</p>
<p>Selector允许单个线程处理多个Channel，相比旧的IO为防止阻塞而为每一个Channel创建一个Thread来说，性能高出非常多；只用SelectableChannel才能注册到Selector，单线程处理多个Channel如下图</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nio2.jpeg" alt=""></p>
<p>将Channel注册到Selector中，轮询调用select()，这个方法会阻塞，当注册的某个通道准备好要进行IO操作时，这个便返回已选择键的个数，此时通过selectedKeys获得已选择的键，就可以进行相关的IO操作了；选择键(SelectionKey)是用来连接Selector和Channel。</p>
<p>这也就是通过Reactor模式的事件驱动机制来达到的Non blocking，那么什么是Reactor模式呢？Reactor翻译成中文是“反应器”，就是我们将事件注册到Reactor中，当有相应的事件发生时，Reactor便会告知我们有哪些事件发生了，我们再根据具体的事件去做相应的处理。</p>
<p>注：<br>Channel主要有：FileChannel、ServerSocketChannel、SocketChannel、DatagramChannel，这四种通道涵盖了文件IO、TCP套接字IO、UDP数据报IO。</p>
<p>Buffer主要有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，涵盖了IO操作的基本数据类型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先讲下个人理解的阻塞是：CPU执行时等待其他条件的完成</p>
<h2 id="java传统阻塞IO">java传统阻塞IO</h2><p>当进行文件操作File IO时是一个字节一个字节或一行一行的读；<br>当进行网络通信Socket IO时一般是对通道中的字节流进行逐个字节读取；<br>这个时候就会发生阻塞，具体体现就是当获取到CPU执行时，CPU要等待读取完通道中的数据流。 可以为每一个Socket创建一个Thread，虽然这样能大大减少线程获取CPU执行时，CPU等待IO的时间，可是会有小部分客户端过来的通道网络很慢，CPU还是要花大把时间等待在IO上面，真正计算执行的时间很短，而且这样的系统开销和资源浪费都太大，不是合理选择。</p>]]>
    
    </summary>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty异步事件驱动模型]]></title>
    <link href="http://www.52ff.cc/2015/04/03/netty%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.52ff.cc/2015/04/03/netty异步事件驱动模型/</id>
    <published>2015-04-02T16:18:29.000Z</published>
    <updated>2015-04-06T03:07:32.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"></p>
<p> Netty使用了异步的事件驱动模型，来触发网络I/O的各种操作，其在socket层上面封装一层异步事件驱动模型，使得业务代码不需要关心网络底层，就可以编写异步的无网络I/O阻塞的代码。</p>
<a id="more"></a>
<p>Netty的异步事件驱动模型主要涉及到下面几个核心的概念：</p>
<ul>
<li>Channel：表示一个与socket关联的通道</li>
<li>ChannelPipeline： 管道，一个Channel拥有一个ChannelPipeline，ChannelPipeline维护着一个处理链（严格的说是两 个：upstream、downstream），处理链是由很多处理句柄ChannelHandler所构成，每个ChannelHandler处理完以 后会传递给链中的下一个处理句柄继续处理。</li>
<li>ChannelHandler：处理句柄，用户可以定义自己的处理句柄来处理每个请求，或发出请求前进行预处理，典型的有编码/解码器：decoder、encoder。</li>
<li>ChannelEvent：事件，是整个模型的处理对象，当产生或触发（fire）一个事件时，该事件会沿着ChannelPipeline处理链依次被处理。</li>
<li>ChannelFuture： 异步结果，这个是异步事件处理的关键，当一个事件被处理时，可以直接以ChannelFuture的形式直接返回，不用在当前操作中被阻塞。可以通过 ChannelFuture得到最终的执行结果，具体的做法是在ChannelFuture添加监听器listener，当操作最终被执行完 后，listener会被触发，我们可以在listener的回调函数中预定义我们的业务代码。</li>
</ul>
<p>模型的结构图如下： </p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty6.jpg" alt=""></p>
<p>ChannelPipeline实际上维持了两个处理链：upstream、downstream。 Upstream一般处理来自Channel的读事件，而downstream一般处理向Channel的写事件。需要注意的是，这两个处理链是相互独立 的，在upstream链中传递到最后一个ChannelHandler处理后，不会再传递到downstream链中继续处理。</p>
<p>在downstream链的末端会有个ChannelSink处理，用户可以自定义这个ChannelSink的实现，系统也有个默认的实现，当downstream链中最后一个ChannelHandler处理完后会被传递给这个ChannelSink进行最后的处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"/></p>
<p> Netty使用了异步的事件驱动模型，来触发网络I/O的各种操作，其在socket层上面封装一层异步事件驱动模型，使得业务代码不需要关心网络底层，就可以编写异步的无网络I/O阻塞的代码。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM-体系结构 内存模型]]></title>
    <link href="http://www.52ff.cc/2015/04/02/JVM-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.52ff.cc/2015/04/02/JVM-体系结构-内存模型/</id>
    <published>2015-04-02T13:01:39.000Z</published>
    <updated>2015-04-02T13:06:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一：Java技术体系模块图">一：Java技术体系模块图</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm1.jpg" alt=""><br><a id="more"></a></p>
<h2 id="二：JVM内存区域模型">二：JVM内存区域模型</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm2.jpg" alt=""></p>
<p>1.方法区<br>也称”永久代” 、“非堆”，  它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。<br>2.虚拟机栈<br>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。<br> 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。<br>3.本地方法栈<br> 与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。<br>4.堆<br>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。<br>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。<br>新生代：<br> 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。<br>老年代：<br>用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。<br>老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm3.jpg" alt=""></p>
<p>5.程序计数器<br>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h2 id="三：直接内存">三：直接内存</h2><p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一：Java技术体系模块图">一：Java技术体系模块图</h2><p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/jvm1.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://www.52ff.cc/tags/jvm/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM学习-GC]]></title>
    <link href="http://www.52ff.cc/2015/04/01/JVM%E5%AD%A6%E4%B9%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://www.52ff.cc/2015/04/01/JVM学习-垃圾回收/</id>
    <published>2015-04-01T02:32:53.000Z</published>
    <updated>2015-04-06T03:12:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本回收算法">基本回收算法</h2><p>引用计数（Reference Counting）<br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。<br><a id="more"></a></p>
<hr>
<p>标记-清除（Mark-Sweep）<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p>
<hr>
<p>复制（Copying）<br>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外 一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺 点也是很明显的，就是需要两倍内存空间。</p>
<hr>
<p>标记-整理（Mark-Compact）<br>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历 整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<hr>
<p>增量收集（Incremental Collecting）<br>实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</p>
<hr>
<p>分代（Generational Collecting）<br>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p>
<h2 id="垃圾回收器">垃圾回收器</h2><ul>
<li>Serial：串行收集器，当进行垃圾收集时，会暂停所有线程</li>
<li>Parallel：并行收集器，是串行收集器的多线程版本，多CPU下</li>
<li>ParallelOld：老年代的Parallel版本</li>
<li>ConcMarkSweep：简称CMS，是并发收集器，将部分操作与用户线程并发执行</li>
<li>CMSIncrementalMode：CMS收集器变种，属增量式垃圾收集器，在并发标记和并发清理时交替运行垃圾收集器和用户线程</li>
<li>G1：面向服务器端应用的垃圾收集器，计划未来替代CMS收集器</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基本回收算法">基本回收算法</h2><p>引用计数（Reference Counting）<br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。<br>]]>
    
    </summary>
    
      <category term="jvm" scheme="http://www.52ff.cc/tags/jvm/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty学习笔记-线程模型]]></title>
    <link href="http://www.52ff.cc/2015/03/30/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.52ff.cc/2015/03/30/Netty学习笔记-线程模型/</id>
    <published>2015-03-30T15:05:34.000Z</published>
    <updated>2015-04-06T03:11:34.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"></p>
<p>常见并发服务器方案比较:<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/20131104212306625.png" alt=""></p>
<p>具体可参照:<a href="http://blog.csdn.net/yusiguyuan/article/details/17591613" target="_blank" rel="external">常见多线程并发服务器编程模型</a></p>
<a id="more"></a>
<p>下面看下Netty的线程模型。Netty采用了Reactor模式，Reactor模式有多个变种，Netty基于Multiple Reactors模式（如下图）做了一定的修改，Mutilple Reactors模式有多个reactor：mainReactor和subReactor，其中mainReactor负责客户端的连接请求，并将请求转交给subReactor，后由subReactor负责相应通道的IO请求，非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理。</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"/></p>
<p>常见并发服务器方案比较:<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/20131104212306625.png" alt=""></p>
<p>具体可参照:<a href="http://blog.csdn.net/yusiguyuan/article/details/17591613">常见多线程并发服务器编程模型</a></p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty学习笔记–ByteBuf]]></title>
    <link href="http://www.52ff.cc/2015/03/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%93ByteBuf/"/>
    <id>http://www.52ff.cc/2015/03/24/Netty学习笔记–ByteBuf/</id>
    <published>2015-03-24T12:54:25.000Z</published>
    <updated>2015-04-06T03:11:58.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"></p>
<p>Netty的ByteBuf是Java NIO Buffer的优化，比JDK自带的缓冲区实现更优秀。</p>
<p>Netty缓冲API提供了几个优势:</p>
<ul>
<li>可以自定义缓冲类型 </li>
<li>通过一个内置的复合缓冲类型实现零拷贝 </li>
<li>扩展性好,比如StringBuffer </li>
<li>不需要调用flip()来切换读/写模式 </li>
<li>读取和写入索引分开</li>
<li>方法链 </li>
<li>引用计数 </li>
<li>Pooling(池)</li>
</ul>
<a id="more"></a>
<h2 id="读写索引">读写索引</h2><p>ByteBuf是一个很好的经过优化的字节数据容器,我们可以将字节数据有效的添加到ByteBuf中或从ByteBuf中获取数据。ByteBuf有2部分:一个用于读,一个用于写。ByteBuf提供两个指针变量支付读和写操作,读操作是使用readerIndex(),写操作时使用writerIndex()<br>写入数据到ByteBuf后,写入索引是增加的字节数量。开始读字节后,读取索引增加。你可以读取字节,直到写入索引和读取索引处理相同的位置,若再继续读取,则会抛出IndexOutOfBoundsException。调用ByteBuf的任何方法开始读/写都会单独维护读索引和写索引。ByteBuf的默认最大容量限制是Integer.MAX_VALUE,写入时若超出这个值将会导致一个异常。</p>
<p>对比上一篇讲到的关于java.nio.Buffer的知识。<br>个人的理解是：</p>
<pre><code>ByteBuf的读索引替代了java<span class="class">.nio</span><span class="class">.Buffer</span>的<span class="attribute">position</span>的作用
写索引替代了java<span class="class">.nio</span><span class="class">.Buffer</span>的limit的作用
</code></pre><p>这和JDK的ByteBuffer不同,ByteBuffer只有一个方法来设置索引,所以需要使用flip()方法来切换读和写模式。<br>ByteBuf一定符合:0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity。<br>注:flip()相当于buffer.limit(buffer.position( )).position(0); </p>
<h2 id="3种不同类型的ByteBuf">3种不同类型的ByteBuf</h2><ul>
<li>Heap Buffer(堆缓冲区)<br>  最常用的类型是ByteBuf将数据存储在JVM的堆空间,这是通过将数据存储在数组的实现。堆缓冲区可以快速分配,当不使用时也可<br>以快速释放。它还提供了直接访问数组的方法,通过ByteBuf.array()来获取byte[]数据。<br>访问非堆缓冲区ByteBuf的数组会导致UnsupportedOperationException,可以使用ByteBuf.hasArray()来检查是否支持访问数组。</li>
<li>Direct Buffer(直接缓冲区)<br>直接缓冲区,在堆之外直接分配内存。直接缓冲区不会占用堆空间容量,使用时应该考虑到应用程序要使用的最大内存容量以及如何限制它。直接缓冲区在使用Socket传递数据时性能很好,因为若使用间接缓冲区,JVM会先将数据复制到直接缓冲区再进行传递;但是直接缓冲区的缺点是在分配内存空间和释放内存时比堆缓冲区更复杂,而Netty使用内存池来解决这样的问题,这也是Netty使用内存池的原因之一。直接缓冲区不支持数组访问数据,但是我们可以间接的访问数据数组,如下面代码:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);￼<span class="keyword">if</span>(!directBuf.hasArray())&#123;    int len = directBuf.readableBytes();￼    byte[] arr = new byte[len];￼    directBuf.getBytes(<span class="number">0</span>, arr);&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问直接缓冲区的数据数组需要更多的编码和更复杂的操作,建议若需要在数组访问数据使用堆缓冲区会更好。</p>
<ul>
<li>Composite Buffer(复合缓冲区)<br>  复合缓冲区,我们可以创建多个不同的ByteBuf,然后提供一个这些ByteBuf组合的视图。复合缓冲区就像一个列表,我们可以动态 的添加和删除其中的ByteBuf,JDK的ByteBuffer没有这样的功能。Netty提供了CompositeByteBuf类来处理复合缓冲 区,CompositeByteBuf只是一个视图,CompositeByteBuf.hasArray()总是返回false,因为它可能包含一些直接或间接的不同类型的 ByteBuf。</li>
</ul>
<p>Unpooled也是用来创建缓冲区的工具类,Unpooled提供了很多方法,详细方法及使用可以看API文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//创建复合缓冲区CompositeByteBuf compBuf = Unpooled.compositeBuffer();￼//创建堆缓冲区￼ByteBuf heapBuf = Unpooled.buffer(<span class="number">8</span>);￼//创建直接缓冲区ByteBuf directBuf = Unpooled.directBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p>ByteBuf提供了一些较为丰富的实现类，逻辑上主要分为两种：HeapByteBuf和DirectByteBuf，实现机制则分为两种：PooledByteBuf和UnpooledByteBuf，除了这些之外，Netty还实现了一些衍生ByteBuf（DerivedByteBuf），如：ReadOnlyByteBuf、DuplicatedByteBuf以及SlicedByteBuf。</p>
<p>ByteBuf实现类的类图如下：</p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty3.jpg" alt=""></p>
<h2 id="ByteBuf特殊机制">ByteBuf特殊机制</h2><ul>
<li><p>Reference Count<br>ByteBuf的生命周期管理引入了Reference Count的机制，感觉让我回到了CPP时代。可以通过简单的继承SimpleChannelInboundHandler实现自动释放reference count。SimpleChannelInboundHandler的事件方法如下，在消费完毕msg后，可以AutoRelease之：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">    boolean release = <span class="literal">true</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptInboundMessage(msg)) &#123;</span><br><span class="line">            @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">            I imsg = (I) msg;</span><br><span class="line">            messageReceived(ctx, imsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            release = <span class="literal">false</span>;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (autoRelease &amp;&amp; release) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Zero Copy<br>Zero-copy与传统意义的zero-copy不太一样。传统的zero-copy是IO传输过程中，数据无需中内核态到用户态、用户态到内核态的数据拷贝，减少拷贝次数。而Netty的zero-copy则是完全在用户态，或者说传输层的zero-copy机制，可以参考下图。由于协议传输过程中，通常会有拆包、合并包的过程，一般的做法就是System.arrayCopy了，但是Netty通过ByteBuf.slice以及Unpooled.wrappedBuffer等方法拆分、合并Buffer无需拷贝数据。<br>如何实现zero-copy的呢。slice实现就是创建一个SlicedByteBuf对象，将this对象，以及相应的数据指针传入即可，wrappedBuffer实现机制类似。</p>
</li>
</ul>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/netty4.png" alt=""></p>
<h2 id="实用工具类">实用工具类</h2><ul>
<li><p>ByteBufHolder<br>ByteBufHolder是一个辅助类,是一个接口,其实现类是DefaultByteBufHolder,还有一些实现了ByteBufHolder接口的其他接口类。 ByteBufHolder的作用就是帮助更方便的访问ByteBuf中的数据,当缓冲区没用了后,可以使用这个辅助类释放资源。ByteBufHolder很简 单,提供的可供访问的方法也很少。如果你想实现一个“消息对象”有效负载存储在ByteBuf,使用ByteBufHolder是一个好主意。</p>
</li>
<li><p>ByteBufAllocator<br>Netty支持各种ByteBuf的池实现,来使Netty提供一种称为ByteBufAllocator成为可能。ByteBufAllocator负责分配ByteBuf实 例,ByteBufAllocator提供了各种分配不同ByteBuf的方法,如需要一个堆缓冲区可以使用ByteBufAllocator.heapBuffer(),需要一个直接 缓冲区可以使用ByteBufAllocator.directBuffer(),需要一个复合缓冲区可以使用ByteBufAllocator.compositeBuffer()。其他方法的使用可 以看ByteBufAllocator源码及注释。<br>获取ByteBufAllocator对象很容易,可以从Channel的alloc()获取,也可以从ChannelHandlerContext的alloc()获取。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">￼@Override￼public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;    ￼//get ByteBufAllocator instance by ChannelHandlerContext.alloc()</span><br><span class="line">    ByteBufAllocator alloc1 = ctx.alloc();</span><br><span class="line">    ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ByteBufUtil<br>ByteBufUtil提供了一些静态的方法,在操作ByteBuf时非常有用。ByteBufUtil提供了Unpooled之外的一些方法,也许最有价值的是 hexDump(ByteBuf buffer)方法,这个方法返回指定ByteBuf中可读字节的十六进制字符串,可以用于调试程序时打印ByteBuf的内容,十 六进制字符串相比字节而言对用户更友好。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"/></p>
<p>Netty的ByteBuf是Java NIO Buffer的优化，比JDK自带的缓冲区实现更优秀。</p>
<p>Netty缓冲API提供了几个优势:</p>
<ul>
<li>可以自定义缓冲类型 </li>
<li>通过一个内置的复合缓冲类型实现零拷贝 </li>
<li>扩展性好,比如StringBuffer </li>
<li>不需要调用flip()来切换读/写模式 </li>
<li>读取和写入索引分开</li>
<li>方法链 </li>
<li>引用计数 </li>
<li>Pooling(池)</li>
</ul>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.nio.Buffer研究笔记]]></title>
    <link href="http://www.52ff.cc/2015/03/23/java.nio.Buffer%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.52ff.cc/2015/03/23/java.nio.Buffer研究笔记/</id>
    <published>2015-03-23T06:22:26.000Z</published>
    <updated>2015-04-04T14:24:07.000Z</updated>
    <content type="html"><![CDATA[<p>每当你需要传输数据时,一个缓冲区是必要的。Java NIO API中缓冲区的类主要是Buffer。Buffer是一个包装了基本数据元素数组的对象，它以及它的子类定义了一系列API用于处理数据缓存。其中最重要的子类是ByteBuffer。</p>
<p>Netty的ByteBuf对jdk自带的缓冲区进行了重新设计和优化，Mina的IoBuffer对ByteBuffer进行了封装优化,它们比JDK自带的缓冲区实现更优秀。</p>
<p>本文用于记录java.nio.Buffer的概念结构，也是为了备忘。<br>最后的目的还是为了更好的学习理解Netty的ByteBuf。</p>
<a id="more"></a>
<h3 id="Buffer有四个基本属性：">Buffer有四个基本属性：</h3><p>1、capacity  容量，buffer能够容纳的最大元素数目，在Buffer创建时设定并不能更改<br>2、limit buffer中有效位置数目<br>3、position 下一个读或者写的位置<br>4、mark  用于记忆的标志位，配合reset()使用，初始值未设定，调用mark后设为当前position的值</p>
<p>四者关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<pre><code>写完后将<span class="built_in">limit</span>从capacity设为position
读的时候从position读到<span class="built_in">limit</span>
</code></pre><h3 id="BufferAPI">BufferAPI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package java.nio;</span><br><span class="line">public abstract class Buffer &#123;</span><br><span class="line">public final int capacity( )</span><br><span class="line">public final int position( )</span><br><span class="line">public final Buffer position (int newPosition)</span><br><span class="line">public final int <span class="built_in">limit</span>( )</span><br><span class="line">public final Buffer <span class="built_in">limit</span> (int newLimit)</span><br><span class="line">public final Buffer mark( )</span><br><span class="line">public final Buffer reset( )</span><br><span class="line">public final Buffer clear( )</span><br><span class="line">public final Buffer flip( )</span><br><span class="line">public final Buffer rewind( )</span><br><span class="line">public final int remaining( )</span><br><span class="line">public final boolean hasRemaining( )</span><br><span class="line">public abstract boolean isReadOnly( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持链式调用，如：buffer.mark().position(5).reset();</p>
<h3 id="操作说明">操作说明</h3><ul>
<li>get()从当前position位置读取</li>
<li>put(byte)put(byte)在当前position位置写入<br>get(index)和put(index,byte)不改变当前position属性</li>
<li>flip()将limit属性从capacity设置为当前position,将position设为0<br>相当于buffer.limit(buffer.position( )).position(0);<br>重要：<br>1.从写状态切换到读状态时需要使用flip()<br>2.两次调用buffer的flip方法，将使得position和limit属性都为0</li>
<li>clear()方法，将buffer重设为空状态，也就是设置limit=capacity,position=0，以便重复利用</li>
<li>mark(),初始是未定义的，这适合如果调用reset将抛出InvalidMarkException。调用makr()后，将当前position设为mark以便reset时返回。<br>注意，rewind(), clear(), and flip()方法都将丢弃已经创建的mark。</li>
<li>rewind()位置清零 position = 0;mark = -1; </li>
</ul>
<h3 id="创建Buffer">创建Buffer</h3><p>Buffer以及其子类都无法直接new，而必须把通过他们提供的工厂方法来创建。通常有两种方式：<br>1、allocate，例如<br>CharBuffer charBuffer = CharBuffer.allocate (100);<br>将在堆上分配一个可以存储100个字符的数组作为backing store。</p>
<p>2、wrap，包装一个已有的数组：<br>char [] myArray = new char [100];<br>CharBuffer charbuffer = CharBuffer.wrap (myArray);<br>注意,这样的方式创建的Buffer，将不会在堆上创建新的数组，而是直接利用myArray做backing store，这意味着任何对myArray或者buffer的修改都将影响到buffer或者myArray。可以通过public final boolean hasArray( )方法来判断是否拥有一个数组，通过array()方法取得这个数组。</p>
<h3 id="复制Buffer">复制Buffer</h3><p>   其实这个复制也是“浅拷贝”，通过duplicate()方法将返回一个新创建的buffer，这个新buffer与原来的Buffer共享数据，一样的capacity，但是有自己的position、limit和mark属性。通过asReadOnlyBuffer()方法复制的buffer与duplicate()类似，但是是只读的，不能调用put。比较特别的是slice()方法，故名思议，类似切割一个Buffer出来，与duplicate类似，但是它将从原来Buffer的当前position开始，并且capacity等于原来Buffer的剩余元素数目，也就是(limit-position)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>每当你需要传输数据时,一个缓冲区是必要的。Java NIO API中缓冲区的类主要是Buffer。Buffer是一个包装了基本数据元素数组的对象，它以及它的子类定义了一系列API用于处理数据缓存。其中最重要的子类是ByteBuffer。</p>
<p>Netty的ByteBuf对jdk自带的缓冲区进行了重新设计和优化，Mina的IoBuffer对ByteBuffer进行了封装优化,它们比JDK自带的缓冲区实现更优秀。</p>
<p>本文用于记录java.nio.Buffer的概念结构，也是为了备忘。<br>最后的目的还是为了更好的学习理解Netty的ByteBuf。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis的Master-Slave模式]]></title>
    <link href="http://www.52ff.cc/2015/03/22/Redis%E7%9A%84Master-Slave%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.52ff.cc/2015/03/22/Redis的Master-Slave模式/</id>
    <published>2015-03-22T13:51:48.000Z</published>
    <updated>2015-04-06T03:34:08.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/redis.jpg" class="img-logo"></p>
<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>
<a id="more"></a>
<p>一、Redis的Replication：</p>
<p>下面的列表清楚的解释了Redis Replication的特点和优势。<br>同一个Master可以同步多个Slaves。<br>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。因此我们可以将Redis的Replication架构视为图结构。<br>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。<br>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。<br>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成。即便如此，系统的伸缩性还是得到了很大的提高。<br>Master可以将数据保存操作交给Slaves完成，从而避免了在Master中要有独立的进程来完成此操作。</p>
<p>二、Replication的工作原理：</p>
<p>在Slave启动并连接到Master之后，它将主动发送一个SYNC命令。此后Master将启动后台存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕后，Master将传送整个数据库文件到Slave，以完成一次完全同步。而Slave服务器在接收到数据库文件数据之后将其存盘并加载到内存中。此后，Master继续将所有已经收集到的修改命令，和新的修改命令依次传送给Slaves，Slave将在本次执行这些数据修改命令，从而达到最终的数据同步。<br>如果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。</p>
<p>三、如何配置Replication：</p>
<p>见如下步骤：<br>1). 同时启动两个Redis服务器，可以考虑在同一台机器上启动两个Redis服务器，分别监听不同的端口，如6379和6380。<br>2). 在Slave服务器上执行一下命令：<br>/&gt; redis-cli -p 6380   #这里我们假设Slave的端口号是6380<br>redis 127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 #我们假设Master和Slave在同一台主机，Master的端口为6379<br>OK<br>上面的方式只是保证了在执行slaveof命令之后，redis_6380成为了redis_6379的slave，一旦服务(redis_6380)重新启动之后，他们之间的复制关系将终止。<br>如果希望长期保证这两个服务器之间的Replication关系，可以在redis_6380的配置文件中做如下修改：<br>/&gt; cd /etc/redis  #切换Redis服务器配置文件所在的目录。<br>/&gt; ls<br>6379.conf  6380.conf<br>/&gt; vi 6380.conf<br>将</p>
<h1 id="slaveof">slaveof <masterip> <masterport></masterport></masterip></h1><p>改为<br>slaveof 127.0.0.1 6379<br>保存退出。<br>这样就可以保证Redis_6380服务程序在每次启动后都会主动建立与Redis_6379的Replication连接了。</p>
<p>四、应用示例：</p>
<p>这里我们假设Master-Slave已经建立。</p>
<h1 id="启动master服务器。">启动master服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6379</span>
redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;
</code></pre><h1 id="情况Master当前数据库中的所有Keys。">情况Master当前数据库中的所有Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; flushdb
OK
</code></pre><h1 id="在Master中创建新的Keys作为测试数据。">在Master中创建新的Keys作为测试数据。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; set mykey hello
OK
redis <span class="number">127.0.0.1:6379</span>&gt; set mykey2 world
OK
</code></pre><h1 id="查看Master中存在哪些Keys。">查看Master中存在哪些Keys。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="启动slave服务器。">启动slave服务器。</h1><pre><code>[root<span class="property">@Stephen</span>-PC redis]<span class="comment"># redis-cli -p 6380</span>
</code></pre><h1 id="查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。">查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
<span class="number">2</span>) <span class="string">"mykey2"</span>
</code></pre><h1 id="在Master中删除其中一个测试Key，并查看删除后的结果。">在Master中删除其中一个测试Key，并查看删除后的结果。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6379</span>&gt; del mykey2
(integer) <span class="number">1</span>
redis <span class="number">127.0.0.1:6379</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre><h1 id="在Slave中查看是否mykey2也已经在Slave中被删除。">在Slave中查看是否mykey2也已经在Slave中被删除。</h1><pre><code><span class="title">redis</span> <span class="number">127.0.0.1:6380</span>&gt; keys *
<span class="number">1</span>) <span class="string">"mykey"</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/redis.jpg" class="img-logo"/></p>
<p> Redis的主从复制功能非常强大，一个master可以拥有多个slave，而一个slave又可以拥有多个slave，如此下去，形成了强大的多级服务器集群架构。在Redis中配置Master-Slave模式是一件简单的事。</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-04-06T03:10:41.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄,顺便测试下七牛云图床的速度<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ffpsb.jpeg" class="img-topic"></p>
<a id="more"></a>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ffpsb.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff2.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff3.jpeg" alt=""></p>
<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ff1.jpeg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄,顺便测试下七牛云图床的速度<br><img src="http://7xi8lq.com1.z0.glb.clouddn.com/ffpsb.jpeg" class="img-topic" /></p>]]>
    
    </summary>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为性能注意的地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-17T16:13:27.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-19T04:46:23.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br></pre></td></tr></table></figure>
<p>1.图片设置成撑满整个div，使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!important &gt; [ id &gt; class &gt; tag ]</span><br></pre></td></tr></table></figure></p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简易的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-26T09:37:19.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-20T03:35:36.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>
<a id="more"></a>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<p>[CentOS 6.2下fastDFS的完整安装和配置步骤]<br>(<a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a>)</p>
<p>[FastDFS在Ubuntu下的安装，PHP客户端]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a>)</p>
<p>[FastDFS分布式文件服务器安装，及配置，测试]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a>)</p>
<p>[FastDFS 整合Nginx问题整理]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a>)</p>
<p>[CentOS下搭建FastDFS]<br>(<a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a>)</p>
<p>[Ubuntu安装FastDFS全程记录]<br>(<a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a>)</p>
<p>同事小伍哥对于FastDFS性能的测试结果如下:</p>
<p>场景1：FastDFS+自带HttpServer<br>FastDFS内置了一个Http服务器，可以提供文件下载服务,使用100个线程，下载一个60M的文件，内存消耗6G左右，估计是把文件都放内存里面去了,线程数增加到500，内存占用提高到12G，剩余空闲内存几乎没有，几分钟后，服务器彻底失去响应，只有进行硬件重启.<br>FastDFS开发者表示，老早就不推荐使用内置的Http服务了</p>
<p>场景2：FastDFS+Nginx<br>编译FastDFS的Nginx支持模块，使用Nginx进行文件下载,使用1000个线程并发，下载60M大小的文件，Nginx服务器内存占用20M左右，完全没有压力</p>
<p>场景3：FastDFS+TCPClient<br>FastDFS支持TCP协议，使用其自带的客户端进行下载,使用1000个线程并发，下载60M大小的文件，FastDFS storage内存占用在120M左右，虽然表现没有Nginx那么优秀，但是性能上也足以满足需求了需要注意的是，FastDFS自带的客户端下载文件，内存占用和磁盘IO没有做较好的优化，大并发下载大文件时，会有性能问题</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-04-06T03:18:04.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/redis.jpg" class="img-logo"></p>
<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><pre><code><span class="built_in">save</span>：将数据同步保存到磁盘
bgsave：将数据异步保存到磁盘
lastsave：返回上次成功将数据保存到磁盘的Unix时戳
shundown：将数据同步保存到磁盘，然后关闭服务
</code></pre><h3 id="远程服务控制">远程服务控制</h3><pre><code><span class="keyword">info</span>：提供服务器的信息和统计
monitor：实时转储收到的请求
slaveof：改变复制策略设置
config：在运行时配置Redis服务器
</code></pre><h3 id="对value操作的命令">对value操作的命令</h3><pre><code><span class="function"><span class="title">exists</span><span class="params">(key)</span></span>：确认一个key是否存在
<span class="function"><span class="title">del</span><span class="params">(key)</span></span>：删除一个key
<span class="function"><span class="title">type</span><span class="params">(key)</span></span>：返回值的类型
<span class="function"><span class="title">keys</span><span class="params">(pattern)</span></span>：返回满足给定pattern的所有key
randomkey：随机返回key空间的一个
<span class="function"><span class="title">keyrename</span><span class="params">(old name, newname)</span></span>：重命名key
dbsize：返回当前数据库中key的数目
expire：设定一个key的活动时间（s）
ttl：获得一个key的活动时间
<span class="function"><span class="title">select</span><span class="params">(index)</span></span>：按索引查询
<span class="function"><span class="title">move</span><span class="params">(key, dbindex)</span></span>：移动当前数据库中的key到dbindex数据库
flushdb：删除当前选择数据库中的所有key
flushall：删除所有数据库中的所有key
</code></pre><h3 id="对String操作的命令">对String操作的命令</h3><pre><code><span class="operator"><span class="keyword">set</span>(<span class="keyword">key</span>, <span class="keyword">value</span>)：给数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予值<span class="keyword">value</span>
<span class="keyword">get</span>(<span class="keyword">key</span>)：返回数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>
getset(<span class="keyword">key</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予上一次的<span class="keyword">value</span>
mget(key1, key2,…, <span class="keyword">key</span> N)：返回库中多个<span class="keyword">string</span>的<span class="keyword">value</span>
setnx(<span class="keyword">key</span>, <span class="keyword">value</span>)：添加<span class="keyword">string</span>，名称为<span class="keyword">key</span>，值为<span class="keyword">value</span>
setex(<span class="keyword">key</span>, <span class="keyword">time</span>, <span class="keyword">value</span>)：向库中添加<span class="keyword">string</span>，设定过期时间<span class="keyword">time</span>
mset(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：批量设置多个<span class="keyword">string</span>的值
msetnx(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：如果所有名称为<span class="keyword">key</span> i的<span class="keyword">string</span>都不存在
incr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增<span class="number">1</span>操作
incrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增加<span class="built_in">integer</span>
decr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减<span class="number">1</span>操作
decrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减少<span class="built_in">integer</span>
append(<span class="keyword">key</span>, <span class="keyword">value</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>的值附加<span class="keyword">value</span>
<span class="keyword">substr</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>的子串</span>
</code></pre><h3 id="对List操作的命令">对List操作的命令</h3><pre><code>rpush(key, value)：在名称为key的<span class="keyword">list</span>尾添加一个值为value的元素
lpush(key, value)：在名称为key的<span class="keyword">list</span>头添加一个值为value的 元素
llen(key)：返回名称为key的<span class="keyword">list</span>的长度
<span class="keyword">lrange</span>(key, start, end)：返回名称为key的<span class="keyword">list</span>中start至end之间的元素
ltrim(key, start, end)：截取名称为key的<span class="keyword">list</span>
<span class="keyword">lindex</span>(key, index)：返回名称为key的<span class="keyword">list</span>中index位置的元素
<span class="keyword">lset</span>(key, index, value)：给名称为key的<span class="keyword">list</span>中index位置的元素赋值
lrem(key, count, value)：删除count个key的<span class="keyword">list</span>中值为value的元素
lpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的首元素
rpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的尾元素
blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
brpop(key1, key2,… key N, timeout)：rpop的block版本。
rpoplpush(srckey, dstkey)：返回并删除名称为srckey的<span class="keyword">list</span>的尾元素，并将该元素添加到名称为dstkey的<span class="keyword">list</span>的头部
</code></pre><h3 id="对Set操作的命令">对Set操作的命令</h3><pre><code><span class="function"><span class="title">sadd</span><span class="params">(key, member)</span></span>：向名称为key的set中添加元素member
<span class="function"><span class="title">srem</span><span class="params">(key, member)</span></span> ：删除名称为key的set中的元素member
<span class="function"><span class="title">spop</span><span class="params">(key)</span></span> ：随机返回并删除名称为key的set中一个元素
<span class="function"><span class="title">smove</span><span class="params">(srckey, dstkey, member)</span></span> ：移到集合元素
<span class="function"><span class="title">scard</span><span class="params">(key)</span></span> ：返回名称为key的set的基数
<span class="function"><span class="title">sismember</span><span class="params">(key, member)</span></span> ：member是否是名称为key的set的元素
<span class="function"><span class="title">sinter</span><span class="params">(key1, key2,…key N)</span></span> ：求交集
<span class="function"><span class="title">sinterstore</span><span class="params">(dstkey, (keys)</span></span>) ：求交集并将交集保存到dstkey的集合
<span class="function"><span class="title">sunion</span><span class="params">(key1, (keys)</span></span>) ：求并集
<span class="function"><span class="title">sunionstore</span><span class="params">(dstkey, (keys)</span></span>) ：求并集并将并集保存到dstkey的集合
<span class="function"><span class="title">sdiff</span><span class="params">(key1, (keys)</span></span>) ：求差集
<span class="function"><span class="title">sdiffstore</span><span class="params">(dstkey, (keys)</span></span>) ：求差集并将差集保存到dstkey的集合
<span class="function"><span class="title">smembers</span><span class="params">(key)</span></span> ：返回名称为key的set的所有元素
<span class="function"><span class="title">srandmember</span><span class="params">(key)</span></span> ：随机返回名称为key的set的一个元素
</code></pre><h3 id="对Hash操作的命令">对Hash操作的命令</h3><pre><code><span class="function"><span class="title">hset</span><span class="params">(key, field, value)</span></span>：向名称为key的hash中添加元素field
<span class="function"><span class="title">hget</span><span class="params">(key, field)</span></span>：返回名称为key的hash中field对应的value
<span class="function"><span class="title">hmget</span><span class="params">(key, (fields)</span></span>)：返回名称为key的hash中field i对应的value
<span class="function"><span class="title">hmset</span><span class="params">(key, (fields)</span></span>)：向名称为key的hash中添加元素field 
<span class="function"><span class="title">hincrby</span><span class="params">(key, field, integer)</span></span>：将名称为key的hash中field的value增加integer
<span class="function"><span class="title">hexists</span><span class="params">(key, field)</span></span>：名称为key的hash中是否存在键为field的域
<span class="function"><span class="title">hdel</span><span class="params">(key, field)</span></span>：删除名称为key的hash中键为field的域
<span class="function"><span class="title">hlen</span><span class="params">(key)</span></span>：返回名称为key的hash中元素个数
<span class="function"><span class="title">hkeys</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键
<span class="function"><span class="title">hvals</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键对应的value
<span class="function"><span class="title">hgetall</span><span class="params">(key)</span></span>：返回名称为key的hash中所有的键（field）及其对应的value
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/redis.jpg" class="img-logo"/></p>
<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优秀技术博文分享]]></title>
    <link href="http://www.52ff.cc/2015/03/10/%E4%BC%98%E7%A7%80%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87%E5%88%86%E4%BA%AB/"/>
    <id>http://www.52ff.cc/2015/03/10/优秀技术博文分享/</id>
    <published>2015-03-10T02:58:18.000Z</published>
    <updated>2015-03-23T01:37:03.000Z</updated>
    <content type="html"><![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>
<a id="more"></a>
<h3 id="Nginx+tomcat配置集群负载均衡">Nginx+tomcat配置集群负载均衡</h3><p><a href="http://ari.iteye.com/blog/833153" title="Nginx+tomcat配置集群负载均衡" target="_blank" rel="external">图文解说：Nginx+tomcat配置集群负载均衡</a> </p>
<h3 id="netty学习">netty学习</h3><p><a href="http://ifeve.com/netty-2-6/" target="_blank" rel="external">并发编程网netty教程</a></p>
<h3 id="hexo搭建博客">hexo搭建博客</h3><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo搭建博客全程指导</a></p>
<h3 id="Dubbo指南">Dubbo指南</h3><p><a href="http://alibaba.github.io/dubbo-doc-static/Home-zh.htm" target="_blank" rel="external">Dubo指南</a></p>
<h3 id="优秀个人csdn博客">优秀个人csdn博客</h3><p><a href="http://blog.csdn.net/yusiguyuan/" target="_blank" rel="external">鱼思故渊的专栏</a></p>
<p>随时更新</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文意在记录曾经阅读过的不错的博文，方便日后查找回顾：</p>]]>
    
    </summary>
    
      <category term="记录分享" scheme="http://www.52ff.cc/categories/%E8%AE%B0%E5%BD%95%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty几个核心类的概念和用法]]></title>
    <link href="http://www.52ff.cc/2015/03/05/netty%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/03/05/netty笔记第一篇/</id>
    <published>2015-03-05T13:37:48.000Z</published>
    <updated>2015-04-06T03:12:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"></p>
<p>本篇文章整理下Netty的10个核心类，列举这些类的概念以及他们的用法，以便更加熟悉的netty的结构，帮助自己和他人学习netty,日后新的理解也会不时补充进来。</p>
<a id="more"></a>
<h2 id="Bootstrap_or_ServerBootstrap">Bootstrap or ServerBootstrap</h2><p>  一个Netty程序开始于Bootstrap类,Bootstrap类是Netty提供的一个可以通过简单配置来设置或”引导”程序的一个很重要的类。当你需要连接客户端或服务器绑定指定端口时需要使用bootstrap.</p>
<ul>
<li>Bootstrap用来连接远程主机,有1个EventLoopGroup</li>
<li>ServerBootstrap用来绑定本地端口,有2个EventLoopGroup<br>一个EventLoopGroup负责接受新连接，一个EventLoopGroup负责已接收到连接</li>
</ul>
<h2 id="EventLoop">EventLoop</h2><p>EventLoop 是一个Channel执行实际工作的线程。当一个Channel注册后,Netty将这个Channel绑定到一个EventLoop,在Channel的生命周期内总是被绑定到一个EventLoop。<br>处理IO的工作由EventLoop管理</p>
<h2 id="EventLoopGroup">EventLoopGroup</h2><p>EventLoopGroup包含一个或多个EventLoop，可以理解为EventLoop是一个事件循环线程,而EventLoopGroup是一个事件循环集合</p>
<h2 id="ChannelPipeline">ChannelPipeline</h2><p>所有的Netty程序都是基于ChannelPipeline,ChannelPipeline上面用于添加ChannelHandler。<br>ChannelHandler会在程序的“引导”阶段被添加 ChannelPipeline中,并且被添加的顺序将决定处理数据的顺序。ChannelPipeline的作用我们可以理解为用来管理ChannelHandler的一个容器。<br>也可以理解为一个链状的列表。</p>
<p>例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(new MyServerHandler());</span><br></pre></td></tr></table></figure></p>
<h2 id="Channel">Channel</h2><p>Channel概念与java.nio.channel概念一致，用以连接IO设备（socket、文件等）的纽带，是数据传输的通道，传输API的核心是Channel接口,每个Channel都会分配一个ChannelPipeline和ChannelConfig。<br>对于每个新的通道,会创建一个新的ChannelPipeline并附加至通道。一旦连接,Channel和ChannelPipeline之间的耦合是永久性 的。Channel不能附加其他的ChannelPipeline或从ChannelPipeline分离。</p>
<h2 id="Future_or_ChannelFuture">Future or ChannelFuture</h2><h2 id="ChannelInitializer">ChannelInitializer</h2><p>ChannelInitializer类用来配置Handlers，通过ChannelPipeline来添加ChannelHandler的，ChannelInitializer自身也是一个ChannelHandler,在添加完其他的handlers之后会自动从ChannelPipeline中删除自己</p>
<h2 id="ChannelHandler">ChannelHandler</h2><p>Netty的ChannelHandler是你的应用程序中处理最多的，我们 可以理解为ChannelHandler是一段执行业务逻辑处理数据的代码,它们来来往往的通过ChannelPipeline。实际上,ChannelHandler是定义一个handler 的父接口，ChannelInboundHandler和ChannelOutboundHandler都实现ChannelHandler接口</p>
<ul>
<li>ChannelInboundHandler<br>入站的消息从ChannelPipeline的头部开始经过所有的ChannelInboundHandler处理</li>
<li>ChannelOutboundHandler<br>出站的消息从ChannelPipeline的尾部开始经过ChannelOutboundHandler处理</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8lq.com1.z0.glb.clouddn.com/nettylog.png" class="img-logo"/></p>
<p>本篇文章整理下Netty的10个核心类，列举这些类的概念以及他们的用法，以便更加熟悉的netty的结构，帮助自己和他人学习netty,日后新的理解也会不时补充进来。</p>]]>
    
    </summary>
    
      <category term="netty" scheme="http://www.52ff.cc/tags/netty/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="网络编程" scheme="http://www.52ff.cc/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第十篇(阻塞队列和栈)]]></title>
    <link href="http://www.52ff.cc/2015/03/05/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%8D%81%E7%AF%87-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <id>http://www.52ff.cc/2015/03/05/JAVA多线程第十篇-阻塞队列和栈/</id>
    <published>2015-03-05T12:53:09.000Z</published>
    <updated>2015-03-23T06:29:54.000Z</updated>
    <content type="html"><![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>
<a id="more"></a>
<p>下面使用ArrayBlockQueue来实现之前实现过的生产者消/费者模式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/** 定义一个盘子类，可以放鸡蛋和取鸡蛋 */  </span><br><span class="line">public class BigPlate &#123;  </span><br><span class="line">  </span><br><span class="line">    /** 装鸡蛋的盘子，大小为<span class="number">5</span> */  </span><br><span class="line">    private BlockingQueue&lt;Object&gt; eggs = new ArrayBlockingQueue&lt;Object&gt;(<span class="number">5</span>);  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋 */  </span><br><span class="line">    public void putEgg(Object egg) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            eggs.put(egg);// 向盘子末尾放一个鸡蛋，如果盘子满了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与put操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"放入鸡蛋"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 取鸡蛋 */  </span><br><span class="line">    public Object <span class="function"><span class="title">getEgg</span></span>() &#123;  </span><br><span class="line">        Object egg = null;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            egg = eggs.take();// 从盘子开始取一个鸡蛋，如果盘子空了，当前线程阻塞  </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 下面输出有时不准确，因为与take操作不是一个原子操作  </span><br><span class="line">        System.out.println(<span class="string">"拿到鸡蛋"</span>);  </span><br><span class="line">        <span class="built_in">return</span> egg;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /** 放鸡蛋线程 */  </span><br><span class="line">    static class AddThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">        private Object egg = new Object();  </span><br><span class="line">  </span><br><span class="line">        public AddThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.putEgg(egg);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** 取鸡蛋线程 */  </span><br><span class="line">    static class GetThread extends Thread &#123;  </span><br><span class="line">        private BigPlate plate;  </span><br><span class="line">  </span><br><span class="line">        public GetThread(BigPlate plate) &#123;  </span><br><span class="line">            this.plate = plate;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">            plate.getEgg();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        BigPlate plate = new BigPlate();  </span><br><span class="line">        // 先启动<span class="number">10</span>个放鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new AddThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 再启动<span class="number">10</span>个取鸡蛋线程  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(new GetThread(plate)).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
放入鸡蛋  
放入鸡蛋  
放入鸡蛋  
拿到鸡蛋  
放入鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
拿到鸡蛋  
</code></pre><p>从结果看，启动10个放鸡蛋线程和10个取鸡蛋线程，前5个放入鸡蛋的线程成功执行，到第6个，发现盘子满了，阻塞住，这时切换到取鸡蛋线程执行，成功实现了生产者/消费者模式。</p>
<p>对于阻塞栈，与阻塞队列相似。不同点在于栈是“后入先出”的结构，每次操作的是栈顶，而队列是“先进先出”的结构，每次操作的是队列头。<br>下面是一个简单例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) throws InterruptedException &#123; </span><br><span class="line">                BlockingDeque bDeque = new LinkedBlockingDeque(<span class="number">20</span>); </span><br><span class="line">                <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123; </span><br><span class="line">                        //将指定元素添加到此阻塞栈中，如果没有可用空间，将一直等待（如果有必要）。 </span><br><span class="line">                        bDeque.putFirst(i); </span><br><span class="line">                        System.out.println(<span class="string">"向阻塞栈中添加了元素:"</span> + i); </span><br><span class="line">                &#125; </span><br><span class="line">                System.out.println(<span class="string">"程序到此运行结束，即将退出----"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>BlockingQueue最终会有四种状况，抛出异常、返回特殊值、阻塞、超时<br>BlockingQueue是个接口，有如下实现类：</p>
<pre><code><span class="bullet">1. </span>ArrayBlockQueue：一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。
<span class="bullet">2. </span>LinkedBlockQueue：一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 
<span class="bullet">3. </span>PriorityBlockingQueue：类似于LinkedBlockingQueue，但其所含对象的排序不是FIFO，而是依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序。
<span class="bullet">4. </span>SynchronousQueue：同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。
</code></pre><p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第九篇(条件变量Condition)]]></title>
    <link href="http://www.52ff.cc/2015/03/04/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AF%87-Condition/"/>
    <id>http://www.52ff.cc/2015/03/04/JAVA多线程第九篇-Condition/</id>
    <published>2015-03-04T12:30:27.000Z</published>
    <updated>2015-03-23T06:29:26.000Z</updated>
    <content type="html"><![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>
<a id="more"></a>
<p>条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。 </p>
<p>而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。当调用signalAll()方法，又可以唤醒该条件下的等待的线程。有关Condition接口的API可以具体参考JavaAPI文档。</p>
<p>条件变量比较抽象，原因是他不是自然语言中的条件概念，而是程序控制的一种手段。</p>
<p>下面以一个银行存取款的模拟程序为例来揭盖Java多线程条件变量的神秘面纱：</p>
<p>有一个账户，多个用户（线程）在同时操作这个账户，有的存款有的取款，存款随便存，取款有限制，不能透支，任何试图透支的操作都将等待里面有足够存款才执行操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                Thread t1 = new SaveThread(<span class="string">"张三"</span>, myCount, <span class="number">2000</span>); </span><br><span class="line">                Thread t2 = new SaveThread(<span class="string">"李四"</span>, myCount, <span class="number">3600</span>); </span><br><span class="line">                Thread t3 = new DrawThread(<span class="string">"王五"</span>, myCount, <span class="number">2700</span>); </span><br><span class="line">                Thread t4 = new SaveThread(<span class="string">"老张"</span>, myCount, <span class="number">600</span>); </span><br><span class="line">                Thread t5 = new DrawThread(<span class="string">"老牛"</span>, myCount, <span class="number">1300</span>); </span><br><span class="line">                Thread t6 = new DrawThread(<span class="string">"胖子"</span>, myCount, <span class="number">800</span>); </span><br><span class="line">                //执行各个线程 </span><br><span class="line">                pool.execute(t1); </span><br><span class="line">                pool.execute(t2); </span><br><span class="line">                pool.execute(t3); </span><br><span class="line">                pool.execute(t4); </span><br><span class="line">                pool.execute(t5); </span><br><span class="line">                pool.execute(t6); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 存款线程类 </span><br><span class="line">*/ </span><br><span class="line">class SaveThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        SaveThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.saving(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 取款线程类 </span><br><span class="line">*/ </span><br><span class="line">class DrawThread extends Thread &#123; </span><br><span class="line">        private String name;                //操作人 </span><br><span class="line">        private MyCount myCount;        //账户 </span><br><span class="line">        private int x;                            //存款金额 </span><br><span class="line"></span><br><span class="line">        DrawThread(String name, MyCount myCount, int x) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.x = x; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                myCount.drawing(x, name); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 普通银行账户，不可透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;                         //账号 </span><br><span class="line">        private int cash;                             //账户余额 </span><br><span class="line">        private Lock lock = new ReentrantLock();                //账户锁 </span><br><span class="line">        private Condition _save = lock.newCondition();    //存款条件 </span><br><span class="line">        private Condition _draw = lock.newCondition();    //取款条件 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 存款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void saving(int x, String name) &#123; </span><br><span class="line">                lock.lock();                        //获取锁 </span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                        cash += x;                    //存款 </span><br><span class="line">                        System.out.println(name + <span class="string">"存款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                &#125; </span><br><span class="line">                _draw.signalAll();            //唤醒所有等待线程。 </span><br><span class="line">                lock.unlock();                    //释放锁 </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 取款 </span><br><span class="line">         * </span><br><span class="line">         * @param x        操作金额 </span><br><span class="line">         * @param name 操作人 </span><br><span class="line">         */ </span><br><span class="line">        public void drawing(int x, String name) &#123; </span><br><span class="line">                lock.lock();                                 //获取锁 </span><br><span class="line">                try &#123; </span><br><span class="line">                        <span class="keyword">if</span> (cash - x &lt; <span class="number">0</span>) &#123; </span><br><span class="line">                                _draw.await();             //阻塞取款操作 </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                                cash -= x;                     //取款 </span><br><span class="line">                                System.out.println(name + <span class="string">"取款"</span> + x + <span class="string">"，当前余额为"</span> + cash); </span><br><span class="line">                        &#125; </span><br><span class="line">                        _save.signalAll();             //唤醒所有存款操作 </span><br><span class="line">                &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                        e.printStackTrace(); </span><br><span class="line">                &#125; finally &#123; </span><br><span class="line">                        lock.unlock();                     //释放锁 </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>李四存款3600，当前余额为13600
张三存款2000，当前余额为15600
老张存款600，当前余额为16200
老牛取款1300，当前余额为14900
胖子取款800，当前余额为14100
王五取款2700，当前余额为11400
</code></pre><p>在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。<br>        这样看来，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition，下面引入API中的一段代码，加以说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;  </span><br><span class="line">   final Lock lock = new ReentrantLock();//锁对象  </span><br><span class="line">   final Condition notFull  = lock.newCondition();//写线程条件   </span><br><span class="line">   final Condition notEmpty = lock.newCondition();//读线程条件   </span><br><span class="line">  </span><br><span class="line">   final Object[] items = new Object[<span class="number">100</span>];//缓存队列  </span><br><span class="line">   int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;  </span><br><span class="line">  </span><br><span class="line">   public void put(Object x) throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == items.length)//如果队列满了   </span><br><span class="line">         notFull.await();//阻塞写线程  </span><br><span class="line">       items[putptr] = x;//赋值   </span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;//如果写索引写到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       ++count;//个数++  </span><br><span class="line">       notEmpty.signal();//唤醒读线程  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   public Object take() throws InterruptedException &#123;  </span><br><span class="line">     lock.lock();  </span><br><span class="line">     try &#123;  </span><br><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)//如果队列为空  </span><br><span class="line">         notEmpty.await();//阻塞读线程  </span><br><span class="line">       Object x = items[takeptr];//取值   </span><br><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;//如果读索引读到队列的最后一个位置了，那么置为<span class="number">0</span>  </span><br><span class="line">       --count;//个数--  </span><br><span class="line">       notFull.signal();//唤醒写线程  </span><br><span class="line">       <span class="built_in">return</span> x;  </span><br><span class="line">     &#125; finally &#123;  </span><br><span class="line">       lock.unlock();  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，下面分析一下代码的执行过程：</p>
<pre><code><span class="bullet">1. </span>一个写线程执行，调用put方法；
<span class="bullet">2. </span>判断count是否为100，显然没有100；
<span class="bullet">3. </span>继续执行，存入值；
<span class="bullet">4. </span>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；
<span class="bullet">5. </span>仅唤醒读线程阻塞队列中的一个；
<span class="bullet">6. </span>一个读线程执行，调用take方法；
<span class="bullet">7. </span>……
<span class="bullet">8. </span>仅唤醒写线程阻塞队列中的一个。
这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第八篇(锁对象Lock)]]></title>
    <link href="http://www.52ff.cc/2015/03/03/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87-%E9%94%81%E5%AF%B9%E8%B1%A1Lock/"/>
    <id>http://www.52ff.cc/2015/03/03/JAVA多线程第八篇-锁对象Lock/</id>
    <published>2015-03-03T13:45:28.000Z</published>
    <updated>2015-03-23T06:29:03.000Z</updated>
    <content type="html"><![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre><a id="more"></a>
<p>下面看个例子帮助我们理解锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                Lock lock = new ReentrantLock(); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newCachedThreadPool(); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private Lock myLock;                //执行操作所需的锁对象 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, Lock myLock) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //获取锁 </span><br><span class="line">                myLock.lock(); </span><br><span class="line">                //执行现金业务 </span><br><span class="line">                System.out.println(name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                System.out.println(name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                //释放锁，否则别的线程没有机会执行了 </span><br><span class="line">                myLock.unlock(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为<span class="number">6000</span>，当前金额为<span class="number">6000</span> 
张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">12000</span> 
张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">12000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">12000</span> 
张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为<span class="number">4000</span> 
张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4000</span>}账户，金额为<span class="number">800</span>，当前金额为<span class="number">4000</span> 
张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">800</span>，当前金额为<span class="number">4800</span> 
</code></pre><p>从上面的输出可以看到，利用锁对象太方便了，比直接在某个不知情的对象上用锁清晰多了。<br>但一定要注意的是，在获取了锁对象后，用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行。</p>
<p>上面提到的Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。</p>
<p>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                //创建并发访问的账户 </span><br><span class="line">                MyCount myCount = new MyCount(<span class="string">"95599200901215522"</span>, <span class="number">10000</span>); </span><br><span class="line">                //创建一个锁对象 </span><br><span class="line">                ReadWriteLock lock = new ReentrantReadWriteLock(<span class="literal">false</span>); </span><br><span class="line">                //创建一个线程池 </span><br><span class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊 </span><br><span class="line">                User u1 = new User(<span class="string">"张三"</span>, myCount, -<span class="number">4000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u2 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">6000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u3 = new User(<span class="string">"张三他弟"</span>, myCount, -<span class="number">8000</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u4 = new User(<span class="string">"张三"</span>, myCount, <span class="number">800</span>, lock, <span class="literal">false</span>); </span><br><span class="line">                User u5 = new User(<span class="string">"张三他爹"</span>, myCount, <span class="number">0</span>, lock, <span class="literal">true</span>); </span><br><span class="line">                //在线程池中执行各个用户的操作 </span><br><span class="line">                pool.execute(u1); </span><br><span class="line">                pool.execute(u2); </span><br><span class="line">                pool.execute(u3); </span><br><span class="line">                pool.execute(u4); </span><br><span class="line">                pool.execute(u5); </span><br><span class="line">                //关闭线程池 </span><br><span class="line">                pool.shutdown(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡的用户 </span><br><span class="line">*/ </span><br><span class="line">class User implements Runnable &#123; </span><br><span class="line">        private String name;                //用户名 </span><br><span class="line">        private MyCount myCount;        //所要操作的账户 </span><br><span class="line">        private int iocash;                 //操作的金额，当然有正负之分了 </span><br><span class="line">        private ReadWriteLock myLock;                //执行操作所需的锁对象 </span><br><span class="line">        private boolean ischeck;        //是否查询 </span><br><span class="line"></span><br><span class="line">        User(String name, MyCount myCount, int iocash, ReadWriteLock myLock, boolean ischeck) &#123; </span><br><span class="line">                this.name = name; </span><br><span class="line">                this.myCount = myCount; </span><br><span class="line">                this.iocash = iocash; </span><br><span class="line">                this.myLock = myLock; </span><br><span class="line">                this.ischeck = ischeck; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                <span class="keyword">if</span> (ischeck) &#123; </span><br><span class="line">                        //获取读锁 </span><br><span class="line">                        myLock.readLock().lock(); </span><br><span class="line">                        System.out.println(<span class="string">"读："</span> + name + <span class="string">"正在查询"</span> + myCount + <span class="string">"账户，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放读锁 </span><br><span class="line">                        myLock.readLock().unlock(); </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                        //获取写锁 </span><br><span class="line">                        myLock.writeLock().lock(); </span><br><span class="line">                        //执行现金业务 </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"正在操作"</span> + myCount + <span class="string">"账户，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        myCount.setCash(myCount.getCash() + iocash); </span><br><span class="line">                        System.out.println(<span class="string">"写："</span> + name + <span class="string">"操作"</span> + myCount + <span class="string">"账户成功，金额为"</span> + iocash + <span class="string">"，当前金额为"</span> + myCount.getCash()); </span><br><span class="line">                        //释放写锁 </span><br><span class="line">                        myLock.writeLock().unlock(); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 信用卡账户，可随意透支 </span><br><span class="line">*/ </span><br><span class="line">class MyCount &#123; </span><br><span class="line">        private String oid;         //账号 </span><br><span class="line">        private int cash;             //账户余额 </span><br><span class="line"></span><br><span class="line">        MyCount(String oid, int cash) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public String <span class="function"><span class="title">getOid</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Oid(String oid) &#123; </span><br><span class="line">                this.oid = oid; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public int <span class="function"><span class="title">getCash</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="built_in">set</span>Cash(int cash) &#123; </span><br><span class="line">                this.cash = cash; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        @Override </span><br><span class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123; </span><br><span class="line">                <span class="built_in">return</span> <span class="string">"MyCount&#123;"</span> + </span><br><span class="line">                                <span class="string">"oid='"</span> + oid + <span class="string">'\'</span><span class="string">' + </span><br><span class="line">                                ", cash=" + cash + </span><br><span class="line">                                '</span>&#125;<span class="string">'; </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">10000</span>}账户，金额为-<span class="number">4000</span>，当前金额为<span class="number">10000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户成功，金额为-<span class="number">4000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">6000</span>}账户，金额为-<span class="number">8000</span>，当前金额为<span class="number">6000</span> 
写：张三他弟操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户成功，金额为-<span class="number">8000</span>，当前金额为-<span class="number">2000</span> 
写：张三正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">2000</span>}账户，金额为<span class="number">800</span>，当前金额为-<span class="number">2000</span> 
写：张三操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户成功，金额为<span class="number">800</span>，当前金额为-<span class="number">1200</span> 
读：张三他爹正在查询MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，当前金额为-<span class="number">1200</span> 
写：张三他爹正在操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span>-<span class="number">1200</span>}账户，金额为<span class="number">6000</span>，当前金额为-<span class="number">1200</span> 
写：张三他爹操作MyCount{<span class="variable">oid=</span>'<span class="number">95599200901215522</span>', <span class="variable">cash=</span><span class="number">4800</span>}账户成功，金额为<span class="number">6000</span>，当前金额为<span class="number">4800</span>
</code></pre><p>在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks 包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<pre><code>Condition 将 Object 监视器方法（<span class="built_in">wait</span>、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 <span class="built_in">set</span> （<span class="built_in">wait</span>-<span class="built_in">set</span>）。
Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
</feed>