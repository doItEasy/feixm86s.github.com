<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[flyfish's Blog]]></title>
  <subtitle><![CDATA[才华配不上梦想就是所谓的迷茫]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.52ff.cc/"/>
  <updated>2015-03-19T03:40:50.000Z</updated>
  <id>http://www.52ff.cc/</id>
  
  <author>
    <name><![CDATA[xiangming]]></name>
    <email><![CDATA[feixm86s@126.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hello Blog]]></title>
    <link href="http://www.52ff.cc/2015/03/18/hello-blog/"/>
    <id>http://www.52ff.cc/2015/03/18/hello-blog/</id>
    <published>2015-03-17T16:14:01.000Z</published>
    <updated>2015-03-19T03:40:50.000Z</updated>
    <content type="html"><![CDATA[<p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结.<br><br>                </p>
<hr>
<a id="more"></a>
<h3 id="为什么是独立博客">为什么是独立博客</h3><p>早就有弄一个独立博客的想法，但是这是一件很花时间和精力的事情，平时忙于琐碎的工作，很难抽出时间玩这个。去年发现有朋友基于bootstrap给自己做了个人站点，发现也有些其他朋友使用markdown写内容再生成静态页面。看到朋友的站点后一下子就想行动起来了，一开始玩了jekyll,后来因为一个主题和node.js选择了hexo。<br>驱使我弄独立博客主要是这几个原因：<br>1.够酷，自己的域名，门面是自己的<br>2.独立，自由，可自定义成自己喜欢的个性的样式<br>3.不会像平台博客那样，平台一变差，博客也跟着变差，更不会有广告飞<br>4.更好的记录</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习领悟一个知识，较长一段时间未接触，是否感觉忘了大半，一时间想不出所以然？<br>学完的知识如果不使用或者不常常回顾，那么还不是自己的知识。<br>自己写的代码，6个月不看就是别人的代码。<br>所以要记下来自己学习过的东西方便自己查看和总结.<br><br>                </p>
<hr>]]>
    
    </summary>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[毛毛]]></title>
    <link href="http://www.52ff.cc/2015/03/13/%E6%AF%9B%E6%AF%9B/"/>
    <id>http://www.52ff.cc/2015/03/13/毛毛/</id>
    <published>2015-03-12T16:49:36.000Z</published>
    <updated>2015-03-17T16:18:40.000Z</updated>
    <content type="html"><![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>
<a id="more"></a>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/8ZOurTlgn8RrbWoXS*BZX1J6IOluDKqIy5HvNrz*mRg!/b/dOpJsHBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/fkm63QBXo93*gpIr1Ptdcxzlq0OuPkrqkBhY.WqXWmo!/b/dO7Uq3BnEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://a1.qpic.cn/psb?/V13e7Xsb3duNUs/1LhAJQ9mFIqvqEpzyCWwgXw0IS4e*MKVXzbCTxvUyNk!/b/dGTNrnBoEQAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
<p><img src="http://b196.photo.store.qq.com/psb?/V13e7Xsb3duNUs/A4Qe**YLZomvtFndrnmyZjMRJL41EAzOSfQQZaVLpE4!/b/dN*O1HQKPwAA&amp;bo=gAJVAwAAAAAFAPc!&amp;rf=viewer_4" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多图预警，晒晒咱家宝贝的照片，😄😄</p>]]>
    
    </summary>
    
      <category term="［宝宝］" scheme="http://www.52ff.cc/tags/%EF%BC%BB%E5%AE%9D%E5%AE%9D%EF%BC%BD/"/>
    
      <category term="随笔生活" scheme="http://www.52ff.cc/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程中为性能注意的地方]]></title>
    <link href="http://www.52ff.cc/2015/03/12/Java%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>http://www.52ff.cc/2015/03/12/Java编程中为了性能尽量要做到的一些地方/</id>
    <published>2015-03-12T09:32:47.000Z</published>
    <updated>2015-03-17T16:13:27.000Z</updated>
    <content type="html"><![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h3 id="1-_尽量在合适的场合使用单例">1. 尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：<br>第一，控制资源的使用，通过线程同步来控制资源的并发访问；<br>第二，控制实例的产生，以达到节约资源的目的；<br>第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
<h3 id="2-_尽量避免随意使用静态变量">2. 尽量避免随意使用静态变量</h3><pre><code class="bash">public class A{   
static B b = new B();   
}
</code></pre>
<p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h3 id="3-_尽量避免过多过常的创建Java对象">3. 尽量避免过多过常的创建Java对象</h3><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h3 id="4-_尽量使用final修饰符">4. 尽量使用final修饰符</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h3 id="5-_尽量使用局部变量">5. 尽量使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h3 id="6-_尽量处理好包装类型和基本类型两者的使用场所">6. 尽量处理好包装类型和基本类型两者的使用场所</h3><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。<br>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h3 id="7-_慎用synchronized，尽量减小synchronize的方法">7. 慎用synchronized，尽量减小synchronize的方法</h3><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h3 id="8-_尽量使用StringBuilder和StringBuffer进行字符串连接">8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h3><p>这个就不多讲了。</p>
<h3 id="9-_尽量不要使用finalize方法">9. 尽量不要使用finalize方法</h3><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h3 id="10-_尽量使用基本数据类型代替对象">10. 尽量使用基本数据类型代替对象</h3><p>String str = “hello”;<br>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；<br>String str = new String(“hello”);<br>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h3 id="11-_单线程应尽量使用HashMap、ArrayList">11. 单线程应尽量使用HashMap、ArrayList</h3><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h3 id="12-_尽量合理的创建HashMap">12. 尽量合理的创建HashMap</h3><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h3 id="13-_尽量减少对变量的重复计算">13. 尽量减少对变量的重复计算</h3><p>如<br>for(int i=0;i&lt;list.size();i++)<br>应该改为<br>for(int i=0,len=list.size();i&lt;len;i++)<br>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h3 id="14-_尽量避免不必要的创建">14. 尽量避免不必要的创建</h3><p>如<br>A a = new A();<br>if(i==1){list.add(a);}<br>应该改为<br>if(i==1){<br>A a = new A();<br>list.add(a);}</p>
<h3 id="15-_尽量在finally块中释放资源">15. 尽量在finally块中释放资源</h3><p>程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h3 id="16-_尽量使用移位来代替’a/b’的操作">16. 尽量使用移位来代替’a/b’的操作</h3><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效<br>如<br>int num = a / 4;<br>int num = a / 8;<br>应该改为<br>int num = a &gt;&gt; 2;<br>int num = a &gt;&gt; 3;<br>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h3 id="17-尽量使用移位来代替’a*b’的操作">17.尽量使用移位来代替’a*b’的操作</h3><p>同样的，对于’<em>‘操作，使用移位的操作将会更快和更有效<br>如<br>int num = a </em> 4;<br>int num = a * 8;<br>应该改为<br>int num = a &lt;&lt; 2;<br>int num = a &lt;&lt; 3;</p>
<h3 id="18-_尽量确定StringBuffer的容量">18. 尽量确定StringBuffer的容量</h3><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。<br>如：StringBuffer buffer = new StringBuffer(1000); </p>
<h3 id="19-_尽量早释放无用对象的引用">19. 尽量早释放无用对象的引用</h3><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。<br>例如：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
}
</code></pre>
<p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。但是如果是改成下面：</p>
<pre><code class="bash">Public void <span class="function"><span class="title">test</span></span>(){   
Object obj = new Object();   
……   
Obj=null;   
//执行耗时，耗内存操作；或调用耗时，耗内存的方法   
……   
}  
[java] view plaincopy
Public void <span class="function"><span class="title">test</span></span>(){  
Object obj = new Object();  
……  
Obj=null;  
//执行耗时，耗内存操作；或调用耗时，耗内存的方法  
……  
}
</code></pre>
<p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h3 id="20-_尽量避免使用二维数组">20. 尽量避免使用二维数组</h3><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h3 id="21-_尽量避免使用split">21. 尽量避免使用split</h3><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h3 id="22-_ArrayList_&amp;_LinkedList">22. ArrayList &amp; LinkedList</h3><p>一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h3 id="23-_尽量使用System-arraycopy_()代替通过来循环复制数组">23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h3><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h3 id="24-_尽量缓存经常使用的对象">24. 尽量缓存经常使用的对象</h3><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h3 id="25-_尽量避免非常大的内存分配">25. 尽量避免非常大的内存分配</h3><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h3 id="26-_慎用异常">26. 慎用异常</h3><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。<br>如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>系统运行一段时间老是内存溢出，除了增加启动内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wap网页css技巧篇1]]></title>
    <link href="http://www.52ff.cc/2015/03/12/wap%E7%BD%91%E9%A1%B5css%E6%8A%80%E5%B7%A7%E7%AF%871/"/>
    <id>http://www.52ff.cc/2015/03/12/wap网页css技巧篇1/</id>
    <published>2015-03-12T03:51:08.000Z</published>
    <updated>2015-03-19T04:46:23.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>
<a id="more"></a>
<h2 id="使用百分比">使用百分比</h2><h3 id="元素的高度和宽度按比例设置">元素的高度和宽度按比例设置</h3><p>手机的wap网页尽量使用百分比<br>1.按一定的百分比设置宽度，如width：100%<br>2.高度设置成0，如height:0<br>3.设置高度是宽度的一定比例，假设60%，则：padding-bottom:60%</p>
<h2 id="图片背景">图片背景</h2><h3 id="div设置图片背景">div设置图片背景</h3><p>示例： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nav&#123; background:url("images/nav.png") no-repeat; width: 100%; padding-bottom: 38.194% ;height: 0; background-size :cover; &#125;</span></span><br></pre></td></tr></table></figure>
<p>1.图片设置成撑满整个div，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-size : cover;</span><br></pre></td></tr></table></figure>
<p>2.图片在div中靠右显示，使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background-position :right top;</span><br></pre></td></tr></table></figure></p>
<h2 id="样式优先级">样式优先级</h2><h3 id="CSS样式优先级">CSS样式优先级</h3><p>一般情况下：<br>[1位重要标志位] &gt; [4位特殊性标志] &gt; 声明先后顺序<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!important &gt; [ id &gt; class &gt; tag ]</span><br></pre></td></tr></table></figure></p>
<p>使用!important可以改变优先级别为最高，其次是style对象，然后是id &gt; class &gt;tag ，另外，另外在同级样式按照申明的顺序后出现的样式具有高优先级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间负责公司冒泡市场的活动开发工作，需要在不同的机型上面做好适配，几天的开发下来，学习掌握了几个css的理念和技巧，下面总结分享下手机上开发网页的几个小技巧</p>]]>
    
    </summary>
    
      <category term="css" scheme="http://www.52ff.cc/tags/css/"/>
    
      <category term="html5" scheme="http://www.52ff.cc/tags/html5/"/>
    
      <category term="前端技术" scheme="http://www.52ff.cc/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第五篇(并发协作例子)]]></title>
    <link href="http://www.52ff.cc/2015/03/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87-%E5%B9%B6%E5%8F%91%E5%8D%8F%E4%BD%9C-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://www.52ff.cc/2015/03/12/JAVA多线程第五篇-并发协作-生产者消费者/</id>
    <published>2015-03-11T17:43:04.000Z</published>
    <updated>2015-03-19T17:50:10.000Z</updated>
    <content type="html"><![CDATA[<p>Java线程：并发协作-生产者消费者模型</p>
<p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：<br>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。<br>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。<br>3、当消费者发现仓储没产品可消费时候会通知生产者生产。<br>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
<a id="more"></a>
<p>此模型将要结合java.lang.Object的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">* Java线程：并发协作-生产者消费者模型 </span><br><span class="line">* </span><br><span class="line">*/</span><br><span class="line">public class Test &#123; </span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Godown godown = new Godown(<span class="number">30</span>); </span><br><span class="line">                Consumer c1 = new Consumer(<span class="number">50</span>, godown); </span><br><span class="line">                Consumer c2 = new Consumer(<span class="number">20</span>, godown); </span><br><span class="line">                Consumer c3 = new Consumer(<span class="number">30</span>, godown); </span><br><span class="line">                Producer p1 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p2 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p3 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p4 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p5 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p6 = new Producer(<span class="number">10</span>, godown); </span><br><span class="line">                Producer p7 = new Producer(<span class="number">80</span>, godown); </span><br><span class="line"></span><br><span class="line">                c1.start(); </span><br><span class="line">                c2.start(); </span><br><span class="line">                c3.start(); </span><br><span class="line">                p1.start(); </span><br><span class="line">                p2.start(); </span><br><span class="line">                p3.start(); </span><br><span class="line">                p4.start(); </span><br><span class="line">                p5.start(); </span><br><span class="line">                p6.start(); </span><br><span class="line">                p7.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 仓库 </span><br><span class="line">*/ </span><br><span class="line">class Godown &#123; </span><br><span class="line">        public static final int max_size = <span class="number">100</span>; //最大库存量 </span><br><span class="line">        public int curnum;     //当前库存量 </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">Godown</span></span>() &#123; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        Godown(int curnum) &#123; </span><br><span class="line">                this.curnum = curnum; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 生产指定数量的产品 </span><br><span class="line">         * </span><br><span class="line">         * @param neednum </span><br><span class="line">         */ </span><br><span class="line">        public synchronized void produce(int neednum) &#123; </span><br><span class="line">                //测试是否需要生产 </span><br><span class="line">                <span class="keyword">while</span> (neednum + curnum &gt; max_size) &#123; </span><br><span class="line">                        System.out.println(<span class="string">"要生产的产品数量"</span> + neednum + <span class="string">"超过剩余库存量"</span> + (max_size - curnum) + <span class="string">"，暂时不能执行生产任务!"</span>); </span><br><span class="line">                        try &#123; </span><br><span class="line">                                //当前的生产线程等待 </span><br><span class="line">                                <span class="built_in">wait</span>(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //满足生产条件，则进行生产，这里简单的更改当前库存量 </span><br><span class="line">                curnum += neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经生产了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                //唤醒在此对象监视器上等待的所有线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        /** </span><br><span class="line">         * 消费指定数量的产品 </span><br><span class="line">         * </span><br><span class="line">         * @param neednum </span><br><span class="line">         */ </span><br><span class="line">        public synchronized void consume(int neednum) &#123; </span><br><span class="line">                //测试是否可消费 </span><br><span class="line">                <span class="keyword">while</span> (curnum &lt; neednum) &#123; </span><br><span class="line">                        try &#123; </span><br><span class="line">                                //当前的生产线程等待 </span><br><span class="line">                                <span class="built_in">wait</span>(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //满足消费条件，则进行消费，这里简单的更改当前库存量 </span><br><span class="line">                curnum -= neednum; </span><br><span class="line">                System.out.println(<span class="string">"已经消费了"</span> + neednum + <span class="string">"个产品，现仓储量为"</span> + curnum); </span><br><span class="line">                //唤醒在此对象监视器上等待的所有线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 生产者 </span><br><span class="line">*/ </span><br><span class="line">class Producer extends Thread &#123; </span><br><span class="line">        private int neednum;                //生产产品的数量 </span><br><span class="line">        private Godown godown;            //仓库 </span><br><span class="line"></span><br><span class="line">        Producer(int neednum, Godown godown) &#123; </span><br><span class="line">                this.neednum = neednum; </span><br><span class="line">                this.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //生产指定数量的产品 </span><br><span class="line">                godown.produce(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* 消费者 </span><br><span class="line">*/ </span><br><span class="line">class Consumer extends Thread &#123; </span><br><span class="line">        private int neednum;                //生产产品的数量 </span><br><span class="line">        private Godown godown;            //仓库 </span><br><span class="line"></span><br><span class="line">        Consumer(int neednum, Godown godown) &#123; </span><br><span class="line">                this.neednum = neednum; </span><br><span class="line">                this.godown = godown; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                //消费指定数量的产品 </span><br><span class="line">                godown.consume(neednum); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>已经生产了10个产品，现仓储量为40 
已经生产了10个产品，现仓储量为50 
已经消费了50个产品，现仓储量为0 
已经生产了80个产品，现仓储量为80 
已经消费了30个产品，现仓储量为50 
已经生产了10个产品，现仓储量为60 
已经消费了20个产品，现仓储量为40 
已经生产了10个产品，现仓储量为50 
已经生产了10个产品，现仓储量为60 
已经生产了10个产品，现仓储量为70 
</code></pre><p>说明：<br>对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的wait方法，wait方法的作用是释放当前线程的所获得的锁，并调用对象的notifyAll() 方法，通知（唤醒）该对象上其他等待线程，使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。<br>notifyAll() 方法，起到的是一个通知作用，不释放锁，也不获取锁。只是告诉该对象上等待的线程“可以竞争执行了，都醒来去执行吧”。</p>
<p>本例仅仅是生产者消费者模型中最简单的一种表示，本例中，如果消费者消费的仓储量达不到满足，而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java线程：并发协作-生产者消费者模型</p>
<p>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，Hello World！都是最经典的例子。</p>
<p>实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。<br>对于此模型，应该明确一下几点：<br>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。<br>2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。<br>3、当消费者发现仓储没产品可消费时候会通知生产者生产。<br>4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简陋的RPC框架]]></title>
    <link href="http://www.52ff.cc/2015/03/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.52ff.cc/2015/03/11/一个简陋的RPC框架/</id>
    <published>2015-03-11T07:03:28.000Z</published>
    <updated>2015-03-12T15:55:35.000Z</updated>
    <content type="html"><![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>
<a id="more"></a>
<p>以下代码来自dubbo团队梁飞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.io.ObjectInputStream;  </span><br><span class="line">import java.io.ObjectOutputStream;  </span><br><span class="line">import java.lang.reflect.InvocationHandler;  </span><br><span class="line">import java.lang.reflect.Method;  </span><br><span class="line">import java.lang.reflect.Proxy;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * RpcFramework  </span><br><span class="line"> */  </span><br><span class="line">public class RpcFramework &#123;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 暴露服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param service 服务实现 </span><br><span class="line">     * @param port 服务端口 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    public static void <span class="built_in">export</span>(final Object service, int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (service == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"service instance == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Export service "</span> + service.getClass().getName() + <span class="string">" on port "</span> + port);  </span><br><span class="line">        ServerSocket server = new ServerSocket(port);  </span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                final Socket socket = server.accept();  </span><br><span class="line">                new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">                    @Override  </span><br><span class="line">                    public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            try &#123;  </span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                                try &#123;  </span><br><span class="line">                                    String methodName = input.readUTF();  </span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  </span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();  </span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                                    try &#123;  </span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);  </span><br><span class="line">                                        Object result = method.invoke(service, arguments);  </span><br><span class="line">                                        output.writeObject(result);  </span><br><span class="line">                                    &#125; catch (Throwable t) &#123;  </span><br><span class="line">                                        output.writeObject(t);  </span><br><span class="line">                                    &#125; finally &#123;  </span><br><span class="line">                                        output.close();  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125; finally &#123;  </span><br><span class="line">                                    input.close();  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125; finally &#123;  </span><br><span class="line">                                socket.close();  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125; catch (Exception e) &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;).start();  </span><br><span class="line">            &#125; catch (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 引用服务 </span><br><span class="line">     *  </span><br><span class="line">     * @param &lt;T&gt; 接口泛型 </span><br><span class="line">     * @param interfaceClass 接口类型 </span><br><span class="line">     * @param host 服务器主机名 </span><br><span class="line">     * @param port 服务器端口 </span><br><span class="line">     * @<span class="built_in">return</span> 远程服务 </span><br><span class="line">     * @throws Exception </span><br><span class="line">     */  </span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)  </span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == null)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Interface class == null"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (! interfaceClass.isInterface())  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"The "</span> + interfaceClass.getName() + <span class="string">" must be interface class!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (host == null || host.length() == <span class="number">0</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Host == null!"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span> || port &gt; <span class="number">65535</span>)  </span><br><span class="line">            throw new IllegalArgumentException(<span class="string">"Invalid port "</span> + port);  </span><br><span class="line">        System.out.println(<span class="string">"Get remote service "</span> + interfaceClass.getName() + <span class="string">" from server "</span> + host + <span class="string">":"</span> + port);  </span><br><span class="line">        <span class="built_in">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new <span class="function"><span class="title">InvocationHandler</span></span>() &#123;  </span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;  </span><br><span class="line">                Socket socket = new Socket(host, port);  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());  </span><br><span class="line">                    try &#123;  </span><br><span class="line">                        output.writeUTF(method.getName());  </span><br><span class="line">                        output.writeObject(method.getParameterTypes());  </span><br><span class="line">                        output.writeObject(arguments);  </span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                            Object result = input.readObject();  </span><br><span class="line">                            <span class="keyword">if</span> (result instanceof Throwable) &#123;  </span><br><span class="line">                                throw (Throwable) result;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            <span class="built_in">return</span> result;  </span><br><span class="line">                        &#125; finally &#123;  </span><br><span class="line">                            input.close();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; finally &#123;  </span><br><span class="line">                        output.close();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; finally &#123;  </span><br><span class="line">                    socket.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    String hello(String name);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;  </span><br><span class="line">  </span><br><span class="line">    public String hello(String name) &#123;  </span><br><span class="line">        <span class="built_in">return</span> <span class="string">"Hello "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">public class RpcProvider &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = new HelloServiceImpl();  </span><br><span class="line">        RpcFramework.export(service, <span class="number">1234</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class RpcConsumer &#123;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        HelloService service = RpcFramework.refer(HelloService.class, <span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i ++) &#123;  </span><br><span class="line">            String hello = service.hello(<span class="string">"World"</span> + i);  </span><br><span class="line">            System.out.println(hello);  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>简易描述RPC的基本工作原理：服务器启动了一个线程监听 Socket 端口, 有Socket访问了, 反序列化解析出<br>调用的Service 和method, 以及传入的参数,再用Socket 写回去。</p>
<p>客户端利用jdk的Proxy生成了一个代理类,在创建Proxy 时建立与服务器的Socket连接.<br>调用Proxy的方法时,向服务器发送数据,等待结果返回。</p>]]>
    
    </summary>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/tags/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
      <category term="RPC远程调用" scheme="http://www.52ff.cc/categories/RPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FAST基础命令安装配置]]></title>
    <link href="http://www.52ff.cc/2015/03/11/FastDFS%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/FastDFS常见命令/</id>
    <published>2015-03-11T06:20:08.000Z</published>
    <updated>2015-03-15T13:36:42.000Z</updated>
    <content type="html"><![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>
<a id="more"></a>
<h3 id="启动FastDFS">启动FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker: /usr/<span class="built_in">local</span>/bin/fdfs_trackered /etc/fdfs/tracker.conf</span><br><span class="line">storage: /usr/<span class="built_in">local</span>/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h3 id="关闭FastDFS">关闭FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_tracker</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/stop.sh /usr/<span class="built_in">local</span>/bin/fdfs_storage</span><br></pre></td></tr></table></figure>
<p>或者 killall fdfs_trackered(storaged)  ——-注意，千万不要使用-9强行杀死进程。</p>
<h3 id="重启FastDFS">重启FastDFS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracker:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_trackered</span><br><span class="line">storage:/usr/<span class="built_in">local</span>/bin/restart.sh /usr/<span class="built_in">local</span>/bin/fdfs_storaged</span><br></pre></td></tr></table></figure>
<h3 id="查看集群情况">查看集群情况</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h3 id="删除一个storage">删除一个storage</h3><p>在任意一台storage(tracker也可以) </p>
<pre><code class="bash">/usr/<span class="built_in">local</span>/bin/fdfs_monitor /etc/fdfs/storage.conf delete group2 <span class="number">20.12</span>.<span class="number">1.73</span>
</code></pre>
<h3 id="CentOS_6-2下fastDFS的完整安装和配置步骤">CentOS 6.2下fastDFS的完整安装和配置步骤</h3><p><a href="http://www.linuxidc.com/Linux/2012-12/75989.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-12/75989.htm</a></p>
<h3 id="FastDFS在Ubuntu下的安装，PHP客户端">FastDFS在Ubuntu下的安装，PHP客户端</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71459.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71459.htm</a></p>
<h3 id="FastDFS分布式文件服务器安装，及配置，测试">FastDFS分布式文件服务器安装，及配置，测试</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71458.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71458.htm</a></p>
<h3 id="FastDFS_整合Nginx问题整理">FastDFS 整合Nginx问题整理</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/71232.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/71232.htm</a></p>
<h3 id="CentOS下搭建FastDFS">CentOS下搭建FastDFS</h3><p><a href="http://www.linuxidc.com/Linux/2012-09/70995.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-09/70995.htm</a></p>
<h3 id="Ubuntu安装FastDFS全程记录">Ubuntu安装FastDFS全程记录</h3><p><a href="http://www.linuxidc.com/Linux/2012-03/56377.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2012-03/56377.htm</a></p>
<p>同事小伍哥对于FastDFS性能的测试结果如下:<br>如果用他自带的HTTP服务，并发500个下载60M的文件，服务器彻底失去响应。<br>使用Nginx+FastDFS，并发1000，下载60M的文件，内存占用不超过10M，服务器毫无压力</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。我们部门的应用商店产用FastDFS作为应用安装包和图片的存储。</p>
<p>它只能通过专有API对文件进行存取访问，不支持POSIX接口方式，不能mount使用。准确地讲，Google FS以及FastDFS、mogileFS、 HDFS、TFS等类Google FS都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p>]]>
    
    </summary>
    
      <category term="fastdfs" scheme="http://www.52ff.cc/tags/fastdfs/"/>
    
      <category term="分布式文件存储" scheme="http://www.52ff.cc/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis基础命令]]></title>
    <link href="http://www.52ff.cc/2015/03/11/redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.52ff.cc/2015/03/11/redis基础命令/</id>
    <published>2015-03-11T03:51:08.000Z</published>
    <updated>2015-03-19T17:05:26.000Z</updated>
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>
<a id="more"></a>
<h3 id="持久化">持久化</h3><pre><code><span class="built_in">save</span>：将数据同步保存到磁盘
bgsave：将数据异步保存到磁盘
lastsave：返回上次成功将数据保存到磁盘的Unix时戳
shundown：将数据同步保存到磁盘，然后关闭服务
</code></pre><h3 id="远程服务控制">远程服务控制</h3><pre><code><span class="keyword">info</span>：提供服务器的信息和统计
monitor：实时转储收到的请求
slaveof：改变复制策略设置
config：在运行时配置Redis服务器
</code></pre><h3 id="对value操作的命令">对value操作的命令</h3><pre><code><span class="function"><span class="title">exists</span><span class="params">(key)</span></span>：确认一个key是否存在
<span class="function"><span class="title">del</span><span class="params">(key)</span></span>：删除一个key
<span class="function"><span class="title">type</span><span class="params">(key)</span></span>：返回值的类型
<span class="function"><span class="title">keys</span><span class="params">(pattern)</span></span>：返回满足给定pattern的所有key
randomkey：随机返回key空间的一个
<span class="function"><span class="title">keyrename</span><span class="params">(old name, newname)</span></span>：重命名key
dbsize：返回当前数据库中key的数目
expire：设定一个key的活动时间（s）
ttl：获得一个key的活动时间
<span class="function"><span class="title">select</span><span class="params">(index)</span></span>：按索引查询
<span class="function"><span class="title">move</span><span class="params">(key, dbindex)</span></span>：移动当前数据库中的key到dbindex数据库
flushdb：删除当前选择数据库中的所有key
flushall：删除所有数据库中的所有key
</code></pre><h3 id="对String操作的命令">对String操作的命令</h3><pre><code><span class="operator"><span class="keyword">set</span>(<span class="keyword">key</span>, <span class="keyword">value</span>)：给数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予值<span class="keyword">value</span>
<span class="keyword">get</span>(<span class="keyword">key</span>)：返回数据库中名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>
getset(<span class="keyword">key</span>, <span class="keyword">value</span>)：给名称为<span class="keyword">key</span>的<span class="keyword">string</span>赋予上一次的<span class="keyword">value</span>
mget(key1, key2,…, <span class="keyword">key</span> N)：返回库中多个<span class="keyword">string</span>的<span class="keyword">value</span>
setnx(<span class="keyword">key</span>, <span class="keyword">value</span>)：添加<span class="keyword">string</span>，名称为<span class="keyword">key</span>，值为<span class="keyword">value</span>
setex(<span class="keyword">key</span>, <span class="keyword">time</span>, <span class="keyword">value</span>)：向库中添加<span class="keyword">string</span>，设定过期时间<span class="keyword">time</span>
mset(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：批量设置多个<span class="keyword">string</span>的值
msetnx(<span class="keyword">key</span> N, <span class="keyword">value</span> N)：如果所有名称为<span class="keyword">key</span> i的<span class="keyword">string</span>都不存在
incr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增<span class="number">1</span>操作
incrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>增加<span class="built_in">integer</span>
decr(<span class="keyword">key</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减<span class="number">1</span>操作
decrby(<span class="keyword">key</span>, <span class="built_in">integer</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>减少<span class="built_in">integer</span>
append(<span class="keyword">key</span>, <span class="keyword">value</span>)：名称为<span class="keyword">key</span>的<span class="keyword">string</span>的值附加<span class="keyword">value</span>
<span class="keyword">substr</span>(<span class="keyword">key</span>, <span class="keyword">start</span>, <span class="keyword">end</span>)：返回名称为<span class="keyword">key</span>的<span class="keyword">string</span>的<span class="keyword">value</span>的子串</span>
</code></pre><h3 id="对List操作的命令">对List操作的命令</h3><pre><code>rpush(key, value)：在名称为key的<span class="keyword">list</span>尾添加一个值为value的元素
lpush(key, value)：在名称为key的<span class="keyword">list</span>头添加一个值为value的 元素
llen(key)：返回名称为key的<span class="keyword">list</span>的长度
<span class="keyword">lrange</span>(key, start, end)：返回名称为key的<span class="keyword">list</span>中start至end之间的元素
ltrim(key, start, end)：截取名称为key的<span class="keyword">list</span>
<span class="keyword">lindex</span>(key, index)：返回名称为key的<span class="keyword">list</span>中index位置的元素
<span class="keyword">lset</span>(key, index, value)：给名称为key的<span class="keyword">list</span>中index位置的元素赋值
lrem(key, count, value)：删除count个key的<span class="keyword">list</span>中值为value的元素
lpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的首元素
rpop(key)：返回并删除名称为key的<span class="keyword">list</span>中的尾元素
blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
brpop(key1, key2,… key N, timeout)：rpop的block版本。
rpoplpush(srckey, dstkey)：返回并删除名称为srckey的<span class="keyword">list</span>的尾元素，并将该元素添加到名称为dstkey的<span class="keyword">list</span>的头部
</code></pre><h3 id="对Set操作的命令">对Set操作的命令</h3><pre><code><span class="function"><span class="title">sadd</span><span class="params">(key, member)</span></span>：向名称为key的set中添加元素member
<span class="function"><span class="title">srem</span><span class="params">(key, member)</span></span> ：删除名称为key的set中的元素member
<span class="function"><span class="title">spop</span><span class="params">(key)</span></span> ：随机返回并删除名称为key的set中一个元素
<span class="function"><span class="title">smove</span><span class="params">(srckey, dstkey, member)</span></span> ：移到集合元素
<span class="function"><span class="title">scard</span><span class="params">(key)</span></span> ：返回名称为key的set的基数
<span class="function"><span class="title">sismember</span><span class="params">(key, member)</span></span> ：member是否是名称为key的set的元素
<span class="function"><span class="title">sinter</span><span class="params">(key1, key2,…key N)</span></span> ：求交集
<span class="function"><span class="title">sinterstore</span><span class="params">(dstkey, (keys)</span></span>) ：求交集并将交集保存到dstkey的集合
<span class="function"><span class="title">sunion</span><span class="params">(key1, (keys)</span></span>) ：求并集
<span class="function"><span class="title">sunionstore</span><span class="params">(dstkey, (keys)</span></span>) ：求并集并将并集保存到dstkey的集合
<span class="function"><span class="title">sdiff</span><span class="params">(key1, (keys)</span></span>) ：求差集
<span class="function"><span class="title">sdiffstore</span><span class="params">(dstkey, (keys)</span></span>) ：求差集并将差集保存到dstkey的集合
<span class="function"><span class="title">smembers</span><span class="params">(key)</span></span> ：返回名称为key的set的所有元素
<span class="function"><span class="title">srandmember</span><span class="params">(key)</span></span> ：随机返回名称为key的set的一个元素
</code></pre><h3 id="对Hash操作的命令">对Hash操作的命令</h3><pre><code><span class="function"><span class="title">hset</span><span class="params">(key, field, value)</span></span>：向名称为key的hash中添加元素field
<span class="function"><span class="title">hget</span><span class="params">(key, field)</span></span>：返回名称为key的hash中field对应的value
<span class="function"><span class="title">hmget</span><span class="params">(key, (fields)</span></span>)：返回名称为key的hash中field i对应的value
<span class="function"><span class="title">hmset</span><span class="params">(key, (fields)</span></span>)：向名称为key的hash中添加元素field 
<span class="function"><span class="title">hincrby</span><span class="params">(key, field, integer)</span></span>：将名称为key的hash中field的value增加integer
<span class="function"><span class="title">hexists</span><span class="params">(key, field)</span></span>：名称为key的hash中是否存在键为field的域
<span class="function"><span class="title">hdel</span><span class="params">(key, field)</span></span>：删除名称为key的hash中键为field的域
<span class="function"><span class="title">hlen</span><span class="params">(key)</span></span>：返回名称为key的hash中元素个数
<span class="function"><span class="title">hkeys</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键
<span class="function"><span class="title">hvals</span><span class="params">(key)</span></span>：返回名称为key的hash中所有键对应的value
<span class="function"><span class="title">hgetall</span><span class="params">(key)</span></span>：返回名称为key的hash中所有的键（field）及其对应的value
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用，Redis已逐步取代memcached。</p>
<p>它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hashs（哈希类型）,下面我来分享一下redis的常用命令</p>]]>
    
    </summary>
    
      <category term="redis" scheme="http://www.52ff.cc/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.52ff.cc/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="no-sql" scheme="http://www.52ff.cc/categories/no-sql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty笔记第一篇]]></title>
    <link href="http://www.52ff.cc/2015/03/05/netty%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/03/05/netty笔记第一篇/</id>
    <published>2015-03-05T13:37:48.000Z</published>
    <updated>2015-03-15T14:03:15.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>]]>
    </summary>
    
      <category term="［netty nio］" scheme="http://www.52ff.cc/tags/%EF%BC%BBnetty-nio%EF%BC%BD/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第四篇(线程交互)]]></title>
    <link href="http://www.52ff.cc/2015/03/02/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87-%E7%BA%BF%E7%A8%8B%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.52ff.cc/2015/03/02/java多线程第四篇-线程交互/</id>
    <published>2015-03-01T17:24:43.000Z</published>
    <updated>2015-03-19T17:39:27.000Z</updated>
    <content type="html"><![CDATA[<p>线程交互是比较复杂的问题，SCJP要求不很基础：给定一个场景，编写代码来恰当使用等待、通知和通知所有线程。</p>
<p>一、线程交互的基础知识</p>
<p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：<br><a id="more"></a> </p>
<p>void notify()<br>唤醒在此对象监视器上等待的单个线程。<br>void notifyAll()<br>唤醒在此对象监视器上等待的所有线程。<br>void wait()<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<p>然，wait()还有另外两个重载方法：<br>void wait(long timeout)<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。<br>void wait(long timeout, int nanos)<br>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<p>以上这些方法是帮助线程传递线程关心的时间状态。</p>
<p>关于等待/通知，要记住的关键点是：<br>必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。<br>wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。</p>
<p>下面看个例子就明白了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class ThreadA &#123; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        ThreadB b = new ThreadB(); </span><br><span class="line">        //启动计算线程 </span><br><span class="line">        b.start(); </span><br><span class="line">        //线程A拥有b对象上的锁。线程为了调用<span class="built_in">wait</span>()或notify()方法，该线程必须是那个对象锁的拥有者 </span><br><span class="line">        synchronized (b) &#123; </span><br><span class="line">            try &#123; </span><br><span class="line">                System.out.println(<span class="string">"等待对象b完成计算。。。"</span>); </span><br><span class="line">                //当前线程A等待 </span><br><span class="line">                b.wait(); </span><br><span class="line">            &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.println(<span class="string">"b对象计算的总和是："</span> + b.total); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class ThreadB extends Thread &#123; </span><br><span class="line">    int total; </span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">        synchronized (this) &#123; </span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                total += i; </span><br><span class="line">            &#125; </span><br><span class="line">            //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒 </span><br><span class="line">            notify(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待对象b完成计算。。。<br>b对象计算的总和是：5050 </p>
<p>千万注意：<br>当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程荣然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。</p>
<p>二、多个线程在等待一个对象锁时候使用notifyAll()</p>
<p>在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。</p>
<p>下面给个例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Calculator extends Thread &#123; </span><br><span class="line">        int total; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                synchronized (this) &#123; </span><br><span class="line">                        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; </span><br><span class="line">                                total += i; </span><br><span class="line">                        &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                //通知所有在此对象上等待的线程 </span><br><span class="line">                notifyAll(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReaderResult extends Thread &#123; </span><br><span class="line">        Calculator c; </span><br><span class="line"></span><br><span class="line">        public ReaderResult(Calculator c) &#123; </span><br><span class="line">                this.c = c; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">                synchronized (c) &#123; </span><br><span class="line">                        try &#123; </span><br><span class="line">                                System.out.println(Thread.currentThread() + <span class="string">"等待计算结果。。。"</span>); </span><br><span class="line">                                c.wait(); </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                                e.printStackTrace(); </span><br><span class="line">                        &#125; </span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"计算结果为："</span> + c.total); </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123; </span><br><span class="line">                Calculator calculator = new Calculator(); </span><br><span class="line"></span><br><span class="line">                //启动三个线程，分别获取计算结果 </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                new ReaderResult(calculator).start(); </span><br><span class="line">                //启动计算线程 </span><br><span class="line">                calculator.start(); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>运行结果：
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]等待计算结果。。。 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]等待计算结果。。。 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">3</span>,<span class="number">5</span>,main]等待计算结果。。。 
Exception in thread <span class="string">"Thread-0"</span> java.lang.IllegalMonitorStateException: current thread not owner 
  at java.lang.Object.notifyAll(Native <span class="keyword">Method</span>) 
  at threadtest.Calculator.run(Calculator.java:<span class="number">18</span>) 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">1</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">2</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
<span class="keyword">Thread</span>[<span class="keyword">Thread</span>-<span class="number">3</span>,<span class="number">5</span>,main]计算结果为：<span class="number">5050</span> 
</code></pre><p>运行结果表明，程序中有异常，并且多次运行结果可能有多种输出结果。这就是说明，这个多线程的交互程序还存在问题。究竟是出了什么问题，需要深入的分析和思考，下面将做具体分析。</p>
<p>实际上，上面这个代码中，我们期望的是读取结果的线程在计算线程调用notifyAll()之前等待即可。 但是，如果计算线程先执行，并在读取结果线程等待之前调用了notify()方法，那么又会发生什么呢？这种情况是可能发生的。因为无法保证线程的不同部分将按照什么顺序来执行。幸运的是当读取线程运行时，它只能马上进入等待状态——它没有做任何事情来检查等待的事件是否已经发生。  ——因此，如果计算线程已经调用了notifyAll()方法，那么它就不会再次调用notifyAll()，——并且等待的读取线程将永远保持等待。这当然是开发者所不愿意看到的问题。</p>
<p>因此，当等待的事件发生时，需要能够检查notifyAll()通知事件是否已经发生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>线程交互是比较复杂的问题，SCJP要求不很基础：给定一个场景，编写代码来恰当使用等待、通知和通知所有线程。</p>
<p>一、线程交互的基础知识</p>
<p>线程交互知识点需要从java.lang.Object的类的三个方法来学习：<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写了个异或加密小程序]]></title>
    <link href="http://www.52ff.cc/2015/02/22/%E5%86%99%E4%BA%86%E4%B8%AA%E5%BC%82%E6%88%96%E5%8A%A0%E5%AF%86%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.52ff.cc/2015/02/22/写了个异或加密小程序/</id>
    <published>2015-02-22T13:40:50.000Z</published>
    <updated>2015-03-15T14:01:46.000Z</updated>
    <content type="html"><![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>
<a id="more"></a>
<p>代码如下，记录下以后review用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class XORCodec &#123;</span><br><span class="line">	private final static String key = <span class="string">"unisms"</span>;  //密钥</span><br><span class="line">	private static String EncodeType =<span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 加密(字节版)，字节异或后转<span class="number">16</span>进制</span><br><span class="line">	 * @param @throws UnsupportedEncodingException</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">53</span>:<span class="number">55</span></span><br><span class="line">	 */</span><br><span class="line">	public static String encrypt(String <span class="keyword">in</span>Str) throws UnsupportedEncodingException &#123;</span><br><span class="line"></span><br><span class="line">		byte[] b=<span class="keyword">in</span>Str.getBytes(EncodeType);</span><br><span class="line">		byte[] snNum = new byte[b.length];</span><br><span class="line">		byte[] c=key.getBytes();</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; b.length; i++, j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == c.length)</span><br><span class="line">				j = <span class="number">0</span>;</span><br><span class="line">			snNum[i] = (byte)(b[i] ^ c[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			result= byte2HexStr(snNum);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Title: 解密(字节版)，将<span class="number">16</span>进制字符串每<span class="number">2</span>位转成INT，再转成byte</span><br><span class="line">	 * @<span class="built_in">return</span> String</span><br><span class="line">	 * @date <span class="number">2012</span>-<span class="number">4</span>-<span class="number">24</span> 上午<span class="number">12</span>:<span class="number">54</span>:<span class="number">34</span></span><br><span class="line">	 */</span><br><span class="line">	public static String decrypt(String instr)&#123;</span><br><span class="line">		byte[] snNum=null;</span><br><span class="line">		byte[] c=null;</span><br><span class="line">		int len;</span><br><span class="line">		String result=<span class="string">""</span>;</span><br><span class="line">		try &#123;</span><br><span class="line">			len = instr.length()/<span class="number">2</span>;</span><br><span class="line">			snNum = new byte[len];</span><br><span class="line">			c=key.getBytes();</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++, j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (j == c.length)</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">				snNum[i] = (byte) ((byte)(Integer.parseInt(instr.substring(i*<span class="number">2</span>,i*<span class="number">2</span>+<span class="number">2</span>),<span class="number">16</span>)) ^ c[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			result=new String(snNum,EncodeType);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * bytes转换成十六进制字符</span><br><span class="line">	 */</span><br><span class="line">	public static String byte2HexStr(byte[] b)</span><br><span class="line">	&#123;</span><br><span class="line">		String stmp=<span class="string">""</span>;</span><br><span class="line">		StringBuilder sb = new StringBuilder(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span> (int n=<span class="number">0</span>;n&lt;b.length;n++)</span><br><span class="line">		&#123;</span><br><span class="line">			stmp = Integer.toHexString(b[n] &amp; <span class="number">0</span>xFF);//<span class="number">0</span>xFF即<span class="number">256</span>相当于<span class="number">11111111</span></span><br><span class="line">			sb.append((stmp.length()==<span class="number">1</span>)? <span class="string">"0"</span>+stmp : stmp);</span><br><span class="line">			sb.append(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> sb.toString().toUpperCase().trim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 加密(字符版)</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String encrypt2(String data)&#123;</span><br><span class="line">		int[] temp = new int[data.length()];</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		//循环需加密的字符串和密钥，分别从需加密字符串和密钥中获取一个字符进行异或</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;data.length();i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			temp[i] = data.charAt(i)^key.charAt(j);//需加密的字符串中一个字符和密钥中一个字符异或得到十进制的整数</span><br><span class="line">			str = Integer.toHexString(temp[i]);//将十进制转化成<span class="number">16</span>进制</span><br><span class="line">			<span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;//不足<span class="number">4</span>位的进行补零</span><br><span class="line">				str = <span class="string">"000"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">2</span>)&#123;</span><br><span class="line">				str = <span class="string">"00"</span>+str;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.length()==<span class="number">3</span>)&#123;</span><br><span class="line">				str = <span class="string">"0"</span>+str;</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(str);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span>  result.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @Description: 解密(字符版)</span><br><span class="line">	 * @throws</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	public static String decrypt2(String data)&#123;</span><br><span class="line">		char[] c=new char[data.length()/<span class="number">4</span>];//加密后的长度是原先的<span class="number">4</span>倍</span><br><span class="line">		StringBuffer result =new StringBuffer();</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;c.length;i++,j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==key.length())&#123;</span><br><span class="line">				j=<span class="number">0</span>;//重新循环取密钥中的字符</span><br><span class="line">			&#125;</span><br><span class="line">			int n = Integer.parseInt(data.substring(i*<span class="number">4</span>,i*<span class="number">4</span>+<span class="number">4</span>),<span class="number">16</span>);//将<span class="number">16</span>进制的字符串解析为整数，因为加密时不足<span class="number">4</span>位补到<span class="number">4</span>位，所以每四个进行一次转化</span><br><span class="line">			c[i]=(char)((char)n^key.charAt(j));//重新和密钥中字符异或还原成原先的字符</span><br><span class="line">			result.append(c[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> result.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>}</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前做有你短信服务端时因客户端是delphi写的，网上找的加密算法在某些字符在java和delphi的运行结果不一致，所以就干脆花了大半天时间写了一个异或加密类XORCodec,写完后对字节处理，以及16进制，二进制和十进制的转化增进了了解</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第三篇(线程同步synchronized和volatile)]]></title>
    <link href="http://www.52ff.cc/2015/02/19/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/02/19/JAVA多线程第三篇/</id>
    <published>2015-02-19T15:38:30.000Z</published>
    <updated>2015-03-19T17:14:04.000Z</updated>
    <content type="html"><![CDATA[<p>当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。” 首先我们创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。</p>
<a id="more"></a>
<h2 id="抛出问题">抛出问题</h2><h3 id="线程的安全和不安全">线程的安全和不安全</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Count &#123;  </span><br><span class="line">    private int num;  </span><br><span class="line">    public void <span class="function"><span class="title">count</span></span>() &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            num += i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-"</span> + num);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line">public class ThreadTest &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Runnable runnable = new <span class="function"><span class="title">Runnable</span></span>() &#123;  </span><br><span class="line">            Count count = new Count();  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                count.count();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            new Thread(runnable).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了10个线程，看一下输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span>-<span class="number">55</span>  </span><br><span class="line">Thread-<span class="number">1</span>-<span class="number">110</span>  </span><br><span class="line">Thread-<span class="number">2</span>-<span class="number">165</span>  </span><br><span class="line">Thread-<span class="number">4</span>-<span class="number">220</span>  </span><br><span class="line">Thread-<span class="number">5</span>-<span class="number">275</span>  </span><br><span class="line">Thread-<span class="number">6</span>-<span class="number">330</span>  </span><br><span class="line">Thread-<span class="number">3</span>-<span class="number">385</span>  </span><br><span class="line">Thread-<span class="number">7</span>-<span class="number">440</span>  </span><br><span class="line">Thread-<span class="number">8</span>-<span class="number">495</span>  </span><br><span class="line">Thread-<span class="number">9</span>-<span class="number">550</span></span><br></pre></td></tr></table></figure>
<p>只有Thread-0线程输出的结果是我们期望的，不安全的情况下输出的结果恰好是逐个递增的(其实是巧合，多运行几次，会产生不同的输出结果)，为什么会产生这样的结果呢，因为建立的Count对象是线程共享的，一个线程改变了其成员变量num值，下一个线程正巧读到了修改后的num，所以会递增输出。想得到我们期望的结果，有几种解决方案：</p>
<ol>
<li>将Count中num变成count方法的局部变量；</li>
<li>将线程类成员变量拿到run方法中，这时count引用是线程内的局部变量；</li>
</ol>
<p>上述测试，我们发现，存在成员变量的类用于多线程时是不安全的，不安全体现在这个成员变量可能发生非原子性的操作，而变量定义在方法内也就是局部变量是线程安全的。</p>
<h3 id="JAVA线程的两个特性，可见性和有序性">JAVA线程的两个特性，可见性和有序性</h3><p>要说明线程同步问题首先要说明Java线程的两个特性，可见性和有序性。多个线程之间是不能直接传递数据交互的，它们之间的交互只能通过共享变量来实现。拿上面的例子来说明，在多个线程之间共享了Count类的一个对象，这个对象是被创建在主内存(堆内存)中，每个线程都有自己的工作内存(线程栈)，工作内存存储了主内存Count对象的一个副本，当线程操作Count对象时，首先从主内存复制Count对象到工作内存中，然后执行代码count.count()，改变了num值，最后用工作内存Count刷新主内存Count。当一个对象在多个内存中都存在副本时，如果一个内存修改了共享变量，其它线程也应该能够看到被修改后的值，此为可见性。多个线程执行时，CPU对线程的调度是随机的，我们不知道当前程序被执行到哪步就切换到了下一个线程，一个最经典的例子就是银行汇款问题，先取款后汇款或者先汇款后取款，此为有序性。本文讲述了JDK5.0之前传统线程的同步方式，更高级的同步方式之后再叙述。<br>    下面同样用代码来展示一下线程同步问题。<br>    创建两个线程，执行同一个对象的输出方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TraditionalThreadSynchronized &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        final Outputter output = new Outputter();  </span><br><span class="line">        new <span class="function"><span class="title">Thread</span></span>() &#123;  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                output.output(<span class="string">"zhangsan"</span>);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">        new <span class="function"><span class="title">Thread</span></span>() &#123;  </span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;  </span><br><span class="line">                output.output(<span class="string">"lisi"</span>);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class Outputter &#123;  </span><br><span class="line">    public void output(String name) &#123;  </span><br><span class="line">        // TODO 为了保证对name的输出不是一个原子操作，这里逐个输出name的每个字符  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">            // Thread.sleep(<span class="number">10</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：zhlainsigsan</p>
<h2 id="synchronized">synchronized</h2><p>显然输出的字符串被打乱了，我们期望的输出结果是zhangsanlisi，这就是线程同步问题，我们希望output方法被一个线程完整的执行完之后再切换到下一个线程，Java中使用synchronized保证一段代码在多线程执行时是互斥的，有两种用法：</p>
<pre><code><span class="number">1.</span> 使用<span class="keyword">synchronized</span>将需要互斥的代码包含起来，并上一把锁。
</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    synchronized (this) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这把锁必须是需要互斥的多个线程间的共享对象，像下面的代码是没有意义的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    Object lock = new Object();  </span><br><span class="line">    synchronized (lock) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">            System.out.print(name.charAt(i));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次进入output方法都会创建一个新的lock，这个锁显然每个线程都会创建，没有意义。</p>
<pre><code><span class="number">2.</span> 将<span class="keyword">synchronized</span>加在需要互斥的方法上。
</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public synchronized void output(String name) &#123;  </span><br><span class="line">    // TODO 线程输出方法  </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;  </span><br><span class="line">        System.out.print(name.charAt(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式就相当于用this锁住整个方法内的代码块，如果用synchronized加在静态方法上，就相当于用××××.class锁住整个方法内的代码块。使用synchronized在某些情况下会造成死锁，死锁问题以后会说明。使用synchronized修饰的方法或者代码块可以看成是一个原子操作。<br>每个锁对(JLS中叫monitor)都有两个队列，一个是就绪队列，一个是阻塞队列，就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程，当一个线程被唤醒(notify)后，才会进入到就绪队列，等待CPU的调度，反之，当一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒，这个涉及到线程间的通信，下一篇博文会说明。看我们的例子，当第一个线程执行输出方法时，获得同步锁，执行输出方法，恰好此时第二个线程也要执行输出方法，但发现同步锁没有被释放，第二个线程就会进入就绪队列，等待锁被释放。一个线程执行互斥代码过程如下：</p>
<ol>
<li>获得同步锁；</li>
<li>清空工作内存；</li>
<li>从主内存拷贝对象副本到工作内存；</li>
<li>执行代码(计算或者输出等)；</li>
<li>刷新主内存数据；</li>
<li>释放同步锁。<br>所以，synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。</li>
</ol>
<h2 id="volatile">volatile</h2><p>volatile是第二种Java多线程同步的机制，根据JLS(Java LanguageSpecifications)的说法，一个变量可以被volatile修饰，在这种情况下内存模型(主内存和线程工作内存)确保所有线程可以看到一致的变量值，来看一段代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些线程执行one方法，另一些线程执行two方法，two方法有可能打印出j比i大的值，按照之前分析的线程执行过程分析一下：</p>
<ol>
<li>将变量i从主内存拷贝到工作内存；</li>
<li>改变i的值；</li>
<li>刷新主内存数据；</li>
<li>将变量j从主内存拷贝到工作内存；</li>
<li>改变j的值；</li>
<li>刷新主内存数据；<br>这个时候执行two方法的线程先读取了主存i原来的值又读取了j改变后的值，这就导致了程序的输出不是我们预期的结果，要阻止这种不合理的行为的一种方式是在one方法和two方法前面加上synchronized修饰符：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static synchronized void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static synchronized void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据前面的分析，我们可以知道，这时one方法和two方法再也不会并发的执行了，i和j的值在主内存中会一直保持一致，并且two方法输出的也是一致的。另一种同步的机制是在共享变量之前加上volatile：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Test &#123;  </span><br><span class="line">    static volatile int i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    static void <span class="function"><span class="title">one</span></span>() &#123;  </span><br><span class="line">        i++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static void <span class="function"><span class="title">two</span></span>() &#123;  </span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">" j="</span> + j);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>one方法和two方法还会并发的去执行，但是加上volatile可以将共享变量i和j的改变直接响应到主内存中，这样保证了主内存中i和j的值一致性，然而在执行two方法时，在two方法获取到i的值和获取到j的值中间的这段时间，one方法也许被执行了好多次，导致j的值会大于i的值。所以volatile可以保证内存可见性，不能保证并发有序性。<br>没有明白JLS中为什么使用两个变量来阐述volatile的工作原理，这样不是很好理解。volatile是一种弱的同步手段，相对于synchronized来说，某些情况下使用，可能效率更高，因为它不是阻塞的，尤其是读操作时，加与不加貌似没有影响，处理写操作的时候，可能消耗的性能更多些。但是volatile和synchronized性能的比较，我也说不太准，多线程本身就是比较玄的东西，依赖于CPU时间分片的调度，JVM更玄，还没有研究过虚拟机，从顶层往底层看往往是比较难看透的。在JDK5.0之前，如果没有参透volatile的使用场景，还是不要使用了，尽量用synchronized来处理同步问题，线程阻塞这玩意简单粗暴。另外volatile和final不能同时修饰一个字段，可以想想为什么。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们查看JDK API的时候，总会发现一些类说明写着，线程安全或者线程不安全，比如说StringBuilder中，有这么一句，“将StringBuilder 的实例用于多个线程是不安全的。如果需要这样的同步，则建议使用StringBuffer。” 首先我们创建一个线程不安全的类，然后在多线程中使用这个类，看看有什么效果。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL优化的几条建议]]></title>
    <link href="http://www.52ff.cc/2015/02/19/SQL%E4%BC%98%E5%8C%96%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%9D%A1%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/19/SQL优化的若干条技巧/</id>
    <published>2015-02-19T06:50:55.000Z</published>
    <updated>2015-03-19T17:03:21.000Z</updated>
    <content type="html"><![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>
<a id="more"></a>
<h3 id="选择最有效率的表名顺序_(只在基于规则的优化器中有效)_：">选择最有效率的表名顺序 (只在基于规则的优化器中有效) ：</h3><pre><code>ORACLE 的解析器按照从右到左的顺序处理 <span class="keyword">FROM</span> 子句中的表名， <span class="keyword">FROM</span> 子句中写在最右的表将被最先处理，所以我们需要把记录最少的表写在最右边。如果有<span class="number">3</span>个以上的表连接查询，那就需要选择交叉表写在最右，交叉表是指那个被其他表所引用的表。
简而言之：大表在前，小表在后
</code></pre><h3 id="WHERE子句中的连接顺序：">WHERE子句中的连接顺序：</h3><pre><code>ORACLE采用自下而上的顺序解析 <span class="keyword">WHERE</span> 子句,根据这个原理 , 表之间的连接必须写在其他 <span class="keyword">WHERE</span> 条件之前 , 那些可以过滤掉最大数量记录的条件必须写在 <span class="keyword">WHERE</span> 子句的末尾<span class="built_in">.</span>
</code></pre><h3 id="SELECT子句中避免使用’*’_：">SELECT子句中避免使用’*’ ：</h3><pre><code>ORACLE在解析的过程中,会将 <span class="string">'*'</span>  依次转换成所有的列名 ,  这个工作是通过查询数据字典完成的 , 这意味着将耗费更多的时间
</code></pre><h3 id="使用_DECODE_函数来减少处理时间：">使用 DECODE 函数来减少处理时间：</h3><pre><code>使用<span class="variable">DECODE</span> 函数可以避免重复扫描相同记录或重复连接相同的表 .
</code></pre><h3 id="删除重复记录：">删除重复记录：</h3><pre><code>最高效的删除重复记录方法 (因为使用了 ROWID) 例子：
<span class="operator"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span>  EMP E  <span class="keyword">WHERE</span>  E.ROWID &gt; (<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(X.ROWID) <span class="keyword">FROM</span>  EMP X  <span class="keyword">WHERE</span>  X.EMP_NO = E.EMP_NO);</span>
</code></pre><h3 id="用_TRUNCATE_替代_DELETE_：">用 TRUNCATE 替代 DELETE ：</h3><pre><code>当删除表中的记录时, 在通常情况下 ,  回滚段 (<span class="operator"><span class="keyword">rollback</span> segments)  用来存放可以被恢复的信息 .  如果你没有 <span class="keyword">COMMIT</span> 事务 ,ORACLE 会将数据恢复到删除之前的状态 (准确地说是恢复到执行删除命令之前的状况)  而当运用 <span class="keyword">TRUNCATE</span> 时 ,  回滚段不再存放任何可被恢复的信息 . 当命令运行后 , 数据不能被恢复 . 因此很少的资源被调用,执行时间也会很短.</span>
</code></pre><h3 id="尽量多使用_COMMIT_：">尽量多使用 COMMIT ：</h3><pre><code>只要有可能, 在程序中尽量多使用 <span class="operator"><span class="keyword">COMMIT</span>,  这样程序的性能得到提高 , 需求也会因为 <span class="keyword">COMMIT</span> 所释放的资源而减少 :
<span class="keyword">COMMIT</span>所释放的资源 :
a. 回滚段上用于恢复数据的信息
b. 被程序语句获得的锁
c. redo <span class="keyword">log</span> buffer 中的空间
d. ORACLE为管理上述 <span class="number">3</span> 种资源中的内部花费</span>
</code></pre><h3 id="用_Where_子句替换_HAVING_子句：">用 Where 子句替换 HAVING 子句：</h3><pre><code>避免使用HAVING 子句 , HAVING  只会在检索出所有记录之后才对结果集进行过滤 .  这个处理需要排序 , 总计等操作 . 如果能通过 WHERE 子句限制记录的数目 , 那就能减少这方面的开销.<span class="keyword">on</span> 、 <span class="keyword">where</span> 、 having 这三个都可以加条件的子句中， <span class="function_start"><span class="keyword">on</span></span> 是最先执行， <span class="keyword">where</span> 次之， having 最后
</code></pre><h3 id="用_EXISTS_替代_IN_、用_NOT_EXISTS_替代_NOT_IN_：">用 EXISTS 替代 IN 、用 NOT EXISTS 替代 NOT IN ：</h3><pre><code>在许多基于基础表的查询中, 为了满足一个条件 , 往往需要对另一个表进行联接 . 在这种情况下 ,  使用 EXISTS(或 <span class="keyword">NOT</span> EXISTS) 通常将提高查询的效率 . 在子查询中 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 子句将执行一个内部的排序和合并 .  无论在哪种情况下 ,<span class="keyword">NOT</span> <span class="keyword">IN</span> 都是最低效的  (因为它对子查询中的表执行了一个全表遍历 ).  为了避免使用 <span class="keyword">NOT</span> <span class="keyword">IN</span> , 我们可以把它改写成外连接 (Outer Joins) 或 <span class="keyword">NOT</span> EXISTS.

(高效)<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  EXISTS (<span class="keyword">SELECT</span>  ‘ X<span class="comment">'  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC =  ‘ MELB')</span>

(低效)<span class="keyword">SELECT</span>  * <span class="keyword">FROM</span>  EMP (基础表)  <span class="keyword">WHERE</span>  EMPNO &gt; <span class="number">0</span>  <span class="keyword">AND</span>  DEPTNO <span class="keyword">IN</span>(<span class="keyword">SELECT</span> DEPTNO  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span>  LOC =  ‘ MELB<span class="comment">')</span>
</code></pre><h3 id="使用表的别名_(Alias)_：">使用表的别名 (Alias) ：</h3><pre><code>当在SQL 语句中连接多个表时 ,  请使用表的别名并把别名前缀于每个 <span class="keyword">Column</span> 上 . 这样一来 , 就可以减少解析的时间并减少那些由 <span class="keyword">Column</span> 歧义引起的语法错误 .
</code></pre><h3 id="避免在索引列上使用计算．">避免在索引列上使用计算．</h3><pre><code>WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．
低效：
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPT  <span class="keyword">WHERE</span> SAL * <span class="number">12</span> &gt; <span class="number">25000</span>;</span>
高效:
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span> DEPT <span class="keyword">WHERE</span> SAL &gt; <span class="number">25000</span>/<span class="number">12</span>;</span>
</code></pre><h3 id="用_&gt;=_替代_&gt;">用 &gt;= 替代 &gt;</h3><pre><code>高效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  EMP  <span class="keyword">WHERE</span>  DEPTNO &gt;=<span class="number">4</span>
低效:
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;<span class="number">3</span>

两者的区别在于,  前者 DBMS 将直接跳到第一个 DEPT 等于 <span class="number">4</span> 的记录而后者将首先定位到 DEPTNO=<span class="number">3</span> 的记录并且向前扫描到第一个 DEPT 大于 <span class="number">3</span> 的记录 .
</code></pre><h3 id="减少对表的查询：">减少对表的查询：</h3><pre><code>在含有子查询的SQL 语句中 , 要特别注意减少对表的查询 . 例子：
    <span class="operator"><span class="keyword">SELECT</span>  TAB_NAME <span class="keyword">FROM</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> (TAB_NAME,DB_VER) = ( <span class="keyword">SELECT</span> TAB_NAME,DB_VER <span class="keyword">FROM</span>  TAB_COLUMNS  <span class="keyword">WHERE</span>  <span class="keyword">VERSION</span> = <span class="number">604</span>)</span>
</code></pre><h3 id="sql语句用大写的：">sql语句用大写的：</h3><pre><code>因为oracle 总是先解析 sql 语句，把小写的字母转换成大写的再执行
</code></pre><h3 id="在_java_代码中尽量少用连接符_“_＋_”_连接字符串！">在 java 代码中尽量少用连接符 “ ＋ ” 连接字符串！</h3><h3 id="避免在索引列上使用_NOT_：">避免在索引列上使用 NOT ：</h3><pre><code>我们要避免在索引列上使用<span class="literal">NOT</span>, <span class="literal">NOT</span> 会产生在和在索引列上使用函数相同的影响 .  当 ORACLE ” 遇到 ” <span class="literal">NOT</span>, 他就会停止使用索引转而执行全表扫描 .
</code></pre><h3 id="通过内部函数提高_SQL_效率：">通过内部函数提高 SQL 效率：</h3><pre><code>复杂的SQL 往往牺牲了执行效率 . 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的
</code></pre><h3 id="识别_‘_低效执行_‘_的_SQL_语句：">识别 ‘ 低效执行 ‘ 的 SQL 语句：</h3><pre><code>虽然目前各种关于SQL 优化的图形化工具层出不穷 , 但是写出自己的 SQL 工具来解决问题始终是一个最好的方法：
<span class="operator"><span class="keyword">SELECT</span>  EXECUTIONS , DISK_READS, BUFFER_GETS,
<span class="keyword">ROUND</span>((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) Hit_radio,
<span class="keyword">ROUND</span>(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,
SQL_TEXT
<span class="keyword">FROM</span>  V$SQLAREA
<span class="keyword">WHERE</span>  EXECUTIONS&gt;<span class="number">0</span>
<span class="keyword">AND</span>  BUFFER_GETS &gt; <span class="number">0</span>
<span class="keyword">AND</span>  (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span>
<span class="keyword">ORDER</span> <span class="keyword">BY</span>  <span class="number">4</span> <span class="keyword">DESC</span>;</span>
</code></pre><h3 id="用索引提高效率：">用索引提高效率：</h3><pre><code>索引是表的一个概念部分, 用来提高检索数据的效率， ORACLE 使用了一个复杂的自平衡 B-tree 结构 .  通常 , 通过索引查询数据比全表扫描要快 .  当 ORACLE 找出执行查询和 <span class="operator"><span class="keyword">Update</span> 语句的最佳路径时 , ORACLE 优化器将使用索引 .  同样在联结多个表时使用索引也可以提高效率 .  另一个使用索引的好处是 , 它提供了主键 (<span class="keyword">primary</span> <span class="keyword">key</span>) 的唯一性验证 . 。那些 LONG 或 LONG RAW 数据类型 ,  你可以索引几乎所有的列 .  通常 ,  在大型表中使用索引特别有效 .  当然 , 你也会发现 ,  在扫描小表时 , 使用索引同样能提高效率 .  虽然使用索引能得到查询效率的提高 , 但是我们也必须注意到它的代价 .  索引需要空间来存储 , 也需要定期维护 ,  每当有记录在表中增减或索引列被修改时 ,  索引本身也会被修改 .  这意味着每条记录的 <span class="keyword">INSERT</span> , <span class="keyword">DELETE</span> , <span class="keyword">UPDATE</span> 将为此多付出 <span class="number">4</span> , <span class="number">5</span>  次的磁盘 I/O .  因为索引需要额外的存储空间和处理 , 那些不必要的索引反而会使查询反应时间变慢 . 。定期的重构索引是有必要的 . <span class="keyword">ALTER</span>  <span class="keyword">INDEX</span> &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt;</span>
</code></pre><h3 id="用_UNION_替换_OR_(_适用于索引列_)">用 UNION 替换 OR ( 适用于索引列 )</h3><pre><code>通常情况下,  用 <span class="keyword">UNION</span> 替换 <span class="keyword">WHERE</span> 子句中的 <span class="keyword">OR</span> 将会起到较好的效果 .  对索引列使用 <span class="keyword">OR</span> 将造成全表扫描 .  注意 ,  以上规则只针对多个索引列有效 .  如果有 column 没有被索引 ,  查询效率可能会因为你没有选择 <span class="keyword">OR</span> 而降低 .  在下面的例子中 , LOC_ID  和 REGION 上都建有索引 .

高效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span>
<span class="keyword">UNION</span>
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> REGION = “ MELBOURNE ”
低效:
<span class="keyword">SELECT</span> LOC_ID , LOC_DESC , REGION
<span class="keyword">FROM</span> LOCATION
<span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> REGION = “ MELBOURNE ”
如果你坚持要用<span class="keyword">OR</span>,  那就需要返回记录最少的索引列写在最前面 .
</code></pre><h3 id="用_IN_来替换_OR">用 IN 来替换 OR</h3><pre><code>低效:
<span class="operator"><span class="keyword">SELECT</span>… . <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_ID = <span class="number">10</span> <span class="keyword">OR</span> LOC_ID = <span class="number">20</span> <span class="keyword">OR</span> LOC_ID = <span class="number">30</span>

高效
<span class="keyword">SELECT</span>…  <span class="keyword">FROM</span> LOCATION <span class="keyword">WHERE</span> LOC_IN  <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span>
</code></pre><h3 id="避免在索引列上使用_IS_NULL_和_IS_NOT_NULL">避免在索引列上使用 IS NULL 和 IS NOT NULL</h3><pre><code>避免在索引中使用任何可以为空的列，ORACLE 将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录 .  对于复合索引，如果每个列都为空，索引中同样不存在此记录 . 　如果至少有一个列不为空，则记录存在于索引中．举例 :  如果唯一性索引建立在表的 A 列和 B 列上 ,  并且表中存在一条记录的 A,B 值为 (123,null) , ORACLE 将不接受下一条具有相同 A,B 值 (123,null) 的记录 ( 插入 ).  然而如果所有的索引列都为空， ORACLE 将认为整个键值为空而空不等于空 .  因此你可以插入 1000  条具有相同键值的记录 , 当然它们都是空 !  因为空值不存在于索引列中 , 所以 WHERE 子句中对索引列进行空值比较将使 ORACLE 停用该索引 .

索引失效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span>
索引有效
<span class="operator"><span class="keyword">SELECT</span> …  <span class="keyword">FROM</span>  DEPARTMENT  <span class="keyword">WHERE</span>  DEPT_CODE &gt;=<span class="number">0</span>;</span>
</code></pre><h3 id="总是使用索引的第一个列：">总是使用索引的第一个列：</h3><pre><code>如果索引是建立在多个列上,  只有在它的第一个列 (leading column) 被 <span class="keyword">where</span> 子句引用时 , 优化器才会选择使用该索引 .  这也是一条简单而重要的规则，当仅引用索引的第二个列时 , 优化器使用了全表扫描而忽略了索引
</code></pre><h3 id="用_UNION-ALL_替换_UNION_(如果业务允许)_：">用 UNION-ALL  替换 UNION (如果业务允许) ：</h3><pre><code>当SQL  语句需要 <span class="keyword">UNION</span> 两个查询结果集合时 , 这两个结果集合会以 <span class="keyword">UNION</span>-ALL 的方式被合并 ,  然后在输出最终结果前进行排序 .  如果用 <span class="keyword">UNION</span> ALL 替代 <span class="keyword">UNION</span>,  这样排序就不是必要了 .  效率就会因此得到提高 .  需要注意的是， <span class="keyword">UNION</span> ALL  将重复输出两个结果集合中相同记录 .  因此各位还是要从业务需求分析使用 <span class="keyword">UNION</span> ALL 的可行性 . <span class="keyword">UNION</span>  将对结果集合排序 , 这个操作会使用到 SORT_AREA_SIZE 这块内存 .  对于这块内存的优化也是相当重要的 .  下面的 SQL 可以用来查询排序的消耗量
</code></pre><h3 id="用_WHERE_替代_ORDER_BY_：">用 WHERE 替代 ORDER BY ：</h3><pre><code><span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句只在两种严格的条件下使用索引
<span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序 <span class="built_in">.
</span><span class="keyword">ORDER</span> <span class="keyword">BY</span>中所有的列必须定义为非空 <span class="built_in">.
</span><span class="keyword">WHERE</span>子句使用的索引和 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中所使用的索引不能并列 <span class="built_in">.

</span>例如:
表DEPT 包含以下列 :
DEPT_CODE PK <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_DESC <span class="literal">NOT</span> <span class="built_in">NULL</span>
DEPT_TYPE <span class="built_in">NULL</span>

低效: ( 索引不被使用 
<span class="keyword">SELECT</span> DEPT_CODE FROM  DEPT  <span class="keyword">ORDER</span> <span class="keyword">BY</span>  DEPT_TYPE
高效: ( 使用索引 )
<span class="keyword">SELECT</span> DEPT_CODE  FROM  DEPT  <span class="keyword">WHERE</span>  DEPT_TYPE <span class="subst">&gt;</span> <span class="number">0</span>
</code></pre><h3 id="避免改变索引列的类型_:">避免改变索引列的类型 :</h3><pre><code>当比较不同数据类型的数据时, ORACLE 自动对列进行简单的类型转换 .
假设 EMPNO 是一个数值类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = ‘<span class="number">123</span><span class="comment">'</span>
实际上, 经过 ORACLE 类型转换 ,  语句转化为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span>  EMPNO = TO_NUMBER(‘<span class="number">123</span><span class="comment">')</span>
幸运的是, 类型转换没有发生在索引列上 , 索引的用途没有被改变 .
现在, 假设 EMP_TYPE 是一个字符类型的索引列 .
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  <span class="keyword">WHERE</span> EMP_TYPE = <span class="number">123</span>
这个语句被ORACLE 转换为 :
<span class="keyword">SELECT</span> …   <span class="keyword">FROM</span> EMP  WHERETO_NUMBER(EMP_TYPE)=<span class="number">12</span>    
因为内部发生的类型转换,  这个索引将不会被用到 !  为了避免 ORACLE 对你的 SQL 进行隐式的类型转换 ,  最好把类型转换用显式表现出来 .  注意当字符和数值比较时 , ORACLE 会优先转换数值类型到字符类型
</code></pre><h3 id="需要当心的_WHERE_子句_:">需要当心的 WHERE 子句 :</h3><pre><code>某些<span class="keyword">SELECT</span> 语句中的 <span class="keyword">WHERE</span> 子句不使用索引 . 这里有一些例子 .
在下面的例子里,
(<span class="number">1</span>)‘ !=<span class="comment">'  将不使用索引 .  记住 ,  索引只能告诉你什么存在于表中 ,  而不能告诉你什么不存在于表中 .</span>
(<span class="number">2</span>) ‘ ||<span class="comment">' 是字符连接函数 .  就象其他函数那样 ,  停用了索引 .</span>
(<span class="number">3</span>) ‘ +<span class="comment">' 是数学函数 .  就象其他数学函数那样 ,  停用了索引 .</span>
</code></pre><h3 id="使用索引">使用索引</h3><pre><code><span class="tag">a</span>. 如果检索数据量超过 <span class="number">30%</span> 的表中记录数 . 使用索引将没有显著的效率提高 . 
<span class="tag">b</span>. 在特定情况下, 使用索引也许会比全表扫描慢 ,  但这是同一个数量级上的区别 . 而通常情况下, 使用索引比全表扫描要块几倍乃至几千倍 ! 
</code></pre><h3 id="避免使用耗费资源的操作_:">避免使用耗费资源的操作 :</h3><pre><code>带有DISTINCT,UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span>,ORDER BY 的SQL 语句会启动 SQL引擎 
执行耗费资源的排序(<span class="keyword">SORT</span>)功能 . DISTINCT 需要一次排序操作,而其他的至少需要执行两次排序.通常,带有 UNION, <span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 的 SQL 语句都可以用其他方式重写.如果你的数据库的 SORT_AREA_SIZE调配得好,使用 UNION,<span class="keyword">MINUS</span>,<span class="keyword">INTERSECT</span> 也是可以考虑的,毕竟它们的可读性很强 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在工作的前两年，做的电信行业，开发主要是和oracle打交道的管理模块，特分享几条同事们整理的文档中的sql优化建议，主要是where条件怎么写和如何不破坏索引之类的小知识点。</p>]]>
    
    </summary>
    
      <category term="［sql］" scheme="http://www.52ff.cc/tags/%EF%BC%BBsql%EF%BC%BD/"/>
    
      <category term="sql数据库" scheme="http://www.52ff.cc/categories/sql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java反射简述一二]]></title>
    <link href="http://www.52ff.cc/2015/02/17/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <id>http://www.52ff.cc/2015/02/17/java反射机制简单整理/</id>
    <published>2015-02-17T14:19:16.000Z</published>
    <updated>2015-03-15T14:02:17.000Z</updated>
    <content type="html"><![CDATA[<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用他的方法？这些答案是肯定的，这种动态获取类的信息，以及动态调用类的方法的功能来源于JAVA的反射。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与 执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。</p>
<a id="more"></a>
<p>JAVA反射机制主要提供了以下功能(前提都是在运行时不是在编译时)：<br>1.判断任意一个对象所属的类<br>2.构造任意一个类的对象<br>3.判断任意一个类所具有的成员变量和方法<br>4.调用任意一个对象的方法(包括private)</p>
<p>Java 反射相关的API简介：<br>位于java.lang.reflect包中<br>—Class类：代表一个类<br>—Filed类：代表类的成员变量<br>—Method类：代表类的方法<br>—Constructor类：代表类的构造方法<br>—Array类：提供了动态创建数组，以及访问数组的元素的静态方法。该类中的所有方法都是静态方法</p>
<h3 id="Class类">Class类</h3><p>在 java 的Object类中的申明了数个应该在所有的java类中被改写的methods：<br>hashCode(), equals(),clone(),toString(),getClass()等，其中的getClass()返回一个Class 类型的对象。<br>Class类十分的特殊，它和一般的类一样继承自Object，其实体用以表达java程序运行时的class和interface，也用来表达 enum，array，primitive，Java Types 以及关键字void，当加载一个类，或者当加载器（class loader）的defineClass（）被JVM调用，便产生一个Class对象，<br>Class是Reflection起源，针对任何你想探勘的class（类），唯有现为他产生一个Class的对象，接下来才能经由后者唤起为数十多个的反射API。</p>
<p>Java允许我们从多种途径为一个类class生成对应的Class对象。<br>—运用 getClass()：Object类中的方法，每个类都拥有此方法<br>String str=”abc”;<br>Class cl=str.getClass();</p>
<p>—运用 Class.getSuperclass（）：Class类中的方法，返回该Class的父类的Class<br>—运用 Class.forName()静态方法：<br>—运用 Class：类名.class<br>—运用primitive wrapper classes的TYPE语法： 基本类型包装类的TYPE，如：Integer.TYPE<br>注意：TYPE的使用，只适合原生（基本）数据类型</p>
<p>——运行时生成instance</p>
<p>想生成对象的实体，在反射动态机制中有两种方法，一个针对无变量的构造方法，一个针对带参数的构造方法，如果想调用带参数的构造方法，就比较的麻烦，不能直接调用Class类中的newInstance()，而是调用Constructor类中newInstance（）方法，首先准备一个Class[]作为Constructor的参数类型。然后调用该Class对象的getConstructor()方法获得一个专属的Constructor的对象，最后再准备一个<br>Object[]作为Constructor对象昂的newInstance(()方法的实参。<br>在这里需要说明的是 只有两个类拥有newInstance()方法，分别是Class类和Constructor类<br>Class类中的newInstance()方法是不带参数的，而Constructro类中的newInstance()方法是带参数的<br>需要提供必要的参数。<br>例:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">"DynTest"</span>);</span><br><span class="line">Class[] ptype=new Class[]&#123;double.class,int.class&#125;；Constructor ctor=c.getConstructor(ptypr);</span><br><span class="line">Object[] obj=new Object[]&#123;new Double(<span class="number">3.1415</span>),new Integer(<span class="number">123</span>)&#125;;</span><br><span class="line">Object object=ctor.newInstance(obj);</span><br></pre></td></tr></table></figure></p>
<h3 id="运行时调用Method">运行时调用Method</h3><p>这个动作首先准备一个Class[]{}作为getMethod（String name，Class[]）方法的参数类型，接下来准备一个Obeject[]放置自变量，然后调用Method对象的invoke（Object obj，Object[]）方法。</p>
<h3 id="运行时调用Field内容">运行时调用Field内容</h3><p>变更Field不需要参数和自变量，首先调用Class的getField（）并指定field名称，获得特定的Field对象后便可以直接调用Field的 get（Object obj）和set(Object obj,Object value)方法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;        </span><br><span class="line">        Class&lt;?&gt; clazz = null;  </span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = User.class;  </span><br><span class="line">            Object obj=clazz.newInstance();  </span><br><span class="line">            ((User) obj).setUsername(<span class="string">"4"</span>);  </span><br><span class="line">            ((User) obj).setPassword(<span class="string">"2222"</span>); </span><br><span class="line">            //获取构造函数数组</span><br><span class="line">            Object[] constructors = clazz.getDeclaredConstructors();  </span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"----constructors["</span>+i+<span class="string">"]-----"</span>+constructors[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            //获取类中声明的字段数组，包括公有和私有字段&lt;br&gt;  </span><br><span class="line">            Field[] fields = clazz.getDeclaredFields();  </span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; fields.length; j++) &#123;  </span><br><span class="line">                String head = fields[j].getName().toUpperCase().substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                //获取属性的get方法名称</span><br><span class="line">                String getName = <span class="string">"get"</span> + head+ fields[j].getName().substring(<span class="number">1</span>);  </span><br><span class="line">                //获取属性的<span class="built_in">set</span>方法名称</span><br><span class="line">                String <span class="built_in">set</span>Name = <span class="string">"set"</span> + head+ fields[j].getName().substring(<span class="number">1</span>);  </span><br><span class="line">                //获取类中声明的方法数组，包括公有和私有方法</span><br><span class="line">                Method[] methods=clazz.getDeclaredMethods();  </span><br><span class="line">                <span class="keyword">for</span>(int m=<span class="number">0</span>;m&lt;methods.length;m++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"----method["</span>+m+<span class="string">"]------"</span>+methods[m].getName()); </span><br><span class="line">                 &#125;</span><br><span class="line">                //根据方法名称和参数，获取Method对象，第一个参数是方法名称，后边是一个Class数组，里边是方法参数类型</span><br><span class="line">                Method getMethod= clazz.getMethod(getName, new Class[] &#123;&#125;); </span><br><span class="line">                Method <span class="built_in">set</span>Method= clazz.getMethod(<span class="built_in">set</span>Name,new Class[]&#123; fields[j].getType() &#125;);</span><br><span class="line">                //obj -从中调用底层方法的对象,后边是用于方法调用的参数</span><br><span class="line">                Object result2=<span class="built_in">set</span>Method.invoke(obj, new Object[]&#123;new String(<span class="string">"hello  "</span>+fields[j].getName())&#125;);</span><br><span class="line">                Object result = getMethod.invoke(obj, new Object[] &#123;&#125;);</span><br><span class="line">                System.out.println(<span class="string">"----result------"</span> + result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (SecurityException e) &#123;            </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123; </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;  </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125; catch (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java类反射中的主要方法">Java类反射中的主要方法</h3><p>对于以下三类组件中的任何一类来说 — 构造函数、字段和方法 — java.lang.Class 提供四种独立的反射调用，以不同的方式来获得信息。调用都遵循一种标准格式。以下是用于查找构造函数的一组反射调用：<br>Constructor getConstructor(Class[] params) — 获得使用特殊的参数类型的公共构造函数，<br>Constructor[] getConstructors() — 获得类的所有公共构造函数<br>Constructor getDeclaredConstructor(Class[] params) — 获得使用特定参数类型的构造函数(与接入级别无关)<br>Constructor[] getDeclaredConstructors() — 获得类的所有构造函数(与接入级别无关)<br>获得字段信息的Class 反射调用不同于那些用于接入构造函数的调用，在参数类型数组中使用了字段名：<br>Field getField(String name) — 获得命名的公共字段<br>Field[] getFields() — 获得类的所有公共字段<br>Field getDeclaredField(String name) — 获得类声明的命名的字段<br>Field[] getDeclaredFields() — 获得类声明的所有字段<br>用于获得方法信息函数：<br>Method getMethod(String name, Class[] params) — 使用特定的参数类型，获得命名的公共方法<br>Method[] getMethods() — 获得类的所有公共方法<br>Method getDeclaredMethod(String name, Class[] params) — 使用特写的参数类型，获得类声明的命名的方法<br>Method[] getDeclaredMethods() — 获得类声明的所有方法 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用他的方法？这些答案是肯定的，这种动态获取类的信息，以及动态调用类的方法的功能来源于JAVA的反射。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代表链接。反射允许我们在编写与 执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IntelliJ Idea操作技巧]]></title>
    <link href="http://www.52ff.cc/2015/02/17/IntelliJ-Idea%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.52ff.cc/2015/02/17/IntelliJ-Idea操作技巧/</id>
    <published>2015-02-17T06:55:49.000Z</published>
    <updated>2015-03-19T03:41:48.000Z</updated>
    <content type="html"><![CDATA[<p>用了多年的eclipse,现在终于决定抛弃它了，转向了JetBrains公司的IntelliJ IDEA.原因是eclipse让我碰到了以下几个痛苦的事：<br>1:安装gradle,ivy构建工具麻烦且慢，myeclipse将近1G的大小svn、反编译这种功能还要新安装插件<br>2: myeclipse太耗内存了，两个myelipse一启动，电脑必来慢慢变卡，另外启动和build workspace的速度也有点不爽<br>3:代码助手的功能缺失，idea有live template这个神器，另外前端的js,css,html我已经转向另一个牛逼的工具HBulider</p>
<a id="more"></a>
<p>写这篇文章的主要目的是记录idea工具磨合期掌握的最实用技巧，因为网上的快捷键列举比较杂乱而且应用在mac上不靠谱，自己记下来可以备忘，回顾也方便，帮助自己精通这个工具。</p>
<p>ps:可使用ctrl+`切换keyMap，建议keyMap使用mac os x 10.5 +，使用default的在mac系统和其他快捷键冲突多些<br><br></p>
<hr>
<h3 id="搜索">搜索</h3><p>cmd+shift+f 当前项目下递归查找，相当于eclipse的ctrl+h<br>cmd+g       当前文件中往后搜索一样的字符，相当于eclipse的ctrl+ k<br>cmd+shift+g 当前文件中往前搜索一样的字符<br>cmd+p            查询某方法的参数信息<br>cmd+b            跳到调用方法的定义处<br>cmd+shift+b      跳到方法的实现处<br>cmd+u            跳到方法在父类或接口的定义处<br>cmd+alt+left/right 跳到上/下一次光标查看处<br>cmd+o        查找类<br>cmd+shift+o  查找文件<br><br></p>
<hr>
<h3 id="编辑">编辑</h3><p>cmd+j        调出IDEA的神器live template<br>cmd+n        各种自动生成代码<br>alt+enter    调出IDEA对出错点的提示处理方法，相当于eclipse的ctrl+1<br>cmd+D        复制粘贴当前行到下一行<br>shift+cmd+v  调出IDEA寄存器中保存的最近复制的N份内容，可选择性粘贴<br>ctrl+shift+/      注释/取消注释<br>shift+cmd+enter   补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用了多年的eclipse,现在终于决定抛弃它了，转向了JetBrains公司的IntelliJ IDEA.原因是eclipse让我碰到了以下几个痛苦的事：<br>1:安装gradle,ivy构建工具麻烦且慢，myeclipse将近1G的大小svn、反编译这种功能还要新安装插件<br>2: myeclipse太耗内存了，两个myelipse一启动，电脑必来慢慢变卡，另外启动和build workspace的速度也有点不爽<br>3:代码助手的功能缺失，idea有live template这个神器，另外前端的js,css,html我已经转向另一个牛逼的工具HBulider</p>]]>
    
    </summary>
    
      <category term="我的工具" scheme="http://www.52ff.cc/categories/%E6%88%91%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第二篇(状态转换)]]></title>
    <link href="http://www.52ff.cc/2015/02/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%88%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%89/"/>
    <id>http://www.52ff.cc/2015/02/12/JAVA多线程第二篇（状态转换）/</id>
    <published>2015-02-12T14:59:53.000Z</published>
    <updated>2015-03-19T17:14:32.000Z</updated>
    <content type="html"><![CDATA[<p>线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待/阻塞。<br><a id="more"></a></p>
<h2 id="线程状态">线程状态</h2><p>1、新状态：线程对象已经创建，还没有在其上调用start()方法。</p>
<p>2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</p>
<p>3、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
<p>4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。</p>
<p>5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</p>
<h2 id="阻止线程执行">阻止线程执行</h2><p>对于线程的阻止，考虑以下三个方面，不考虑IO阻塞的情况：<br>睡眠；<br>等待；<br>因为需要一个对象的锁定而被阻塞。</p>
<h3 id="睡眠">睡眠</h3><hr>
<p>Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread &#123; </span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123; </span><br><span class="line">                System.out.println(<span class="string">"-------"</span> + i); </span><br><span class="line">            &#125; </span><br><span class="line">            System.out.print(i); </span><br><span class="line">            try &#123; </span><br><span class="line">                Thread.sleep(<span class="number">1</span>); </span><br><span class="line">                System.out.print(<span class="string">"    线程睡眠1毫秒！\n"</span>); </span><br><span class="line">            &#125; catch (InterruptedException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        new MyThread().start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>1、线程睡眠是帮助所有线程获得运行机会的最好方法。<br>2、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。<br>3、sleep()是静态方法，只能控制当前正在运行的线程。</p>
<h3 id="线程的优先级和线程让步yield()">线程的优先级和线程让步yield()</h3><hr>
<p>线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。</p>
<p>注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。</p>
<p>当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。</p>
<p>设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过setPriority(int newPriority)更改线程的优先级。例如：<br>Thread t = new MyThread();<br>t.setPriority(8);<br>t.start();<br>线程优先级为1~10之间的正整数，JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。</p>
<p>线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：<br>static int MAX_PRIORITY<br>线程可以具有的最高优先级。<br>static int MIN_PRIORITY<br>线程可以具有的最低优先级。<br>static int NORM_PRIORITY<br>分配给线程的默认优先级。</p>
<h3 id="join()方法">join()方法</h3><hr>
<p>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。例如：<br>        Thread t = new MyThread();<br>        t.start();<br>        t.join();<br>另外，join()方法还有带超时限制的重载版本。 例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态</p>
<h2 id="小结">小结</h2><p>到目前位置，介绍了线程离开运行状态的3种方法：<br>1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。<br>2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。<br>3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</p>
<p>除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：<br>1、线程的run()方法完成。<br>2、在对象上调用wait()方法（不是在线程上调用）。<br>3、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。<br>4、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待/阻塞。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重写hashcode()与equals()]]></title>
    <link href="http://www.52ff.cc/2015/02/12/%E9%87%8D%E5%86%99hashcode()%E4%B8%8Eequals()/"/>
    <id>http://www.52ff.cc/2015/02/12/重写hashcode()与equals()/</id>
    <published>2015-02-12T03:51:08.000Z</published>
    <updated>2015-03-15T13:27:18.000Z</updated>
    <content type="html"><![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>
<a id="more"></a>
<p>首先，这两个方法都来自于Object对象，根据API文档查看下原意。(1)public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true；注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。（2）public int hashCode() 返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p>
<p>我的理解是hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写hashcode。为了保证这种一致性，必须满足以下两个条件：</p>
<p>(1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true<br>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class BeanA &#123;</span><br><span class="line">private int i;</span><br><span class="line">public BeanA(int i) &#123;</span><br><span class="line">   this.i = i;</span><br><span class="line">&#125;</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> <span class="string">"   "</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">   BeanA a = (BeanA) o;</span><br><span class="line">   <span class="built_in">return</span> (a.i == i) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">   <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HashCodeTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   HashSet&lt;BeanA&gt; <span class="built_in">set</span> = new HashSet&lt;BeanA&gt;();</span><br><span class="line">   <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    set.add(new BeanA(i));</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">   set.add(new BeanA(<span class="number">1</span>));</span><br><span class="line">   System.out.println(set.toString());</span><br><span class="line">   System.out.println(set.contains(new BeanA(<span class="number">0</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">1</span>)));</span><br><span class="line">   System.out.println(set.add(new BeanA(<span class="number">4</span>)));</span><br><span class="line">   System.out.println(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在类BeanA中重写了equals和hashcode方法，这样在存储到HashSet数据集中，将保证不会出现重复的数据；如果把这两个方法去掉后，那些重复的数据仍会存入HashSet中，这就与HashSet强调的元素唯一性相违背，大家可以把这两个方法注释掉再运行一下。<br>因此，我们就可以理解在一些java类中什么情况下需要重写equals和hashcode。比如：在hibernate的实体类中，往往通过一个主键（或唯一标识符）来判断数据库的某一行，这就需要重写这两个方法。因为，Hibernate保证，仅在特定会话范围内，持久化标识（数据库的行）和Java标识是等价的。因此，一旦我们混合了从不同会话中获取的实例，如果希望Set有明确的语义，就必 须实现equals() 和hashCode()。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浅谈为何要重写 hashcode()与equals()<br>我们知道，如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出，此时，利用equals比较八大包装对象（如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它对象都是比较的引用地址。那产生了一个问题，为什么jdk中希望我们在重写equals时，非常有必要重写hashcode呢？</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA多线程第一篇(概念和启动线程)]]></title>
    <link href="http://www.52ff.cc/2015/02/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.52ff.cc/2015/02/09/java多线程第一篇/</id>
    <published>2015-02-08T17:52:33.000Z</published>
    <updated>2015-03-19T17:15:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="进程和线程">进程和线程</h2><h3 id="操作系统中线程和进程">操作系统中线程和进程</h3><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。</p>
<p>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</p>
<p>“同时”执行是人的感觉，在线程之间实际上轮换执行。</p>
<h3 id="Java中的线程">Java中的线程</h3><p>在Java中，“线程”指两件不同的事情：<br>1、java.lang.Thread类的一个实例；<br>2、线程的执行。</p>
<p>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。</p>
<p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。</p>
<p>Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。</p>
<p>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。</p>
<p>一旦创建一个新的线程，就产生一个新的调用栈。</p>
<p>线程总体分两类：用户线程和守候线程。</p>
<p>当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。</p>
<h2 id="线程启动">线程启动</h2><p>1.实现Runnable接口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class DoSomething implements Runnable &#123; </span><br><span class="line">    private String name; </span><br><span class="line"></span><br><span class="line">    public DoSomething(String name) &#123; </span><br><span class="line">        this.name = name; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (long k = <span class="number">0</span>; k &lt; <span class="number">100000000</span>; k++) ; </span><br><span class="line">            System.out.println(name + <span class="string">": "</span> + i); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        DoSomething ds1 = new DoSomething(<span class="string">"阿三"</span>); </span><br><span class="line">        DoSomething ds2 = new DoSomething(<span class="string">"李四"</span>); </span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(ds1); </span><br><span class="line">        Thread t2 = new Thread(ds2); </span><br><span class="line"></span><br><span class="line">        t1.start(); </span><br><span class="line">        t2.start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.继承thread类<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class TestThread extends Thread&#123; </span><br><span class="line">    public TestThread(String name) &#123; </span><br><span class="line">        super(name); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123; </span><br><span class="line">            <span class="keyword">for</span>(long k= <span class="number">0</span>; k &lt;<span class="number">100000000</span>;k++); </span><br><span class="line">            System.out.println(this.getName()+<span class="string">" :"</span>+i); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        Thread t1 = new TestThread(<span class="string">"阿三"</span>); </span><br><span class="line">        Thread t2 = new TestThread(<span class="string">"李四"</span>); </span><br><span class="line">        t1.start(); </span><br><span class="line">        t2.start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FAQ">FAQ</h2><p>1、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。<br>2、获取当前线程的对象的方法是：Thread.currentThread()；<br>3、在一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。<br>4、当线程目标run()方法结束时该线程完成。<br>5、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。<br>6、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。<br>7、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。<br>8、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="进程和线程">进程和线程</h2><h3 id="操作系统中线程和进程">操作系统中线程和进程</h3><p>进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程]]>
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="多线程" scheme="http://www.52ff.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mina多线程池]]></title>
    <link href="http://www.52ff.cc/2012/02/15/mina%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.52ff.cc/2012/02/15/mina多线程池/</id>
    <published>2012-02-15T02:51:08.000Z</published>
    <updated>2015-03-15T13:27:36.000Z</updated>
    <content type="html"><![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>
<a id="more"></a>
<p>Mina 的多级线程池<br>在基于 SocketAcceptor 的应用程序中运行过程中 Mina 框架本身会有两种类型的线程在运行<br>一种是在SocketAcceptor 中创建的用于监听并接收来自客户端请求的线程。还有一类线程是处理客户端与服务器端 I/O 的线程即 Processor 的处理线程。后面还有第三类，就是过滤器层的线程。<br>这个多级的概念后面你会体会到Acceptor 是一级线程池而 Processor 的线程池主要通过 ExecutorFileter 进行添加当然可以添加多个层次的线程池。下面逐层进行讲解。</p>
<p>第一类线程池<br>当调用 SocketAcceptor 的 bind 方法时默认会创建一个名称前缀为 SocketAcceptor 的线程该线程负责监听来自客户端的请求如果接收到客户端的请求它仅仅是为处理这个请求做好准备而把具体处理请求以及I/O 的任务代理给 SocketIoProcessor 让它去处理请求。这个准备过程主要是为接受到的请求创建一个   IoSession 并构建出 IoFilter 链然后把准备好的数据以及来自客户端的请求交给 SocketIoProcessor 处理。通常 这类线程会针对每一次的 bind 调用创建一个新的线程。 请注意 “通常 ” 二字使用这两个字说明上述的行为不是绝对的。的确这不是绝对的这取决于SocketAcceptor 的字段 executor 的实现可以通过构造方法来设置字段 executor 的值 executor 字段的类型为 java.util.concurrent.Executor 。 mina 默认是用 org.apache.mina.util.NewThreadExecutor 它会为每一个提交的任务创建一个新的线程。因为在 bind 方法中它会把实现监听客户端请求任务的 Runnable 提交到 executor中去执行。注意千万不要使用一个不创建新线程而是在原线程中执行的 Executor 这会使程序无法监听客户端的请求因为程序中的唯一线程会被 Selector.get() 方法所阻塞详情可以查看 SocketAcceptor 类的源代码。</p>
<p>第二类线程池<br> 当 SocketAcceptor 收到了来自客户端的请求它就会把此请求丢给 SocketIoProcessor 去处理这会创建名称以 SocketAcceptorIoProcessor 为前缀的线程 mina 框架在这类线程中处理 I/O 发布并处理事件。这一类线程的数量可以通过 SocketAcceptor 的构造函数来设置。具体的值可以根据应用的具体需求来决定。 作为 I/O 真正处理的线程存在于服务器端和客户端用来处理 I/O 的读写操作线程的数量是可以配置的默认最大数量是 CPU 个数 +1 。 在服务器端中在创建 SocketAcceptor 的时候指定 ProcessorCount 。<br>SocketAcceptor acceptor = new SocketAcceptor(Runtime.getRuntime().availableProcessors() + 1, Executors.newCachedThreadPool()); NioProcessor 虽然是多线程但是对与一个连接的时候业务处理只会使用一个线程进行处理 Processor线程对于一个客户端连接只使用一个线程 NioProcessor-n 如果 handler 的业务比较耗时会导致NioProcessor 线程堵塞 在 2 个客户端同时连接上来的时候会创建第 2 个前提是第 1 个 NioProcessor 正在忙创建的最大数量由 Acceptor 构造方法的时候指定。如果一个客户端连接同服务器端有很多通信并且I/O 的开销不大但是 Handler 处理的业务时间比较长那么需要采用独立的线程模式在 FilterChain 的最后增加一个 ExecutorFitler 这个就是第三类线程池了。</p>
<p>第三类线程池<br>上述的两类线程是 mina 框架本身所创建的如果你的应用每次处理请求的时间较长而又希望应用能够有较好的响应性那么最好是把处理业务逻辑的任务放到一个新的线程中去执行而不是在 mina 框架创建的线程中去执行。 mina 框架本身提供了一个过滤器 ExecutorFilter 来完成这样的任务它会把在此之后的过滤器以及IoHandler 中处理业务逻辑的代码放到一个新的线程中去执行。当 mina 框架中的第二类线程执行完此过滤器后就会立即返回可以用于处理新的请求。如果不想使用此过滤器还可以设置 mina 的线程模型来达到相同的效果其实线程模型也是使用 ExecutorFilter 实现的。但需要注意的是在 mina 2.0 版本中已经废弃了线程模型。 使用类这三次线程池性能可以得到保证了在本项目中主要配置了第二类线程池和第三类线程池。第二类线程池在新建 NioAcceptor 对象以建立 TCP 监听服务器为例时候在其构造函数中体现而这个数值需要多次测试来设定其测试方法在国外网站有完整表述请自行 Google 第三类线程池设定在 Apache Mina 的过滤器层一般而言只需要设置一层设置在最消耗时间的业务前面如比较复杂的解码或者是数据库访问模块。 关于共享线程池问题 Apache Mina 有个官方说法你可以想让 IoServices 和 ExecutorFilters 共享一个线程池而不是一家一个。这个是不禁止的但是会出现很多问题在这种情况下除非你为 IoServices 建立一个缓冲线程池。 本人尚未考究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mina服务端的通信过程如下<br> 1 、通过 SocketAcceptor 同客户端建立连接<br> 2 、链接建立之后 I/O 的读写交给了 I/O Processor 线程 I/O Processor 是多线程的<br> 3 、通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter  IoFilter 进行消息的过滤格式的转换在这个层面可以制定一些自定义的协议；<br> 4 、最后 IoFilter 将数据交给 Handler 进行业务处理完成了整个读取的过程<br> 5 、写入过程也是类似只是刚好倒过来通过 IoSession.write 写出数据然后 Handler 进行写入的业务处理处理完成后交给 IoFilterChain 进行消息过滤和协议的转换最后通过 I/O Processor 将数据写出到 socket通道。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.52ff.cc/tags/java/"/>
    
      <category term="nio" scheme="http://www.52ff.cc/tags/nio/"/>
    
      <category term="java" scheme="http://www.52ff.cc/categories/java/"/>
    
  </entry>
  
</feed>